<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
NPC实现时的注意事项（1） | Posvirus&#39; Blog
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="YSYX学习笔记：NPC实现时的注意事项（1）">

<meta name="generator" content="Hugo 0.148.1">


<link rel="canonical" href="uildDrafts/post/ysyx-npc-note1/" >




<link href="uildDrafts/css/style.min.bd4aca9b9a5f6ce86d9d6ab6e6757498b0a0c742d1963f144557e59ca9d2da00.css" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" />



</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="/uildDrafts">
                <span>posvirus@github.io ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="uildDrafts/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="uildDrafts/blog" title="" >
                        ~/blog</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>NPC实现时的注意事项（1）</h1>
    
    	<p>YSYX学习笔记：NPC实现时的注意事项（1）</p>
    
    
    <section class="postMetadata">
        <dl>
            
                
<dt>tags</dt>
<dd><span></span>
    <a href="uildDrafts/tags/npc/">#NPC</a><span></span>
    <a href="uildDrafts/tags/nemu/">#NEMU</a></dd>
            
            
            
                
<dt>categories</dt>
<dd><span></span>
    <a href="uildDrafts/categories/ysyx/">YSYX</a></dd>
            
            
                <dt>published</dt>
                
                <dd><time datetime="2025-09-25">September 25, 2025</time></dd>
            
            
                <dt>reading time</dt>
                <dd>1 minute</dd>
            
        </dl>
    </section>
    
    <div>
        <p><strong>Created by posvirus, September 25th, 2025</strong></p>
<h3 id="1-npc指令的反汇编">1. NPC指令的反汇编</h3>
<p>当直接在NPC中使用<a href="https://github.com/capstone-engine/capstone/">capstone项目</a>提供的反汇编功能，并将NEMU中的<code>disasm.c</code>复制到NPC中，会出现报错。具体而言，我们需要对<code>disasm.c</code>中的几个函数指针进行显示强制类型转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>cs_err (<span style="color:#f92672">*</span>cs_open_dl)(cs_arch arch, cs_mode mode, csh <span style="color:#f92672">*</span>handle) <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>cs_open_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>cs_err (<span style="color:#f92672">*</span>)(cs_arch, cs_mode, csh<span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_open&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_open_dl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cs_disasm_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>size_t (<span style="color:#f92672">*</span>)(csh, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span>, size_t, <span style="color:#66d9ef">uint64_t</span>, size_t, cs_insn<span style="color:#f92672">**</span>)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_disasm&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_disasm_dl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cs_free_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(cs_insn<span style="color:#f92672">*</span>, size_t)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_free&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_free_dl);
</span></span></code></pre></div><h3 id="2-npc中sdb命令行的实现">2. NPC中sdb命令行的实现</h3>
<p>sdb命令行需要调用<code>readline.h</code>库实现，在C++中，由于readline是一个动态库，编译的时候需要加上<code>-lreadline</code>，不然会找不到相关的函数。并且，Verilator是直接使用g++编译的，需要将<code>-lreadline</code>写在编译命令的最后。</p>
<p>但是，我们是调用Verilator指令进行编译的，如何保证Verilator编译时<code>-lreadline</code>在命令的最后？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#75715e"># load readline library (used for sdb)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>VRC_INPUT <span style="color:#f92672">+=</span> -lreadline
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">run</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>VERILOG_INPUT<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VRC_INPUT<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	@rm -rf input.vc
</span></span><span style="display:flex;"><span>	@echo <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>INPUT_FLAG<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> | cat &gt; input.vc
</span></span><span style="display:flex;"><span>	@echo
</span></span><span style="display:flex;"><span>	@echo <span style="color:#e6db74">&#34;---------- VERILATE ----------&#34;</span>
</span></span><span style="display:flex;"><span>	@rm -rf <span style="color:#66d9ef">$(</span>OBJ_PATH<span style="color:#66d9ef">)</span>/*
</span></span><span style="display:flex;"><span>	@<span style="color:#66d9ef">$(</span>VERILATOR<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VERILATOR_FLAGS<span style="color:#66d9ef">)</span> --top-module <span style="color:#66d9ef">$(</span>VERILOG_TOP<span style="color:#66d9ef">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">$(</span>addprefix -CFLAGS , <span style="color:#66d9ef">$(</span>CXXFLAGS_VR<span style="color:#66d9ef">))</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		--Mdir <span style="color:#66d9ef">$(</span>OBJ_PATH<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VERILATOR_INPUT<span style="color:#66d9ef">)</span> $^
</span></span></code></pre></div><p>我们只需要把<code>-lreadline</code>添加在待编译的C++文件<code>VRC_INPUT</code>末尾即可。</p>
<h3 id="3-sdb扫描npc寄存器的实现">3. sdb扫描NPC寄存器的实现</h3>
<p>我们考虑通过DPI-C实现，请注意DPI-C实际上是双向的，即：我可以在RTL代码中调用C++中实现的函数（<code>import</code>），也可以在C++代码中调用RTL代码中定义的任务（<code>export</code>）。在sdb中实现扫描NPC寄存器显然属于后者，即我们需要在RTL代码中定义一个读取寄存器的任务，再在C++代码中调用该任务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>export <span style="color:#e6db74">&#34;DPI-C&#34;</span> <span style="color:#66d9ef">task</span> gpr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">task</span> gpr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">longint</span> addr; <span style="color:#75715e">// 64-bit space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">output</span> <span style="color:#66d9ef">longint</span> data; <span style="color:#75715e">// 64-bit space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (addr <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> {{(<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#66d9ef">`ysyx_25070184_DATA_WIDTH</span>){<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}}, cur_pc};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> {{(<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#66d9ef">`ysyx_25070184_DATA_WIDTH</span>){<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}}, u_ysyx_25070184_IDU.u_ysyx_25070184_RegisterFile.rf[addr[<span style="color:#66d9ef">`ysyx_25070184_REG_ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]]};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">endtask</span>
</span></span></code></pre></div><p>在实现该任务时，有以下几点需要注意：</p>
<ol>
<li>这里我们将任务名定义成<code>gpr</code>，这样我们就可以在C++代码中通过<code>gpr(N)</code>读取第<code>N</code>个寄存器的值，保持其与NEMU代码中的一致性。</li>
<li>我们将任务定义在顶层模块中，这样可以同时读取PC寄存器与通用寄存器。</li>
<li>为防止RTL代码与C++代码中复杂的类型转换，我们统一将<code>addr</code>与<code>data</code>类型定义为<code>longint</code>，这样可以直接映射至C++中的<code>long long</code>类型，且对32/64位的CPU均不会产生溢出。</li>
</ol>
    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2025 Posvirus&#39; Blog, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> and
            <a href="https://github.com/LordMathis/hugo-theme-nightfall" class="footerLink">Nightfall</a> theme
        </span>
    
</footer>
    </div>

</body>

</html>
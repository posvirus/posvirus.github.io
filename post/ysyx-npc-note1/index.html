<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
NPC实现时的注意事项（1） | Posvirus&#39; Blog
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="YSYX学习笔记：NPC实现时的注意事项（1）">

<meta name="generator" content="Hugo 0.148.1">


<link rel="canonical" href="https://posvirus.github.io/post/ysyx-npc-note1/" >




<link href="/css/style.min.bd4aca9b9a5f6ce86d9d6ab6e6757498b0a0c742d1963f144557e59ca9d2da00.css" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" />



</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="/">
                <span>posvirus@github.io ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://posvirus.github.io/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://posvirus.github.io/blog" title="" >
                        ~/blog</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>NPC实现时的注意事项（1）</h1>
    
    	<p>YSYX学习笔记：NPC实现时的注意事项（1）</p>
    
    
    <section class="postMetadata">
        <dl>
            
                
<dt>tags</dt>
<dd><span></span>
    <a href="/tags/npc/">#NPC</a><span></span>
    <a href="/tags/nemu/">#NEMU</a></dd>
            
            
            
                
<dt>categories</dt>
<dd><span></span>
    <a href="/categories/ysyx/">YSYX</a></dd>
            
            
                <dt>published</dt>
                
                <dd><time datetime="2025-09-25">September 25, 2025</time></dd>
            
            
                <dt>reading time</dt>
                <dd>2 minutes</dd>
            
        </dl>
    </section>
    
    <div>
        <p><strong>Created by posvirus, September 25th, 2025</strong></p>
<h3 id="1-npc指令的反汇编">1. NPC指令的反汇编</h3>
<p>当直接在NPC中使用<a href="https://github.com/capstone-engine/capstone/">capstone项目</a>提供的反汇编功能，并将NEMU中的<code>disasm.c</code>复制到NPC中，会出现报错。具体而言，我们需要对<code>disasm.c</code>中的几个函数指针进行显示强制类型转换：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span>cs_err (<span style="color:#f92672">*</span>cs_open_dl)(cs_arch arch, cs_mode mode, csh <span style="color:#f92672">*</span>handle) <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>cs_open_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>cs_err (<span style="color:#f92672">*</span>)(cs_arch, cs_mode, csh<span style="color:#f92672">*</span>)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_open&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_open_dl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cs_disasm_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span>size_t (<span style="color:#f92672">*</span>)(csh, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span>, size_t, <span style="color:#66d9ef">uint64_t</span>, size_t, cs_insn<span style="color:#f92672">**</span>)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_disasm&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_disasm_dl);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>cs_free_dl <span style="color:#f92672">=</span> <span style="color:#66d9ef">reinterpret_cast</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">void</span> (<span style="color:#f92672">*</span>)(cs_insn<span style="color:#f92672">*</span>, size_t)<span style="color:#f92672">&gt;</span>(dlsym(dl_handle, <span style="color:#e6db74">&#34;cs_free&#34;</span>));
</span></span><span style="display:flex;"><span>assert(cs_free_dl);
</span></span></code></pre></div><h3 id="2-npc中sdb命令行的实现">2. NPC中sdb命令行的实现</h3>
<p>sdb命令行需要调用<code>readline.h</code>库实现，在C++中，由于readline是一个动态库，编译的时候需要加上<code>-lreadline</code>，不然会找不到相关的函数。在Verilator中，我们可以直接使用<code>-LDFLAG</code>加载这一动态库。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#75715e"># load readline library (used for sdb)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>LDFLAGS_VR <span style="color:#f92672">+=</span> -lreadline
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">run</span><span style="color:#f92672">:</span> <span style="color:#66d9ef">$(</span>VERILOG_INPUT<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VRC_INPUT<span style="color:#66d9ef">)</span>
</span></span><span style="display:flex;"><span>	@rm -rf input.vc
</span></span><span style="display:flex;"><span>	@echo <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>INPUT_FLAG<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> | cat &gt; input.vc
</span></span><span style="display:flex;"><span>	@echo
</span></span><span style="display:flex;"><span>	@echo <span style="color:#e6db74">&#34;---------- VERILATE ----------&#34;</span>
</span></span><span style="display:flex;"><span>	@rm -rf <span style="color:#66d9ef">$(</span>OBJ_PATH<span style="color:#66d9ef">)</span>/*
</span></span><span style="display:flex;"><span>	@@<span style="color:#66d9ef">$(</span>VERILATOR<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VERILATOR_FLAGS<span style="color:#66d9ef">)</span> --top-module <span style="color:#66d9ef">$(</span>VERILOG_TOP<span style="color:#66d9ef">)</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">$(</span>addprefix -CFLAGS , <span style="color:#66d9ef">$(</span>CXXFLAGS_VR<span style="color:#66d9ef">))</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">$(</span>addprefix -LDFLAGS , <span style="color:#66d9ef">$(</span>LDFLAGS_VR<span style="color:#66d9ef">))</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		--Mdir <span style="color:#66d9ef">$(</span>OBJ_PATH<span style="color:#66d9ef">)</span> $^
</span></span></code></pre></div><h3 id="3-sdb扫描npc寄存器的实现">3. sdb扫描NPC寄存器的实现</h3>
<p>我们考虑通过DPI-C实现，请注意DPI-C实际上是双向的，即：我可以在RTL代码中调用C++中实现的函数（<code>import</code>），也可以在C++代码中调用RTL代码中定义的任务（<code>export</code>）。在sdb中实现扫描NPC寄存器显然属于后者，即我们需要在RTL代码中定义一个读取寄存器的任务，再在C++代码中调用该任务：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-verilog" data-lang="verilog"><span style="display:flex;"><span>export <span style="color:#e6db74">&#34;DPI-C&#34;</span> <span style="color:#66d9ef">task</span> gpr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">task</span> gpr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">input</span>  <span style="color:#66d9ef">longint</span> addr; <span style="color:#75715e">// 64-bit space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">output</span> <span style="color:#66d9ef">longint</span> data; <span style="color:#75715e">// 64-bit space
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (addr <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> {{(<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#66d9ef">`ysyx_25070184_DATA_WIDTH</span>){<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}}, cur_pc};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">begin</span>
</span></span><span style="display:flex;"><span>            data <span style="color:#f92672">=</span> {{(<span style="color:#ae81ff">64</span><span style="color:#f92672">-</span><span style="color:#66d9ef">`ysyx_25070184_DATA_WIDTH</span>){<span style="color:#ae81ff">1</span><span style="color:#ae81ff">&#39;b0</span>}}, u_ysyx_25070184_IDU.u_ysyx_25070184_RegisterFile.rf[addr[<span style="color:#66d9ef">`ysyx_25070184_REG_ADDR_WIDTH</span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">:</span><span style="color:#ae81ff">0</span>]]};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">end</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">endtask</span>
</span></span></code></pre></div><p>在实现该任务时，有以下几点需要注意：</p>
<ol>
<li>这里我们将任务名定义成<code>gpr</code>，这样我们就可以在C++代码中通过<code>gpr(N)</code>读取第<code>N</code>个寄存器的值，保持其与NEMU代码中的一致性。</li>
<li>我们将任务定义在顶层模块中，这样可以同时读取PC寄存器与通用寄存器。</li>
<li>为防止RTL代码与C++代码中复杂的类型转换，我们统一将<code>addr</code>与<code>data</code>类型定义为<code>longint</code>，这样可以直接映射至C++中的<code>long long</code>类型，且对32/64位的CPU均不会产生溢出。</li>
</ol>
<h3 id="4-verilator的优化输出">4. Verilator的优化输出</h3>
<p>Verilator编译的原始输出相对比较冗杂，难以在其中提取有效信息，我希望可以通过修改Makefile将其输出优化为NEMU的规整编译输出。但是NEMU是基于多个Makefile的嵌套，实现对项目的逐文件编译，在NPC中较难实现这一点（一般我们是将需要编译的文件一次性在Makefile中嵌入Verilator编译指令中）。</p>
<p>于是，我这里采用了一种取巧的方法，直接将Verilator的原始编译输出重定向并依据其输出格式进行信息提取，从而实现规整输出：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span><span style="color:#66d9ef">$(</span>VERILATOR<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VERILATOR_FLAGS<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">--top-module</span> <span style="color:#66d9ef">$(</span>VERILOG_TOP<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">$(</span>addprefix -CFLAGS , <span style="color:#66d9ef">$(</span>CXXFLAGS_VR<span style="color:#66d9ef">))</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">--Mdir</span> <span style="color:#66d9ef">$(</span>OBJ_PATH<span style="color:#66d9ef">)</span> <span style="color:#66d9ef">$(</span>VERILATOR_INPUT<span style="color:#66d9ef">)</span> <span style="color:#960050;background-color:#1e0010">$^</span> <span style="color:#960050;background-color:#1e0010">2&gt;&amp;1</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#960050;background-color:#1e0010">\</span>
</span></span><span style="display:flex;"><span>		<span style="color:#960050;background-color:#1e0010">while</span> IFS<span style="color:#f92672">=</span> read -r line; <span style="color:#66d9ef">do</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;g++&#34;</span>* <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			last_word<span style="color:#f92672">=</span>$$<span style="color:#f92672">(</span>echo <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> | awk <span style="color:#e6db74">&#39;{print $$NF}&#39;</span><span style="color:#f92672">)</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			<span style="color:#66d9ef">if</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">last_word&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;.cpp&#34;</span> <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>				echo <span style="color:#e6db74">&#34;[CXX] </span>$$<span style="color:#e6db74">last_word&#34;</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			<span style="color:#66d9ef">else</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>				echo <span style="color:#e6db74">&#34;[BUILD] </span>$$<span style="color:#e6db74">last_word&#34;</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			<span style="color:#66d9ef">fi</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;python3&#34;</span>* <span style="color:#f92672">]]</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;.cpp&#34;</span>* <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			echo <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> | grep -o <span style="color:#e6db74">&#39;[^ ]*\.cpp&#39;</span> | <span style="color:#66d9ef">while</span> read -r cpp_file; <span style="color:#66d9ef">do</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>				echo <span style="color:#e6db74">&#34;[PYTHON] verilator include: </span>$$<span style="color:#e6db74">cpp_file&#34;</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			<span style="color:#66d9ef">done</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">elif</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;echo&#34;</span>* <span style="color:#f92672">]]</span> <span style="color:#f92672">||</span> <span style="color:#f92672">[[</span> <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span> <span style="color:#f92672">==</span> *<span style="color:#e6db74">&#34;rm&#34;</span>* <span style="color:#f92672">]]</span>; <span style="color:#66d9ef">then</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			<span style="color:#66d9ef">continue</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">else</span> <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>			echo <span style="color:#e6db74">&#34;</span>$$<span style="color:#e6db74">line&#34;</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">fi</span>; <span style="color:#ae81ff">\
</span></span></span><span style="display:flex;"><span><span style="color:#ae81ff"></span>		<span style="color:#66d9ef">done</span>
</span></span></code></pre></div><h3 id="5-sdb退出指令的优化">5. sdb退出指令的优化</h3>
<p>在实现NPC时，发现NEMU sdb中的退出指令（q）有一个bug，原始的<code>cmd_q()</code>函数通常实现如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmd_q</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args) {
</span></span><span style="display:flex;"><span>  nemu_state.state <span style="color:#f92672">=</span> NEMU_QUIT;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这会导致在运行<code>am-kernels</code>中的测试程序时，如果没有使用批处理模式，且程序最终<code>HIT BAD TRAP</code>，此时直接使用退出指令退出，NEMU的状态会被重置为<code>NEMU_QUIT</code>，导致最后<code>is_exit_status_bad()</code>函数的返回值仍为<code>0</code>，这使得程序虽然测试失败，但最终仍会返回<code>PASS</code>的结果。</p>
<p>为此，我们需要额外对运行退出指令时NEMU的状态进行判断，如果程序非正常退出，则保持程序当前的状态：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cmd_q</span>(<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>args) {
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// if nemu hits bad trap, hold state
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> ((nemu_state.state <span style="color:#f92672">==</span> NEMU_ABORT) <span style="color:#f92672">||</span> 
</span></span><span style="display:flex;"><span>      ((nemu_state.state <span style="color:#f92672">==</span> NEMU_END) <span style="color:#f92672">&amp;&amp;</span> (nemu_state.halt_ret <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>))) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do nothing
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    nemu_state.state <span style="color:#f92672">=</span> NEMU_QUIT;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里其实还有另外一个问题，就是如果在程序运行过程中退出，是否需要保留当前NEMU的状态？此处我们暂时认为无需保留，即NEMU的状态会被重置为<code>NEMU_QUIT</code>，程序测试会返回<code>PASS</code>的结果。</p>
<h3 id="6-npc默认程序的日志输出">6. NPC默认程序的日志输出</h3>
<p>在NPC中直接运行默认程序，会发现每条日志输出都会在命令行中重复输出两次，这主要是因为在<code>init_log()</code>函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c++" data-lang="c++"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_log</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>log_file) {
</span></span><span style="display:flex;"><span>  log_fp <span style="color:#f92672">=</span> stdout;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (log_file <span style="color:#f92672">!=</span> NULL) {
</span></span><span style="display:flex;"><span>    FILE <span style="color:#f92672">*</span>fp <span style="color:#f92672">=</span> fopen(log_file, <span style="color:#e6db74">&#34;w&#34;</span>);
</span></span><span style="display:flex;"><span>    Assert(fp, <span style="color:#e6db74">&#34;Can not open &#39;%s&#39;&#34;</span>, log_file);
</span></span><span style="display:flex;"><span>    log_fp <span style="color:#f92672">=</span> fp;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  Log(<span style="color:#e6db74">&#34;Log is written to %s&#34;</span>, log_file <span style="color:#f92672">?</span> log_file : <span style="color:#e6db74">&#34;stdout&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p><code>log_fp</code>被初始化为<code>stdout</code>，这使得<code>log_write()</code>在调用<code>fprintf()</code>函数时，也会直接将日志输出至命令行中。</p>
<p>为解决这一点，我们只需在Makfile中加入：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">override</span> ARGS <span style="color:#f92672">?=</span> --log<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>BUILD_PATH<span style="color:#66d9ef">)</span>/npc-log.txt
</span></span></code></pre></div><p>使得运行NPC默认程序时的日志会输出至构建目录的<code>npc-log.txt</code>中即可。</p>
    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2025 Posvirus&#39; Blog, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> and
            <a href="https://github.com/LordMathis/hugo-theme-nightfall" class="footerLink">Nightfall</a> theme
        </span>
    
</footer>
    </div>

</body>

</html>
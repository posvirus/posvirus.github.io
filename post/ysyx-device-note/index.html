<!DOCTYPE html>
<html lang="en-us">

<head>
    <title>
NEMU的设备实现注意事项 | Posvirus&#39; Blog
</title>

    <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="YSYX学习笔记：NEMU的设备实现注意事项">

<meta name="generator" content="Hugo 0.148.1">


<link rel="canonical" href="https://posvirus.github.io/post/ysyx-device-note/" >




<link href="/css/style.min.bd4aca9b9a5f6ce86d9d6ab6e6757498b0a0c742d1963f144557e59ca9d2da00.css" rel="stylesheet">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" />



</head>

<body>

    <div class="flexWrapper">
        <header class="headerWrapper">
    <div class="header">
        <div>
            <a class="terminal" href="/">
                <span>posvirus@github.io ~ $</span>
            </a>
        </div>
        <input class="side-menu" type="checkbox" id="side-menu">
        <label class="hamb" for="side-menu"><span class="hamb-line"></span></label>
        <nav class="headerLinks">
            <ul>
                
                <li>
                    <a href="https://posvirus.github.io/about" title="" >
                        ~/about</a>
                </li>
                
                <li>
                    <a href="https://posvirus.github.io/blog" title="" >
                        ~/blog</a>
                </li>
                
            </ul>
        </nav>
    </div>
</header>


        <div class="content">
            <main class="main">
                
<div class="postWrapper">
    <h1>NEMU的设备实现注意事项</h1>
    
    	<p>YSYX学习笔记：NEMU的设备实现注意事项</p>
    
    
    <section class="postMetadata">
        <dl>
            
                
<dt>tags</dt>
<dd><span></span>
    <a href="/tags/nemu/">#NEMU</a><span></span>
    <a href="/tags/makefile/">#Makefile</a><span></span>
    <a href="/tags/am/">#AM</a><span></span>
    <a href="/tags/device/">#Device</a><span></span>
    <a href="/tags/clang/">#Clang</a></dd>
            
            
            
                
<dt>categories</dt>
<dd><span></span>
    <a href="/categories/ysyx/">YSYX</a></dd>
            
            
                <dt>published</dt>
                
                <dd><time datetime="2025-10-04">October 4, 2025</time></dd>
            
            
                <dt>reading time</dt>
                <dd>3 minutes</dd>
            
        </dl>
    </section>
    
    <div>
        <p><strong>Created by posvirus, October 4th, 2025</strong></p>
<h3 id="1-nemu中设备初始化的流程">1. NEMU中设备初始化的流程</h3>
<p>NEMU中各设备的初始化遵循一个统一的流程，以下将作简要说明：</p>
<p>首先，设备会调用<code>new_space()</code>函数，这会从I/O地址空间中分配指定大小的空间给该设备，该函数在<code>map.c</code>中实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>io_space <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>p_space <span style="color:#f92672">=</span> NULL;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uint8_t</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">new_space</span>(<span style="color:#66d9ef">int</span> size) {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>p <span style="color:#f92672">=</span> p_space;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// page aligned;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  size <span style="color:#f92672">=</span> (size <span style="color:#f92672">+</span> (PAGE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>PAGE_MASK;
</span></span><span style="display:flex;"><span>  p_space <span style="color:#f92672">+=</span> size;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert</span>(p_space <span style="color:#f92672">-</span> io_space <span style="color:#f92672">&lt;</span> IO_SPACE_MAX);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> p;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>为解释该函数的作用，我们首先需要明确<code>map.c</code>中另一个函数<code>init_map()</code>的作用，该函数在<code>device.c</code>中的<code>init_device()</code>函数中被调用，用于初始化I/O地址空间，在完成初始化后才会调用各设备的初始化函数，将地址空间分配给各个设备。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init_map</span>() {
</span></span><span style="display:flex;"><span>  io_space <span style="color:#f92672">=</span> <span style="color:#a6e22e">malloc</span>(IO_SPACE_MAX);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert</span>(io_space);
</span></span><span style="display:flex;"><span>  p_space <span style="color:#f92672">=</span> io_space;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这里<code>init_map()</code>函数通过<code>malloc()</code>函数创建了一个大小为<code>IO_SPACE_MAX</code>的空间，并将<code>p_space</code>与<code>io_space</code>均指向该空间起始位置。这里<code>p_space</code>实际用于指示当前未分配空间的起始位置，<code>io_space</code>则始终执行I/O地址空间的起始位置。</p>
<blockquote>
<p>注意，I/O地址空间在NEMU整个生命周期中都需要存在，且当NEMU退出时，操作系统会自动回收所有分配的内存，所以我们无需手动释放动态分配的空间。</p></blockquote>
<p>随后在设备初始化中调用<code>new_space()</code>函数，它会首先将<code>p_space</code>赋值给指针<code>p</code>，即将<code>p</code>指向当前未分配空间的起始位置，也是即将分配给该设备空间的初始位置。随后，我们对<code>size</code>进行向上取整的操作，使<code>size</code>变为<code>PAGE_SIZE</code>的整数倍：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>size <span style="color:#f92672">=</span> (size <span style="color:#f92672">+</span> (PAGE_SIZE <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>)) <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>PAGE_MASK;
</span></span></code></pre></div><p>我们可以结合实际简要理解这段代码，假设<code>PAGE_SIZE</code>取<code>1ul &lt;&lt; 12</code>（即4096），这里<code>size + (PAGE_SIZE - 1)</code>的操作确保了：</p>
<ul>
<li>当<code>size</code>为<code>PAGE_SIZE</code>整数倍时，<code>size + (PAGE_SIZE - 1)</code>仍在当前页的范围内。</li>
<li>当<code>size</code>不为<code>PAGE_SIZE</code>整数倍时，<code>size + (PAGE_SIZE - 1)</code>会进入下一页的范围内。</li>
</ul>
<p>随后，利用<code>PAGE_MASK</code>，我们可以将<code>size + (PAGE_SIZE - 1)</code>二进制表示中的低若干位清零，从而实现取整的操作，比如<code>PAGE_SIZE</code>取<code>1ul &lt;&lt; 12</code>时，<code>PAGE_MASK</code>可取<code>(1ul &lt;&lt; 12) - 1</code>，该数二进制表示的低12位均为0，从而与该数按位与后一定是<code>PAGE_SIZE</code>的倍数，且<code>size + (PAGE_SIZE - 1)</code>的操作保证最终分配的空间大小一定不小于原始请求的大小。</p>
<p>完成对齐后，我们可以移动<code>p_space</code>指针，将<code>size</code>大小的空间标记为已分配，同时检查是否有足够的空间可以分配，如有，则返回指针<code>p</code>，代表空间分配完成。</p>
<p>随后，设备会调用<code>add_mmio_map()</code>函数（这里我们只考虑MMIO），这一函数在<code>mmio.c</code>中实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> IOMap maps[NR_MAP] <span style="color:#f92672">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> nr_map <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">report_mmio_overlap</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name1, <span style="color:#66d9ef">paddr_t</span> l1, <span style="color:#66d9ef">paddr_t</span> r1,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name2, <span style="color:#66d9ef">paddr_t</span> l2, <span style="color:#66d9ef">paddr_t</span> r2) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">panic</span>(<span style="color:#e6db74">&#34;MMIO region %s@[&#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;, &#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;] is overlapped &#34;</span>
</span></span><span style="display:flex;"><span>               <span style="color:#e6db74">&#34;with %s@[&#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;, &#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;]&#34;</span>, name1, l1, r1, name2, l2, r2);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* device interface */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">add_mmio_map</span>(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name, <span style="color:#66d9ef">paddr_t</span> addr, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>space, <span style="color:#66d9ef">uint32_t</span> len, <span style="color:#66d9ef">io_callback_t</span> callback) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert</span>(nr_map <span style="color:#f92672">&lt;</span> NR_MAP);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">paddr_t</span> left <span style="color:#f92672">=</span> addr, right <span style="color:#f92672">=</span> addr <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">in_pmem</span>(left) <span style="color:#f92672">||</span> <span style="color:#a6e22e">in_pmem</span>(right)) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">report_mmio_overlap</span>(name, left, right, <span style="color:#e6db74">&#34;pmem&#34;</span>, PMEM_LEFT, PMEM_RIGHT);
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> nr_map; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> (left <span style="color:#f92672">&lt;=</span> maps[i].high <span style="color:#f92672">&amp;&amp;</span> right <span style="color:#f92672">&gt;=</span> maps[i].low) {
</span></span><span style="display:flex;"><span>      <span style="color:#a6e22e">report_mmio_overlap</span>(name, left, right, maps[i].name, maps[i].low, maps[i].high);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  maps[nr_map] <span style="color:#f92672">=</span> (IOMap){ .name <span style="color:#f92672">=</span> name, .low <span style="color:#f92672">=</span> addr, .high <span style="color:#f92672">=</span> addr <span style="color:#f92672">+</span> len <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>,
</span></span><span style="display:flex;"><span>    .space <span style="color:#f92672">=</span> space, .callback <span style="color:#f92672">=</span> callback };
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">Log</span>(<span style="color:#e6db74">&#34;Add mmio map &#39;%s&#39; at [&#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;, &#34;</span> FMT_PADDR <span style="color:#e6db74">&#34;]&#34;</span>,
</span></span><span style="display:flex;"><span>      maps[nr_map].name, maps[nr_map].low, maps[nr_map].high);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  nr_map <span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>这一函数主要创建一个<code>IOMap</code>结构体，该结构体存储了内存地址空间与I/O地址空间的映射关系，它的定义在<code>map.h</code>中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>name;
</span></span><span style="display:flex;"><span>  <span style="color:#75715e">// we treat ioaddr_t as paddr_t here
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">paddr_t</span> low;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">paddr_t</span> high;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>space;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">io_callback_t</span> callback;
</span></span><span style="display:flex;"><span>} IOMap;
</span></span></code></pre></div><p>主要包括以下字段：</p>
<ul>
<li><code>name</code>：设备名称。</li>
<li><code>low</code>/<code>high</code>：用于映射的内存地址空间的上/下边界。</li>
<li><code>space</code>：指向设备I/O地址空间起始位置的指针。</li>
<li><code>callback</code>：设备回调函数指针，指向各设备的回调函数。</li>
</ul>
<p>了解<code>IOMap</code>的定义后，<code>add_mmio_map()</code>函数本身的实现是简单的，首先需要判断映射的内存地址空间与物理内存地址空间、已注册的设备内存地址空间是否重叠，如果不重叠，创建结构体即可。</p>
<p>有了<code>IOMap</code>结构体后，我们便可在NEMU中使用<code>map_read()</code>函数与<code>map_write()</code>函数来访问设备并调用各设备的回调函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">word_t</span> <span style="color:#a6e22e">map_read</span>(<span style="color:#66d9ef">paddr_t</span> addr, <span style="color:#66d9ef">int</span> len, IOMap <span style="color:#f92672">*</span>map) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert</span>(len <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> len <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">check_bound</span>(map, addr);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">paddr_t</span> offset <span style="color:#f92672">=</span> addr <span style="color:#f92672">-</span> map<span style="color:#f92672">-&gt;</span>low;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">invoke_callback</span>(map<span style="color:#f92672">-&gt;</span>callback, offset, len, false); <span style="color:#75715e">// prepare data to read
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">word_t</span> ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">host_read</span>(map<span style="color:#f92672">-&gt;</span>space <span style="color:#f92672">+</span> offset, len);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> ret;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">map_write</span>(<span style="color:#66d9ef">paddr_t</span> addr, <span style="color:#66d9ef">int</span> len, <span style="color:#66d9ef">word_t</span> data, IOMap <span style="color:#f92672">*</span>map) {
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">assert</span>(len <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> len <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">8</span>);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">check_bound</span>(map, addr);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">paddr_t</span> offset <span style="color:#f92672">=</span> addr <span style="color:#f92672">-</span> map<span style="color:#f92672">-&gt;</span>low;
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">host_write</span>(map<span style="color:#f92672">-&gt;</span>space <span style="color:#f92672">+</span> offset, len, data);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">invoke_callback</span>(map<span style="color:#f92672">-&gt;</span>callback, offset, len, true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="2-mainargs的传递">2. mainargs的传递</h3>
<p>当我们在测试程序目录下输入<code>mainargs</code>参数时，测试程序目录下的Makefile会先包含<code>AM_HOME</code>目录下（<code>abstract-machine</code>）的主Makefile，而这一主Makefile又会使用以下语句包含特定架构的Makefile：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#75715e">### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`)
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">-include</span> <span style="color:#66d9ef">$(</span>AM_HOME<span style="color:#66d9ef">)</span><span style="color:#960050;background-color:#1e0010">/scripts/</span><span style="color:#66d9ef">$(</span>ARCH<span style="color:#66d9ef">)</span><span style="color:#960050;background-color:#1e0010">.mk</span>
</span></span></code></pre></div><p>特定架构的Makefile又会包含其所运行平台（<code>nemu</code>/<code>npc</code>/<code>native</code>）的Makefile，以<code>riscv32-nemu.mk</code>为例，其包含：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">include</span> <span style="color:#66d9ef">$(</span>AM_HOME<span style="color:#66d9ef">)</span><span style="color:#960050;background-color:#1e0010">/scripts/platform/nemu.mk</span>
</span></span></code></pre></div><p>最终，当我们使用<code>make run</code>时，<code>mainargs</code>会被传递到运行平台（<code>nemu</code>/<code>npc</code>/<code>native</code>）的Makefile中，以NEMU为例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-makefile" data-lang="makefile"><span style="display:flex;"><span><span style="color:#a6e22e">insert-arg</span><span style="color:#f92672">:</span> image
</span></span><span style="display:flex;"><span>	@python <span style="color:#66d9ef">$(</span>AM_HOME<span style="color:#66d9ef">)</span>/tools/insert-arg.py <span style="color:#66d9ef">$(</span>IMAGE<span style="color:#66d9ef">)</span>.bin <span style="color:#66d9ef">$(</span>MAINARGS_MAX_LEN<span style="color:#66d9ef">)</span> <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>MAINARGS_PLACEHOLDER<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>mainargs<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">run</span><span style="color:#f92672">:</span> insert-arg
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">$(</span>MAKE<span style="color:#66d9ef">)</span> -C <span style="color:#66d9ef">$(</span>NEMU_HOME<span style="color:#66d9ef">)</span> ISA<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>ISA<span style="color:#66d9ef">)</span> run ARGS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>NEMUFLAGS<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span> IMG<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>IMAGE<span style="color:#66d9ef">)</span>.bin
</span></span></code></pre></div><p>此时，<code>run</code>目标会依赖<code>insert-arg</code>目标，而<code>insert-arg</code>目标会调用Python程序<code>insert-arg.py</code>，<code>mainargs</code>便作为该Python程序的输入参数，那么，这段Python程序主要在做什么呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#75715e">#!/usr/bin/env python3</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> sys <span style="color:#f92672">import</span> argv
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>bin <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>max_len <span style="color:#f92672">=</span> int(argv[<span style="color:#ae81ff">2</span>])
</span></span><span style="display:flex;"><span>placeholder <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">3</span>]
</span></span><span style="display:flex;"><span>mainargs <span style="color:#f92672">=</span> argv[<span style="color:#ae81ff">4</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> len(mainargs) <span style="color:#f92672">&gt;=</span> max_len:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Error: mainargs should not be longer than </span><span style="color:#e6db74">{0}</span><span style="color:#e6db74"> bytes</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format( max_len))
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;mainargs=</span><span style="color:#e6db74">{0}</span><span style="color:#e6db74">&#34;</span><span style="color:#f92672">.</span>format(mainargs))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>fp <span style="color:#f92672">=</span> open(bin, <span style="color:#e6db74">&#39;r+b&#39;</span>)
</span></span><span style="display:flex;"><span>data <span style="color:#f92672">=</span> fp<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>idx <span style="color:#f92672">=</span> data<span style="color:#f92672">.</span>find(str<span style="color:#f92672">.</span>encode(placeholder))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> idx <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Error: placeholder not found!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>fp<span style="color:#f92672">.</span>seek(idx)
</span></span><span style="display:flex;"><span>mainargs_pad <span style="color:#f92672">=</span> str<span style="color:#f92672">.</span>encode(mainargs)<span style="color:#f92672">+</span> ((max_len <span style="color:#f92672">-</span> len(mainargs)) <span style="color:#f92672">*</span> str<span style="color:#f92672">.</span>encode(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\0</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> len(mainargs_pad) <span style="color:#f92672">!=</span> max_len:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Error: len(mainargs_pad) != max_len</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>    exit(<span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>fp<span style="color:#f92672">.</span>write(mainargs_pad)
</span></span><span style="display:flex;"><span>fp<span style="color:#f92672">.</span>close()
</span></span></code></pre></div><p>首先，它会将<code>mainargs</code>打印出来（但这个打印并对应<code>hello</code>程序中输出<code>mainargs</code>的打印行为，后者所<code>hello</code>程序本身内置的），同时向编译后的可执行文件注入<code>mainargs</code>参数。随后，在<code>trm.c</code>中，我们便可将<code>mainargs</code>参数通过<code>_trm_init()</code>函数注入到<code>main</code>函数中：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> mainargs[MAINARGS_MAX_LEN] <span style="color:#f92672">=</span> MAINARGS_PLACEHOLDER; <span style="color:#75715e">// defined in CFLAGS
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">_trm_init</span>() {
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#a6e22e">main</span>(mainargs);
</span></span><span style="display:flex;"><span>  <span style="color:#a6e22e">halt</span>(ret);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
    </div>
</div>

            </main>
        </div>


        <footer class="footer">
    
        <span>
            © 2025 Posvirus&#39; Blog, Built with
            <a href="https://gohugo.io" class="footerLink">Hugo</a> and
            <a href="https://github.com/LordMathis/hugo-theme-nightfall" class="footerLink">Nightfall</a> theme
        </span>
    
</footer>
    </div>

</body>

</html>
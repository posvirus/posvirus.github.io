[{"content":" 本文是我在几年前学习《VLSI数字信号处理系统设计》这门课程时所做的笔记，此处进行简单整理，以供复习。\n数字基带传输 数字基带传输系统 在本节中，我们将首先考查数字基带传输系统进行信号传输，在第一章中已经说明过，所谓数字基带传输系统，即为不经载波调制而直接传输数字基带信号的数字通信系统，常用于传输距离不太远的情况。\n我们仍然可以使用如上图所示的一般数字通信系统的Work-flow Chart来对数字基带传输系统进行可视化理解（毕竟其也为一类数字通信系统），原始信号在进行量化、信源编码（Source encode） 与信道编码（Channel encode） 后成功生成了一个二进制序列（ $0101001\\cdots$ ），而注意，此时的二进制序列仍然只是一个抽象的数字序列，要将其转化为可实际进行传输的信号，我们需要将该数字序列整合1至脉冲波形上，形成实际的数字基带信号。在此之后，直接对数字基带信号进行传输，并通过接收端的采样、解码等操作恢复原始的二进制序列信息。\n几类常用的基带信号 而首先，我们需了解数字基带传输系统中常用的几类基带信号：\n矩形脉冲： $$ f(t)=\\left\\{\\begin{array}{lcl} A\u0026\u0026|t|\\leqslant T_c\\\\ \\\\ 0\u0026\u0026\\text{else} \\end{array}\\right. $$ 三角脉冲： $$ f(t)=\\left\\{\\begin{array}{lcl} \\displaystyle\\frac{A}{T_c}(t+T_c)\u0026\u0026-T_c\\leqslant t\u003c0\\\\ \\\\ \\displaystyle-\\frac{A}{T_c}(t-T_c)\u0026\u00260\\leqslant t\\leqslant T_c\\\\ \\\\ 0\u0026\u0026\\text{else} \\end{array}\\right. $$ 高斯脉冲： $$ f(t)=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{-\\frac{t^2}{2\\sigma^2}} $$ 升余弦脉冲： $$ f(t)=\\left\\{\\begin{array}{lcl} \\displaystyle \\frac{A}{2}\\left[1+\\cos\\left(\\frac{\\pi t}{T_c}\\right)\\right]\u0026\u0026|t|\\leqslant T_c\\\\ \\\\ 0\u0026\u0026\\text{else} \\end{array}\\right. $$其中，考虑到各脉冲在现实应用场景中的生成难度，最常用的基带信号为升余弦脉冲，但为保证说明的形象性与简洁性，在后文我们统一采用矩形脉冲进行讨论。\n这里需要补充说明两个问题：\n第一，上述这些信号虽被称为基带信号，但它们是符合严格数学定义的基带信号吗？不妨以矩形脉冲为例，对其进行Fourier变换：\n$$ F(\\omega)=\\mathscr{F}\\{f(t)\\}=\\int_{-T_c}^{+T_c}A\\mathrm{e}^{-i\\omega t}\\mathrm{d}t=\\frac{A\\sin(\\omega T_c)}{\\omega}=AT_c\\cdot\\text{Sinc}(T_c\\omega) $$ 可见，矩形脉冲具有无限宽的频谱，从数学意义上并不是基带信号（其实从更广义的角度而言，在时域上有限的信号往往在频域上无限），那么，我们为何称其为基带信号呢？仍以矩形脉冲为例，我们注意到， $F(\\omega)=\\displaystyle \\frac{A\\sin(\\omega T_c)}{\\omega}$ 除在 $[-\\pi/T_c,~\\pi/T_c]$ 上取值较大（主瓣）外，在其余区域内（旁瓣）频谱的取值都非常接近0，这就说明，虽然 $F(\\omega)$ 是无限宽的频谱，但它其实与基带信号的频谱是十分相似的。\n当然， $F(\\omega)$ 与基带信号的频谱相似并不代表着我们可以直接把矩形脉冲当作基带信号使用，但我们确实可以利用这种相似性将矩形脉冲转化为基带信号，这一过程一般称为脉冲/基带成型：即使用一个低通滤波器滤去 $F(\\omega)$ 的高频分量，将滤波后的信号作为基带信号使用，而 $F(\\omega)$ 与基带信号频谱的相似性保证了在滤波后，矩形脉冲的时域波形不会发生太大改变。由于脉冲成型是一个相对独立的处理过程，且滤波后的波形的解析表达式在形式上又过于复杂，因此我们常常直接称矩形脉冲信号（以及上述这些信号）为基带信号。\n第二，上述信号所代表的仅仅为单个脉冲，而若要传输一个二进制序列，往往需要在一段连续时间内多个脉冲的叠加，即： $$ f(t)=\\sum\\limits_{i=0}^{+\\infty}a_ig(t-iT_B) $$ 其中 $g(t)$ 为单个基带脉冲，而我们注意到： $$ \\mathscr{F}\\{g(t-t_0)\\}=\\int_{-\\infty}^{+\\infty}g(t-t_0)\\mathrm{e}^{-i\\omega(t-t_0)}\\cdot\\mathrm{e}^{-i\\omega t_0}\\mathrm{d}t=\\mathscr{F}\\{g(t)\\}\\cdot\\mathrm{e}^{-i\\omega t_0} $$ 因此我们得到一个重要事实：基带信号在时域上平移叠加后的信号仍为基带信号。\n二进制序列与脉冲波形的对应关系 在完成对几类基带信号的说明后，以下我们将以矩形脉冲为例，探讨二进制序列与脉冲波形的对应关系：\n由于二进制序列从本质上而言仅有0和1两个基本元素，因此我们仅需考虑脉冲波形的（电平）取值与0和1的对应关系即可，我们常将这种对应关系称为二元传输码的传输码型，主要有以下几类：\n单极性非归零码（Unipolar Non-return-to-zero Coding）： 用一种信号电平代表1，用另一种信号电平代表0，在码元2持续期间电平保持不变。如用高电平代表1，低电平（一般为零电平）代表0，为正逻辑，反之为负逻辑。\n双极性非归零码（Bipolar Non-return-to-zero Coding）： 用正电平和负电平分别表示1和0，在码元持续期间电平保持不变。\n注： 单极性码与双极性码的特点比较：\n单极性码 双极性码 1. 有直流分量，无法使用一些交流耦合的线路和设备；2. 判决电平不能稳定在最佳的电平，即抗噪性能差；3. 传输时需一端接地。不能用两根芯线均不接地的电缆传输线。（用于设备内部和数字调制器中） 1.直流分量小。当二进制序列中1和0等可能出现时，无直流成分；2.接收端判决门限为0，容易设置并且稳定，因此抗干扰能力强；3.可以在电缆等无接地线上传输。（RS-232C接口标准和数字调制器中） 单极性归零码（Unipolar Return-to-zero Coding）： 单极性归零码与单极性非归零码稍有区别，具体表现为：高电平不是在整个码元期间保持不变，而是只持续一段时间，然后在码元的其余时间内返回到零电平。以正逻辑为例，这种码在表示1时，信号会在一个码元宽度（记为 $T_s$ ）内先保持一段时间（记为 $\\tau$ ）的高电平，并在剩余时间切换为零电平；在表示0时则仍始终为低电平。我们同时称 $\\tau/T_s$ 为这种码型的占空比，一般地， $\\tau/T_s=0.5$ 。\n单极性归零码可直接提取位同步信号，可作为其他码型提取同步时钟的过渡码型。\n双极性归零码（Bipolar Return-to-zero Coding）： 正电平与负电平在整个码元期间均不是保持不变的，而是只持续一段时间，然后在码元的其余时间内返回到零电平。\n差分波形： 不是用码元本身的电平表示二进制序列，而是用相邻码元的电平的跳变和不变来表示二进制序列，分为传号差分与空号差分：考虑第 $k$ 个码元的电平 $E_k$ 与第 $k+1$ 个码元的电平 $E_{k+1}$ ，对传号差分，若 $E_{k}=E_{k+1}$ ，则第 $k+1$ 个码元代表0；若 $E_k\\ne E_{k+1}$ ，则第 $k+1$ 个码元代表1，对空号差分则相反。\n差分波形可以消除设备初始状态不确定性带来的影响。同时，由于差分波形是以相邻脉冲电平的相对变化来表示二进制序列的，因此称它为相对码，而相应地称前面的码型为绝对码。\n多进制波形： 使用超过两个电平的脉冲波形表示二进制序列，根据所使用电平的数量，各电平可包含多个比特的信息（一般地，如使用 $N$ 个电平，则每个电平至多可包含 $\\lfloor\\log_2 N\\rfloor~\\text{bit}$ 的序列信息）。\n对多进制波形，传码率3一定时，其传信率3高，可用于高数据速率传输系统。\n数字基带信号的表达式 在不考虑二进制序列所包含的具体信息的前提下（即考查随机生成的二进制序列），我们可将一个随机二进制序列对应的数字基带信号记作 $f(t)$ ，其可表示如下：\n当各码元波形相同而取值不同时： $$ f(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}a_ng(t-nT_s) $$其中，${a_n}$ 为离散型随机变量， $T_s$ 为码元宽度。\n当0/1使用不同波形表示时： $$ f(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}g_n(t),~g_n(t)=\\left\\{\\begin{array}{lcl} g_{(1)}(t-nT_s)\u0026\u0026\\text{with probability of}~p\\\\ \\\\ g_{(0)}(t-nT_s)\u0026\u0026\\text{with probability of}~1-p\\\\ \\end{array}\\right. $$其中， $p$ 为二进制序列中1出现的概率。\n基带信号解调与检测 噪声的来源简述 在上节中，我们考查了数字基带传输系统的原始信息编码，以下，我们将对传输系统的后半部分，即信号的传输与接收进行说明。我们首先考查信号的传输，在实际的信号传输过程中，由于受到外界各类因素的干扰，因此会在信号传输过程中引入噪声（Noise）。我们对信号传输过程的研究，也是这些噪声为重点的。\n噪声一般分为两类，外界因素引起的噪声（我们一般称为热噪声（Thermal Noise）），以及因传输信息的脉冲波形的非理想特性所引起的噪声（一般称为码间串扰（Inter-Symbol Interference, ISI）），具体内容如下：\n热噪声： 一般用于仿真热噪声的数学模型被称为加性高斯白噪声模型（Addictive White Gaussian Noise, AWGN），是最基本的噪声与干扰模型，其可使用 $n(t)$ 进行描述，对加性高斯白噪声 $n(t)$ 而言，其应当满足如下条件： 加性： 噪声 $n(t)$ 是直接叠加在信号波形上的，且无论信号是否存在，噪声都始终存在。 白噪声： 噪声 $n(t)$ 的功率谱4为常数。 高斯噪声： 噪声取值的概率分布满足正态分布。 注： 噪声是随机信号，$n(t)$ 只是形式上的记法，我们应从统计意义上对其进行分析。\n码间串扰： 我们将在后面的章节中讨论，此处从略。 接收系统的组成 上图展示了数字基带传输系统中接收系统的组成，读图可知，接收系统主要由接收滤波器与抽样判决器组成，两者的作用具体如下所示：\n接收滤波器/匹配滤波器： 滤除带外噪声，恢复具有最大信噪比的基带脉冲，使输出的基带波形有利于抽样判决。 抽样判决器： 对接收滤波器的输出波形进行抽样判决（即依据波形取值判断二进制0/1），确定发送的二进制序列。 同步提取： 提取用于抽样的位同步脉冲。 而对接收滤波器而言，在进行基带脉冲恢复的前后，还需要分别通过频率下搬移与均衡滤波器：\n其中，频率下搬移是指将接收到的带通信号重构为基带信号，当然，这仅对带通传输系统是必要的，对本节所讨论的数字基带传输系统则无必要；而均衡滤波器则用于消除码间串扰，当然，如果不考虑码间串扰的影响，则均衡滤波器也是不必要的。\n信号与噪声 AWGN噪声模型 在本节，我们将对上节提到的AWGN噪声模型进行量化分析，首先，我们假设传输的二进制序列为随机序列： $$ s(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}s_n(t),~s_n(t)=\\left\\{\\begin{array}{lcl} s_{(1)}(t-nT_s)\u0026\u0026\\text{for a binary 1, with probability of}~p\\\\ \\\\ s_{(0)}(t-nT_s)\u0026\u0026\\text{for a binary 0, with probability of}~1-p\\\\ \\end{array}\\right. $$ 其中， $s_0(t),~s_1(t)$ 分别为代表0和1的脉冲波形，码元宽度为 $T_s$ 。同时，我们记AWGN噪声为 $n(t)$ ，则传输基带信号 $s(t)$ 的信道可抽象为如下系统：\n其中 $h_c(t)=\\delta(t)$ 为一个单位无失真传输系统，输入信号与输出信号完全相等， $s(t)$ 在通过该系统后，与AWGN噪声 $n(t)$ 线性叠加，假设输出信号为 $z(t)$ ，则成立： $$ z(t)=s(t)+n(t) $$ 我们固定某一时间点 $\\tau$ 对上式研究，假设上式可记作： $$ z(\\tau)=s_i(\\tau)+n(\\tau)=\\left\\{\\begin{array}{lcl} a_{(1)}+n(\\tau)\u0026\u0026\\text{for a binary 1, with probability of}~p\\\\ \\\\ a_{(0)}+n(\\tau)\u0026\u0026\\text{for a binary 0, with probability of}~1-p\\\\ \\end{array}\\right. $$ 可知，当该时间点传输的码元为1时（将该事件记为 $S_{(1)}$ ， $p(S_{(1)})=p$ ），则 $z(\\tau)=a_{(1)}+n(\\tau)$ ;当该时间点传输的码元为0时（将该事件记为 $S_{(0)}$ ， $p(S_{(0)})=1-p$ ），则 $z(\\tau)=a_{(0)}+n(\\tau)$ 。\n而注意到，当固定时间点 $\\tau$ 时，$n(\\tau)$ 是一个服从正态分布的随机变量， $a_{(1)},~a_{(0)}$ 默认为常数，我们记： $$ n(\\tau)\\sim N(0,~\\sigma^2) $$ 则显然 $z(\\tau)$ 也是一个随机变量，满足： $$ z(\\tau)\\sim \\left\\{\\begin{array}{lcl} N(a_{(1)},~\\sigma^2)\u0026\u0026\\text{for a binary 1, with probability of}~p\\\\ \\\\ N(a_{(0)},~\\sigma^2)\u0026\u0026\\text{for a binary 0, with probability of}~1-p\\\\ \\end{array}\\right. $$ 或也可用概率密度函数的形式写作： $$ \\rho(z|S_{(1)})=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{-\\frac{(z-a_{(1)})^2}{2\\sigma^2}},~\\rho(z|S_{(0)})=\\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{-\\frac{(z-a_{(0)})^2}{2\\sigma^2}} $$ 进一步，依据条件概率公式，我们有： $$ \\rho(z)=p\\rho(z|S_{(1)})+(1-p)\\rho(z|S_{(0)})=\\frac{p}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{-\\frac{(z-a_{(1)})^2}{2\\sigma^2}}+\\frac{1-p}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{-\\frac{(z-a_{(0)})^2}{2\\sigma^2}} $$ $\\rho(z)$ 给出了 $\\tau$ 时刻的接收信号 $z(\\tau)$ 服从的概率分布，事实上一般性地也给出了任意时刻接收信号服从的概率分布（因为 $\\sigma^2,~a_{(0)},~a_{(1)}$ 均是独立于时间的变量），而我们最终需要依据该概率密度函数确定一个判决门限 $\\gamma$ （当然也是独立于时间的），当实际接收的信号 $\\hat{z}(\\tau)\u0026gt;\\gamma$ 时，判定该码元表示二进制1；当实际接收的信号 $\\hat{z}(\\tau)\u0026lt;\\gamma$ 时，判定该码元表示二进制0（以下，均使用正逻辑作为代表）。\n当然，由于 $z$ 是连续型随机变量，这就表明，无论我们如何选取判决门限 $\\gamma$ ，总不能将误码的概率降至0，而在信号传输的过程中，我们希望能够将误码的概率降至最低，这一准则一般称为最小错误概率准则。\n信噪比 信噪比（Signal-noise Ratio, SNR） 是描述信号传输中噪声的一个重要参量，若记 接收信号在 $t=\\tau$ 时的瞬时功率为 $P(\\tau)$ ，噪声在 $t=\\tau$ 时的平均功率5为 $N(\\tau)$ ，则信噪比被定义为： $$ \\text{SNR}=\\frac{P(\\tau)}{N(\\tau)} $$ 同时，利用上节中的AWGN噪声模型，我们易于给出 $P(\\tau),~N(\\tau)$ 的具体表达式，仅需注意到： $$ P(\\tau)=\\lim\\limits_{T\\to 0}\\frac{1}{T}\\int_{\\tau-T/2}^{\\tau+T/2}z^2(t)\\mathrm{d}t=z^2(\\tau) $$ 以及： $$ N(\\tau)=E[n^2(\\tau)] $$ 同时，我们若记各码元的平均能量为 $E_s$ ，每比特的平均能量为 $E_b$ ， 传码率为 $R_s$ ，传信率为 $R_b$ ，则应当成立： $$ \\frac{E_s}{E_b}=\\frac{R_b}{R_s}=k $$ $k$ 即为每个码元传输的比特数，因此有： $$ \\bar{P}=\\frac{E_s}{T_s}=E_sR_s=E_bR_b,~\\bar{N}=\\frac{N_0W}{2} $$ 其中 $W$ 为噪声功率谱的带宽（虽然白噪声功率谱的带宽理论上是无穷大，但在实际中应当是一个有限值 $W$ ），噪声的功率谱记为 $\\displaystyle P_s(\\omega)=\\frac{N_0}{2}$ ，进而有： $$ \\text{SNR}=\\frac{E_b}{N_0}\\cdot\\frac{2R_b}{W} $$ 参量 $\\displaystyle\\frac{E_b}{N_0}$ 有时也作为衡量数字通信系统性能的重要指标之一。\n在信号传输过程中，我们同样希望接收信号的信噪比能够尽可能大，这一准则一般称为最大输出信噪比准则。\n匹配滤波器 匹配滤波器的基本形式 在上节中我们了解到，利用接收滤波器/匹配滤波器对接收信号进行处理，可以改善接收信号的信噪比，以下，我们记匹配滤波器的系统函数为 $h(t)$ ，探究当 $h(t)$ 满足何种表达式时，输出信号 $y(t)$ 的信噪比最低。\n为此，我们假设接收系统会在 $t=t_0$ 时刻进行抽样，不妨仅考查 $t=t_0$ 这一时刻的信噪比，并不妨设首先计算输出信号 $y(t)$ 的表达式： $$ y(t_0)=z(t_0)*h(t_0)=\\int_{-\\infty}^{+\\infty}z(\\tau)h(t_0-\\tau)\\mathrm{d}\\tau=\\int_{-\\infty}^{+\\infty}(s(\\tau)+n(\\tau))h(t_0-\\tau)\\mathrm{d}\\tau $$ 进而可记： $$ y_s(t_0)=\\int_{-\\infty}^{+\\infty}s(\\tau)h(t_0-\\tau)\\mathrm{d}\\tau,~y_n(t_0)=\\int_{-\\infty}^{+\\infty}n(\\tau)h(t_0-\\tau)\\mathrm{d}\\tau $$于是有： $$ \\text{SNR}(t_0)=\\frac{y_s^2(t_0)}{E[y_n^2(t_0)]} $$ 以下我们重点考查 $E[y_n^2(t_0)]$ 的计算，将其展开，有： $$ E[y_n^2(t_0)]=E\\left[\\left(\\int_{-\\infty}^{+\\infty}n(\\tau)h(t_0-\\tau)\\mathrm{d}\\tau\\right)^2\\right]=E\\left[\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}n(\\tau)n(t)h(t_0-\\tau)h(t_0-t)\\mathrm{d}\\tau\\mathrm{d}t\\right] $$ 而由于积分运算的线性性质，我们有： $$ E[y_n^2(t_0)]=\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}E[n(\\tau)n(t)]h(t_0-\\tau)h(t_0-t)\\mathrm{d}\\tau\\mathrm{d}t $$ 其中，$R(t-\\tau)=E[n(\\tau)n(t)]$ 一般被称为自相关函数，利用 维纳-辛钦定理（Wiener–Khinchin Theorem） 可得：若记 $n(t)$ 对应的功率谱为 $\\displaystyle P_s(\\omega)=\\frac{N_0}{2}$ ，则 $\\displaystyle R(\\tau)=\\mathscr{F}^{-1}\\{P_s(\\omega)\\}=\\frac{N_0}{2}\\delta(\\tau)$ ，因此有： $$ E[y_n^2(t_0)]=\\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}\\int_{-\\infty}^{+\\infty}\\delta(t-\\tau)h(t_0-\\tau)h(t_0-t)\\mathrm{d}\\tau\\mathrm{d}t=\\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}h^2(t_0-\\tau)\\mathrm{d}\\tau $$ 因此就有： $$ \\text{SNR}(t_0)=\\frac{\\displaystyle\\left|\\int_{-\\infty}^{+\\infty}s(\\tau)h(t_0-\\tau)\\mathrm{d}\\tau\\right|^2}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}h^2(t_0-\\tau)\\mathrm{d}\\tau}=\\frac{\\displaystyle\\left|\\int_{-\\infty}^{+\\infty}s(t_0-\\tau)h(\\tau)\\mathrm{d}\\tau\\right|^2}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}h^2(\\tau)\\mathrm{d}\\tau} $$ 而若记 $S(f)=\\mathscr{F}\\{s(t)\\},~H(f)=\\mathscr{F}\\{h(t)\\}$ （此处， $f$ 为频率而非角频率），则有： $$ \\mathscr{F}\\{s(t_0-t)\\}=S^*(f)\\cdot\\mathrm{e}^{-2\\pi ft_0} $$ 利用Parseval定理，可计算得： $$ \\text{SNR}(t_0)=\\frac{\\displaystyle\\left|\\int_{-\\infty}^{+\\infty}H(f)S(f)\\cdot\\mathrm{e}^{2\\pi ft_0}\\mathrm{d}f\\right|}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}|H(f)|^2\\mathrm{d}f} $$ 利用Cauchy-Schwartz不等式，则有： $$ \\text{SNR}(t_0)\\leqslant\\frac{\\displaystyle\\int_{-\\infty}^{+\\infty}|S(f)\\cdot\\mathrm{e}^{2\\pi ft_0}|^2\\mathrm{d}f\\cdot \\int_{-\\infty}^{+\\infty}|H(f)|^2\\mathrm{d}f}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}|H(f)|^2\\mathrm{d}f}=\\frac{2\\displaystyle\\int_{-\\infty}^{+\\infty}|S(f)\\cdot\\mathrm{e}^{2\\pi ft_0}|^2\\mathrm{d}f}{N_0}=\\frac{2\\displaystyle\\int_{-\\infty}^{+\\infty}|S(f)|^2\\mathrm{d}f}{N_0} $$ 以下，为方便讨论，我们不妨仅考查第一个码元，即认为 $s(t)$ 仅在 $[0,~T_s]$ 上非06，并设 $t_0\\in[0,~T_s]$ ，于是有： $$ \\int_{-\\infty}^{+\\infty}|S(f)|^2\\mathrm{d}f=E_s\u003c\\infty $$ 其中， $E_s$ 为码元的平均能量。\n由上式可知，在 $t=t_0$ 时的信噪比的最大值为 $\\displaystyle \\frac{2E_s}{N_0}$ ，而由Cauchy-Schwartz不等式的取等条件，信噪比取得该最大值的条件是： $$ H(f)=K\\cdot\\left(S(f)\\mathrm{e}^{2\\pi ft_0}\\right)^*=K\\cdot S^*(f)\\mathrm{e}^{-2\\pi ft_0},~K\\in\\mathbb{R} $$ 等式两边进行Fourier逆变换，进而有： $$ h(t)=K\\cdot\\mathscr{F}^{-1}\\{S^*(f)\\mathrm{e}^{-2\\pi ft_0}\\}=K\\cdot s(t_0-t) $$ 上式表明，若使在 $t=t_0$ 时刻抽样第一个码元所获样本的信噪比取最大值，则 $h(t)$ 应当满足： $h(t)=K\\cdot s(t_0-t)$ 。\n以下，我们对抽样时刻 $t_0$ 是否有特殊的要求呢？首先，由于抽样的是第一个码元，则 $t_0\\in[0,~T_s]$ ；其次，若使 $h(t)$ 在实际中是可实现的，则 $h(t)$ 至少要是因果的，即： $$ s(t_0-t)\\equiv0,~\\forall t\u003c0~(\\Leftrightarrow\\forall t_0-t\u003et_0) $$ 注意到 $s(t)$ 在 $[0,~T_s]$ 上是非0的，则有 $t_0\\geqslant T_s$ ，因此，对抽样时刻的最优选择只能是 $t=T_s$ ，对应的匹配滤波器的单位脉冲响应为 $h(t)=s(T_s-t)$ （为方便讨论，不妨约定 $K=1$ ）。\n以下，我们考查更一般的情形，假定输入信号为： $$ z(t)=s(t)+n(t)=\\sum\\limits_{k=1}^{+\\infty}s_k(t)+n(t) $$ 其中， $s_k(t)$ 为第 $k$ 个码元的对应波形，则我们不妨将其设为 $s_k(t)=a_k\\hat{s}(t-(k-1)T_s)$ ，$a_k$ 为随机二进制序列在第 $k$ 位取值的随机变量，$\\hat{s}(t)$ 是仅在 $[0,~T]$ 非0的脉冲波形。将该输入信号输入匹配滤波器后，我们有： $$ y(t)=z(t)*h(t)=\\sum\\limits_{k=1}^{+\\infty}s_k(t)*h(t)+n(t)*h(t)=\\sum\\limits_{k=1}^{+\\infty}y_{s,k}(t)+y_n(t) $$ 不难发现，此时的输出脉冲波形是AWGN噪声对应响应 $y_n(t)$ 与各码元对应响应 $y_{s,k}(t)$ 的线性叠加，如果我们在 $t=kT_s$ 时刻对第 $k$ 个码元进行抽样，则很明显，我们希望在该时刻有且仅有第 $k$ 个码元对应响应与AWGN噪声对应响应的叠加（否则不同码元响应的叠加会导致干扰），即： $$ y(kT_s)=y_{s,k}(kT_s)+y_n(kT_s),~k\\in\\mathbb{N}_+ $$ 这直接导致 $y_{s,k}(t)$ 必须在时域上有限，更具体地说， $y_{s,k}(t)$​ 至多在 $(k-1)T_s\u0026lt;t\u0026lt;(k+1)T_s$ 时非0，结合 $y_{s,k}(t)$ 的表达式： $$ y_{s,k}(t)=\\int_{-\\infty}^{+\\infty}s_k(\\tau)h(t-\\tau)\\mathrm{d}\\tau=\\int_{(k-1)T_s}^{kT_s}s_k(\\tau)h(t-\\tau)\\mathrm{d}\\tau,~t-\\tau\\in(t-kT_s,~t-(k-1)T_s) $$ 可知 $h(t)$ 也必须在时域上有限，至多在 $0 \u0026lt; t \u0026lt; T_s$ 上非0（此处同时考虑了 $h(t)$ 的因果性）。进而我们有： $$ \\text{SNR}(kT_s)=\\frac{\\displaystyle\\left|\\int_{-\\infty}^{+\\infty}s(\\tau)h(kT_s-\\tau)\\mathrm{d}\\tau\\right|^2}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}h^2(kT_s-\\tau)\\mathrm{d}\\tau}=\\frac{\\displaystyle\\left|\\int_{(k-1)T_s}^{kT_s}a_k\\hat{s}(\\tau-(k-1)T_s)h(kT_s-\\tau)\\mathrm{d}\\tau\\right|^2}{\\displaystyle \\frac{N_0}{2}\\int_{-\\infty}^{+\\infty}h^2(kT_s-\\tau)\\mathrm{d}\\tau}\\leqslant\\frac{2E_s}{N_0} $$ 此时不等式的取等条件为： $$ h(kT_s-\\tau)=K\\cdot a_k\\hat{s}(\\tau-(k-1)T_s)~\\Leftrightarrow~h(t)=K\\cdot a_k\\hat{s}(T_s-t),~K\\in\\mathbb{R} $$ 综上可知，对形如 $\\displaystyle z(t)=\\sum\\limits_{k=1}^{+\\infty}a_k\\hat{s}(t-(k-1)T_s)+n(t)$ 的接收信号，我们仅需保证匹配滤波器的单位脉冲响应 $h(t)=\\hat{s}(T_s-t)$ ，即可同时使在 $t=kT_s$ 时刻对第 $k$ 个码元的抽样信噪比达到最大。\n使用相关运算取代匹配滤波器 匹配滤波器虽然可以使抽样时的信噪比达到最大，但是相对而言难以实现，为此，我们有时会使用相关运算取代匹配滤波器的实现，我们仅需注意到，当 $t=kT_s$ 时，成立： $$ y(kT_s)=\\int_{(k-1)T_s}^{kT_s}z(\\tau)\\hat{s}(\\tau-(k-1)T_s)\\mathrm{d}\\tau=\\int_{0}^{T_s}z(\\tau+(k-1)T_s)\\hat{s}(\\tau)\\mathrm{d}\\tau $$ 我们如果定义信号 $f(t)$ 与 $g(t)$ 的相关运算为： $$ (f\\otimes g)(t)=\\int_{-\\infty}^{+\\infty}f^*(\\tau)g(\\tau+t)\\mathrm{d}\\tau $$ 则考虑到 $z(t),~\\hat{s}(t)$ 均为实信号，易有： $$ y(kT_s)=(\\hat{s}\\otimes z)((k-1)T_s) $$ 我们不难注意到， $y(kT_s)=(\\hat{s}\\otimes z)((k-1)T_s)$ 是在 $t=kT_s$ 信噪比最大的输出信号（之一），这一结论对任意形式的匹配滤波器均成立，那么，我们不妨构造系统 $\\mathscr{H}$ ，满足：\n$$ y(t)=\\mathscr{H}\\{x(t)\\}=(\\hat{s}\\otimes x)(t-T_s)=\\int_{0}^{T_s}\\hat{s}(\\tau)x(\\tau+t-T_s)\\mathrm{d}\\tau $$ 这样，该系统在 $t=kT_s$ 时的信噪比也能够达到最大。\n这样的系统 $\\mathscr{H}$ 相比原来的匹配滤波器设计有什么好处呢？除相关运算更易于实现外，该系统实际上可以对更广义的脉冲波形进行处理，如果我们记： $$ s_n(t)=\\left\\{\\begin{array}{lcl} s_{(1)}(t-nT_s)\u0026\u0026\\text{for a binary 1, with probability of}~p\\\\ \\\\ s_{(0)}(t-nT_s)\u0026\u0026\\text{for a binary 0, with probability of}~1-p\\\\ \\end{array}\\right. $$ 且 $s_{(1)}(t)$ 与 $s_{(0)}(t)$ 如果不具备倍数关系的话，则原来的匹配滤波器失效（因为 $h(t)$ 显然不可能在 $s_{(1)}(T_s-t)$ 与 $s_{(0)}(T_s-t)$ 间概率性地切换），但我们仍然可以使用系统 $\\mathscr{H}$ 进行设计，可以分别构造如下两个系统： $$ y(t)=\\mathscr{H}_{(0)}\\{x(t)\\}=(s_{(0)}\\otimes x)(t-T_s),~y(t)=\\mathscr{H}_{(1)}\\{x(t)\\}=(s_{(1)}\\otimes x)(t-T_s) $$ 则我们可以分别将接收信号 $z(t)$ 输入两个系统得到输出 $y_{(0)}(t)$ 与 $y_{(1)}(t)$ ，再根据 $y_{(0)}(t)$ 与 $y_{(1)}(t)$ 在 $t=kT_s$ 的取值判断第 $k$ 个码元的取值。\n至于具体如何依据 $y_{(0)}(kT_s)$ 与 $y_{(1)}(kT_s)$ 的取值判断第 $k$ 个码元的取值，我们可举一个简单的例子，如果我们忽略噪声并认为： $$ \\int_{0}^{T_s}s_{(0)}^2(\\tau)\\mathrm{d}\\tau=\\int_{0}^{T_s}s_{(1)}^2(\\tau)\\mathrm{d}\\tau=E_s $$ 则依据Cauchy-Schwartz不等式，我们有： $$ E_s\\geqslant\\int_{0}^{T_s}s_{(0)}(\\tau)s_{(1)}(\\tau)\\mathrm{d}\\tau $$ 因此，我们可得如下判定条件：当 $y_{(1)}(kT_s)\u0026gt;y_{(0)}(kT_s)$ 时，则第 $k$ 个码元为1；当 $y_{(1)}(kT_s)\u0026lt;y_{(0)}(kT_s)$ 时，则第 $k$ 个码元为0。\nAWGN噪声干扰下的二进制信号检测 一般性模型 在本节，我们将通过对更一般情形的分析，讨论如何对AWGN噪声干扰下的接收波形进行接收滤波以及抽样判决，在上节中我们已经讨论过，使用怎样的接收滤波器才可以满足最大输出信噪比准则，而在本节我们主要讨论，应当使用怎样的策略对通过接收滤波器的信号进行抽样判决，才能使得判决的结果满足最小错误概率准则。\n为此，首先我们定义更为一般的接收信号，假设对一个码元而言，共有 $M$ 种可能的脉冲波形，构成集合： $$ S_M=\\{s_m(t)|m=1,~2,\\cdots,~M\\} $$ 而此处我们默认 $S_M$ 满足一个性质：即 $S_M$ 中的脉冲波形可进行正交基分解，换言之，存在一组正交基： $$ F_N=\\{f_n(t)|n=1,~2,\\cdots,~n\\},~\\int_{-\\infty}^{+\\infty}f_n(t)f_m(t)\\mathrm{d}t=\\delta_{mn} $$ 使得： $$ s_m(t)=\\sum\\limits_{n=1}^{N}\\hat{s}_{mn}f_n(t),~m=1,~2,\\cdots,~M $$ 或可写成矩阵形式： $$ \\left[\\begin{array}{c} s_1(t)\\\\ s_2(t)\\\\ \\vdots\\\\ s_M(t) \\end{array}\\right]=\\left[\\begin{array}{cccc} \\hat{s}_{11}\u0026\\hat{s}_{12}\u0026\\cdots\u0026\\hat{s}_{1N}\\\\ \\hat{s}_{21}\u0026\\hat{s}_{22}\u0026\\cdots\u0026\\hat{s}_{2N}\\\\ \\vdots\u0026\\vdots\u0026\\ddots\u0026\\vdots\\\\ \\hat{s}_{M1}\u0026\\hat{s}_{M2}\u0026\\cdots\u0026\\hat{s}_{MN} \\end{array}\\right]\\left[\\begin{array}{c} f_1(t)\\\\ f_2(t)\\\\ \\vdots\\\\ f_N(t) \\end{array}\\right] $$ 进而，接收信号 $z(t)$ 便可记作： $$ z(t)=s_m(t)+n(t)=\\sum\\limits_{k=1}^{N}\\hat{s}_{mk}f_k(t)+n(t) $$ 其次，我们设计如下的接收滤波器：\n读图可知，该接收滤波器有 $N$ 个并行的相关器，分别输出 $z(t)$ 与 $N$ 个基函数的相关性，而我们最终即基于这 $N$ 条描述相关性的抽样信息，去判定接收的波形究竟是 $S_M$ 中的哪一者。如果用数学语言描述，即为： $$ r_k=\\int_{0}^{T_s}f_k(t)z(t)\\mathrm{d}t=\\int_{0}^{T_s}f_k(t)\\cdot\\sum\\limits_{j=1}^N\\hat{s}_{mj}f_j(t)\\mathrm{d}t+\\int_{0}^{T_s}f_k(t)n(t)\\mathrm{d}t $$ 利用正交基的性质，并记 $\\displaystyle n_k=\\int_{0}^{T_s}f_k(t)n(t)\\mathrm{d}t$ ，则有： $$ r_k=\\hat{s}_{mk}+n_k,~m=1,~2,\\cdots,~M $$ 我们最终即需根据输出的抽样向量 $\\vec{r}=[r_1,~r_2,\\cdots,~r_N]^T$ ，判定接收信号 $z(t)$ 中所传输的脉冲波形 $s_m(t)$ 。\n以下，我们考查抽样向量所满足的性质，对 $r_k$ 而言， $\\hat{s}_{mk}$ 是一个确定值，而 $n_k$ 则是一个服从正态分布的随机变量，且由积分运算的线性性质，其均值 $E[n_k]$ 满足： $$ E[n_k]=E\\left[\\int_{0}^{T_s}f_k(t)n(t)\\mathrm{d}t\\right]=\\int_{0}^{T_s}f_k(t)E[n(t)]\\mathrm{d}t=0 $$ 其方差 $D[n_k]$ 满足： $$ D[n_k]=E[n_k^2]-(E[n_k])^2=E[n_k^2] $$ 而由上节的推导可知，若 $n(t)$ 的功率谱为 $\\displaystyle \\frac{N_0}{2}$ ，则有： $$ D[n_k]=E[n_k^2]=\\frac{N_0}{2}\\int_{0}^{T_s}f^2_k(t)\\mathrm{d}t=\\frac{N_0}{2} $$ 因此有： $$ n_k\\sim N\\left(0,~\\frac{N_0}{2}\\right)~\\Rightarrow~r_k\\sim N\\left(\\hat{s}_{mk},~\\frac{N_0}{2}\\right) $$ 以上的推导实质上是在已知传输的脉冲波形为$s_m(t)$​ 的前提下进行的。因此，可以知道，如果接收信号传输的脉冲波形为 $s_m(t)$ （将该事件简记为 $s_m$ ），则输出向量 $\\vec{r}$ 满足的概率密度函数为： $$ \\rho(\\vec{r}|s_m)=\\prod\\limits_{k=1}^N\\rho(r_k|s_m)=\\frac{1}{(\\sqrt{\\pi N_0})^N}\\cdot\\exp\\left(-\\frac{\\displaystyle\\sum\\limits_{k=1}^N(r_k-\\hat{s}_{mk})^2}{N_0}\\right) $$ 那么，不难注意到，如果我们得到的抽样向量为 $\\vec{r}$ ，则若要使得判决结果 $s(t)$ 满足最小错误概率准则，应进行如下判决： $$ s(t)=\\underset{s_m(t)\\in S_M}{\\text{argmax}}\\{\\rho(s_m|\\vec{r})\\} $$ 其中， $\\text{argmax}$ 代表能够使目标函数取得最大值的自变量集合，上述判决准则的含义是：在已知抽样向量 $\\vec{r}$ 的条件下，如果取得某个脉冲波形 $s_m(t)$ 的条件概率最大，则就认为接收波形传输的是 $s_m(t)$ 。从概率论的角度， $\\rho(s_m|\\vec{r})$ 是后验概率，因此这种判决准则又被称为最大后验概率准则（Maximum A Posteriori Estimation, MAP）。\n利用最大后验概率准则，我们可以使判决完全满足最小错误概率准则。但是，最大后验概率准则是可实现的吗？这一问题实质上等价于在已知抽样向量 $\\vec{r}$ 时，后验概率密度 $\\rho(s_m|\\vec{r})$ 是否是可算的。为此，我们可以使用Bayes公式，将后验概率 $\\rho(s_m|\\vec{r})$ 转化为先验概率 $\\rho(\\vec{r}|s_m)$ ： $$ \\rho(s_m|\\vec{r})=\\frac{\\displaystyle \\rho(\\vec{r}|s_m)\\cdot\\rho(s_m)}{\\displaystyle\\rho(\\vec{r})}=\\frac{\\displaystyle \\rho(\\vec{r}|s_m)\\cdot\\rho(s_m)}{\\displaystyle\\sum\\limits_{m=1}^M\\rho(\\vec{r}|s_m)\\cdot\\rho(s_m)} $$由上式可知，由于 $\\rho(\\vec{r}|s_m)$ 是已知的，如果希望计算 $\\rho(s_m|\\vec{r})$ ，则必须需要知道 $\\rho(s_m)$ ，即各脉冲波形在序列中出现的概率，但很显然，对接收系统而言，我们无法事先预判各脉冲波形出现的概率，因此， $\\rho(s_m)$ 是未知的，进而导致 $\\rho(s_m|\\vec{r})$ 不可算，基于最大后验概率准则的抽样判决实质上是不可实现的。\n但是，最大后验概率准则并非一无是处，虽然我们无法知道确切的 $\\rho(s_m)$ ，但我们可以作一个先验的假设，认为任一脉冲波形的出现均是等概率的（即 $\\rho(s_m)=1/M,~m=1,~2,\\cdots,~M$ ），则我们有： $$ \\rho(s_m|\\vec{r})=\\frac{\\rho(\\vec{r}|s_m)}{\\displaystyle\\sum\\limits_{k=1}^M\\rho(\\vec{r}|s_k)} $$ 注意到， $\\displaystyle\\sum\\limits_{k=1}^M\\rho(\\vec{r}|s_k)$ 对固定的 $\\vec{r}$ 而言是一个常量，则最大后验概率准则对应的判决表达式可等价为： $$ s(t)=\\underset{s_m(t)\\in S_M}{\\text{argmax}}\\left\\{\\rho(\\vec{r}|s_m)\\right\\} $$ 这一判决准则又被称为最大似然概率准则（Maximum Likelihood Estimation, ML），考虑到前文已给出的 $\\rho(\\vec{r}|s_m)$ 的表达式，该准则可进一步等价为（利用 $\\mathrm{e}^{-x}$ 的单调性）： $$ s(t)=\\underset{s_m(t)\\in S_M}{\\text{argmin}}\\{\\Vert\\vec{r}-\\hat{s}_{m}\\Vert^2\\},~\\hat{s}_m=[\\hat{s}_{m1},~\\hat{s}_{m2},\\cdots,~\\hat{s}_{mN}]^T $$ 直观上，最大似然概率准则即是在得到抽样向量 $\\vec{r}$ 后，直接比较 $\\vec{r}$ 与各个 $\\hat{s}_m$ 系数的平方误差，认为其中的最小者即为传输的脉冲波形。\n一类特殊情形 以下，我们考查在前文中提到的一类特殊情形，此时的脉冲波形只有两种 $s_{(1)}(t),~s_{(0)}(t)$ ，分别代表二进制1与二进制0，且我们可以使用一个基函数 $s(t)$ 对其进行展开： $$ s_{(i)}(t)=a_{(i)}\\cdot s(t),~i=0,~1 $$ 那么，此时的接收滤波器便可以仅由一个相关器 $\\mathscr{H}$ 构成（ $\\displaystyle y(t)=\\mathscr{H}{x(t)}=\\int_{0}^{T_s}s(\\tau)x(\\tau+t-T_s)\\mathrm{d}\\tau$ ），当传输脉冲波形为 $s_{(i)}(t)$ 时，对应相关器输出 $r$ 7为： $$ r=a_{(i)}+n_i,~i=0,~1 $$则若依据最大后验概率准则，此时的判定准则为： $$ \\rho(r|s_{(1)})\\cdot\\rho(s_{(1)})\\lesseqqgtr\\rho(r|s_{(0)})\\cdot\\rho(s_{(0)}) $$ 进一步等价于： $$ \\exp\\left(-\\frac{(r-a_{(1)})^2}{N_0}\\right)\\cdot\\rho(s_{(1)})\\lesseqqgtr\\exp\\left(-\\frac{(r-a_{(0)})^2}{N_0}\\right)\\cdot\\rho(s_{(0)}) $$ 此亦即： $$ \\exp\\left(\\frac{(a_{(1)}-a_{(0)})(2r-a_{(0)}-a_{(1)})}{N_0}\\right)=\\exp\\left(\\frac{(r-a_{(0)})^2-(r-a_{(1)})^2}{N_0}\\right)\\lesseqqgtr\\frac{\\rho(s_{(0)})}{\\rho(s_{(1)})} $$ 如果考查正逻辑（即 $a_{(1)}\u0026gt;a_{(0)}$ ），化简即有： $$ r\\lesseqqgtr\\frac{a_{(0)}+a_{(1)}}{2}-\\frac{N_0}{2}\\cdot\\frac{\\ln(\\rho(s_{(1)}))-\\ln(\\rho(s_{(0)}))}{a_{(1)}-a_{(0)}} $$ 由此可知，判决门限 $\\gamma$ 满足： $$ \\gamma=\\frac{a_{(0)}+a_{(1)}}{2}-\\frac{N_0}{2}\\cdot\\frac{\\ln(\\rho(s_{(1)}))-\\ln(\\rho(s_{(0)}))}{a_{(1)}-a_{(0)}} $$ 当 $r\u0026gt;\\gamma$ 时，将接收信号判定为二进制1；当 $r\u0026lt;\\gamma$ 时，将接收信号判定为二进制0。而若依据最大似然概率准则，则判决门限退化为： $$ \\gamma=\\frac{a_{(0)}+a_{(1)}}{2} $$码间串扰（ISI） 码间串扰的基本概念 在前文中我们提到过，为保证我们用于传输波形的脉冲 $s(t)$ 为基带信号，我们需要在传输前对其进行脉冲/基带成型，即使用低通滤波器迫使其频谱仅在低频有限域内非0。而我们忽略了这一操作对时域脉冲波形的影响，即一个频域有限的信号在时域上通常是无限的。换言之，对进行脉冲/基带成型后的脉冲波形 $\\displaystyle s(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}s_n(t)$ 而言， $s_n(t)$ 在时域上是无限的，因此，不同码元对应的脉冲波形便会相互重叠，发生干扰，这一现象便称为 码间串扰（Inter-Symbol Interference, ISI） ，如下图所示：\n那么，如何从数学上定量描述码间串扰呢？需要指出，对数字基带传输系统而言，我们其实仅关注码间串扰对最终抽样判决的影响，因此，我们可以将数字基带传输系统抽样判决前的所有部分抽样为一个子系统 $\\mathscr{H}$ ，对输入信号 $s(t)$ 的单位脉冲响应为 $h(t)$ 。同时，AWGN噪声 $n(t)$ 是在传输时加入的，由于其具有加性，因此可与 $s(t)$ 相对独立地进行分析，我们可直接记噪声通过接收滤波器后的输出为 $n_r(t)$ ，则需进行抽样判决的信号 $y(t)$ 为： $$ y(t)=\\mathscr{H}\\{s(t)\\}+n_r(t)=s(t)*h(t)+n_r(t) $$ 代入 $\\displaystyle s(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}s_n(t)$ ，有： $$ y(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}\\left(\\int_{-\\infty}^{+\\infty}s_n(\\tau)h(t-\\tau)\\mathrm{d}\\tau\\right)+n_r(t) $$ 我们考虑 $s_n(t)=a_n\\cdot \\hat{s}(t-nT_s)$ 的特殊情形，则有： $$ y(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}\\left(a_n\\cdot\\int_{-\\infty}^{+\\infty}\\hat{s}(\\tau-nT_s)h(t-\\tau)\\mathrm{d}\\tau\\right)+n_r(t) $$ 于是，在 $t=kT_s$ 处抽样时，对应的抽样值 $y(kT_s)$ 可化作： $$ y(kT_s)=a_k\\cdot\\left(\\int_{-\\infty}^{+\\infty}\\hat{s}(\\tau-kT_s)h(kT_s-\\tau)\\mathrm{d}\\tau\\right)+\\sum\\limits_{n\\ne k}\\left(a_n\\cdot\\int_{-\\infty}^{+\\infty}\\hat{s}(\\tau-nT_s)h(kT_s-\\tau)\\mathrm{d}\\tau\\right)+n_r(kT_s) $$ 我们可以不妨设 $\\hat{s}(t)=\\delta(t)$ 8 ，则上式可化简为： $$ y(kT_s)=a_k\\cdot h(0)+\\sum\\limits_{n\\ne k}a_n\\cdot h((k-n)T_s)+n_r(kT_s) $$ 其中， $a_k\\cdot h(0)$ 为第 $k$ 个码元对应的样本， $\\displaystyle \\sum\\limits_{n\\ne k}a_n\\cdot h((k-n)T_s)$ 为码间串扰， $n_r(kT_s)$ 为AWGN噪声。\n使用均衡滤波器消除码间串扰 前文提及，我们可以使用均衡滤波器消除码间串扰，本节我们便来考虑均衡滤波器的具体实现。\n我们记均衡滤波器为系统 $\\mathscr{B}$ ，均衡滤波器的输入信号为 $y(t)$ ： $$ y(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot h(t-nT_s)+n_r(t) $$ 同时设均衡滤波器的输出信号： $z(t)=\\mathscr{B}\\{y(t)\\}$ ，则不妨假定这是一个线性非时变系统，我们有： $$ z(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot\\mathscr{B}\\{h(t-nT_s)\\}+\\mathscr{B}\\{n_r(t)\\} $$ 为方便说明，不妨记 $h_o(t)=\\mathscr{B}\\{h(t)\\},~n_o(t)=\\mathscr{B}\\{n_r(t)\\}$​ ，则利用系统的非时变性，有： $$ z(t)=\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot h_o(t-nT_s)+n_o(t) $$ 对均衡滤波器，要使其能够消除码间串扰，我们至少希望输出信号在抽样时刻对应的码间串扰为0，而样本不为0，考虑 $t=kT_s$ 时刻的抽样，即： $$ a_k\\cdot h_o(0)\\ne0,~\\sum\\limits_{n\\ne k}a_n\\cdot h_o((k-n)T_s)=0,~\\forall k\\in \\mathbb{Z} $$ 如果我们进一步加强条件，我们其实可以要求 $h_o(t)$ 满足： $$ \\mathscr{B}\\{h(t)\\}=h_o(t)=\\left\\{\\begin{array}{lcl} 1\u0026\u0026t=0\\\\ \\\\ 0\u0026\u0026t=kT_s,~\\forall k\\in \\mathbb{Z}/\\{0\\}\\\\ \\end{array}\\right. $$ 要实现这一点，其实我们仅需记系统 $\\mathscr{B}$ 的单位脉冲响应为 $\\displaystyle b(t)=\\sum_{n=-\\infty}^{+\\infty}b_k\\cdot\\delta(t-kT_s)$ ，则易有： $$ h_o(t)=\\int_{-\\infty}^{+\\infty}b(\\tau)h(t-\\tau)\\mathrm{d}\\tau=\\sum\\limits_{n=-\\infty}^{+\\infty}b_n\\cdot h(t-nT_s) $$ 因此，我们仅需确定系数 $b_k,~k\\in\\mathbb{Z}$ ，使得 $h_o(t)$ 满足性质即可。同时，我们注意，此时的系统 $\\mathscr{B}$ 对应递归方程： $$ y(t)=\\mathscr{B}\\{x(t)\\}=\\sum\\limits_{n=-\\infty}^{+\\infty}b_n\\cdot x(t-nT_s) $$ 一方面，这一系统是非因果的，同时涉及无限多个延时器，因此是物理不可实现的，为获得一个物理可实现的均衡滤波器，我们考查如下系统： $$ y(t)=\\mathscr{B}\\{x(t)\\}=\\sum\\limits_{n=0}^{N}b_n\\cdot x(t-nT_s),~b(t)=\\sum\\limits_{n=0}^{N}b_n\\cdot\\delta(t-nT_s) $$ 上述系统即是将系统响应的无穷求和变为了有限项求和，此时输出 $\\displaystyle h_o(t)=\\sum\\limits_{n=0}^{N}b_n\\cdot h(t-nT_s)$ ，为方便讨论，我们记 $c_k=h(kT_s)$ ，则有： $$ h_o(kT_s)=\\sum\\limits_{n=0}^{N}b_n\\cdot c_{k-n} $$ 首先注意两个事实：\n$h(t)$ 是因果系统的单位脉冲响应，因此对所有的$k\u0026lt;0$，有 $c_k=0$ ，进而 $h_o(kT_s)=0$ （这也可以理解为因果系统级联仍为因果系统）。 $h_o(t)$ 在 $t$ 充分大时通常近似为0。 因此，我们对 $h_o(t)$ 的要求其实可以弱化为： $$ \\mathscr{B}\\{h(t)\\}=h_o(t)=\\left\\{\\begin{array}{lcl} 1\u0026\u0026t=0\\\\ \\\\ 0\u0026\u0026t=kT_s,~1\\leqslant k\\leqslant N\\\\ \\end{array}\\right. $$ 其中，保证 $N$ 为一充分大的正整数即可，换言之，对码元 $a_n\\cdot h_o(t-nT_s)$ ，我们仅需考虑其对未来 $N$ 个码元（对过去的码元无影响）的码间串扰，之后的码间串扰即使不作处理也可忽略不计。\n进而，我们仅需确定 $N+1$ 个未知数 $b_k,~0\\leqslant k\\leqslant N+1$ 的取值，其应满足线性方程组： $$ \\left[\\begin{array}{cccc} c_0\u0026c_{-1}\u0026\\cdots\u0026c_{-N}\\\\ c_1\u0026c_0\u0026\\cdots\u0026c_{1-N}\\\\ \\vdots\u0026\\vdots\u0026\\ddots\u0026\\vdots\\\\ c_N\u0026c_{N-1}\u0026\\cdots\u0026c_{0} \\end{array}\\right]\\left[\\begin{array}{c} b_0\\\\ b_1\\\\ \\vdots\\\\ b_N \\end{array}\\right]=\\left[\\begin{array}{c} 1\\\\ 0\\\\ \\vdots\\\\ 0 \\end{array}\\right] $$ 这种均衡滤波器设计一般称为迫零均衡器，其实现如下：\n其中， $N$ 一般称为迫零均衡器的抽头数。\n均衡滤波器的性能评估 以下，我们可给出用于评估均衡滤波器的性能指标，记均衡滤波器 $\\mathscr{B}$ 前子系统的单位脉冲响应为 $h(t)$ ，且 $h_o(t)=\\mathscr{B}\\{h(t)\\}$ ，则有：\n输出峰值失真： $\\displaystyle D_o=\\frac{\\displaystyle \\sum\\limits_{n\\ne 0}h_o(nT_s)}{h_o(0)}$ ，即输出信号码间串扰与原样本的比值。 输入峰值失真： $\\displaystyle D=\\frac{\\displaystyle \\sum\\limits_{n\\ne 0}h(nT_s)}{h(0)}$ ，即输入信号码间串扰与原样本的比值。 一般地，我们使用 $\\eta=D/D_o$ 来评估均衡滤波器的效果， $\\eta$ 越大，均衡滤波器的效果越好。\n但同时注意，均衡滤波器不可避免地会对噪声信号 $n_r(t)$ 进行进一步处理，导致在 $t=kT_s$ 抽样时，信噪比可能有所降低。\n有的文本中会直接表述为“用数字序列调制脉冲波形”，此处使用整合一词只是为了方便理解，并区别于载波调制过程。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n在数字通信中常常用时间间隔相同的符号来表示一个二进制数字，这样的时间间隔内的信号称为（二进制）码元，时间间隔长度则被称为码元宽度。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n传码率指单位时间内传输的码元数；传信率指单位时间内传输的比特数。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n对信号 $n(t)$ ，其平均功率定义为： $\\displaystyle P=\\lim\\limits_{T\\to+\\infty}\\frac{1}{T}\\int_{-T/2}^{T/2}n^2(t)\\mathrm{d}t$，若记 $n_T(t)$ 为 $n(t)$ 在 $[-T/2,~T/2]$ 内的表达式（其余区域内取值为0），对应的Fourier变换为 $N_T(\\omega)$ ，则平均功率亦可记作 $\\displaystyle P=\\int_{-\\infty}^{+\\infty}\\lim\\limits_{T\\to+\\infty}\\frac{n_T^2(t)}{T}\\mathrm{d}t$ ，利用Parseval定理，可得 $P=\\displaystyle \\int_{-\\infty}^{+\\infty}\\lim\\limits_{T\\to+\\infty}\\frac{|N_T(\\omega)|^2}{2\\pi T}\\mathrm{d}\\omega$，则我们一般称 $P_s(\\omega)=\\displaystyle\\lim\\limits_{T\\to+\\infty}\\frac{|N_T(\\omega)|^2}{2\\pi T}$ 为信号 $n(t)$ 对应的功率密度函数/功率谱。同理，我们也可以定义 $n(t)$ 的能量密度函数/能量谱为 $E_s(\\omega)=\\displaystyle \\lim\\limits_{T\\to+\\infty}\\frac{|N_T(\\omega)|^2}{2\\pi}$。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n此处的平均功率，指的是噪声信号 $n(t)$ 在某一时刻瞬时功率的数学期望，而先前定义功率谱时的平均功率，指的是噪声信号 $n(t)$ 在整个时域上功率的平均值。基于此，我们也可对AWGN噪声模型有一个更清晰的理解： $n(t)$ 在每个时刻的取值都服从正态分布，而所有时刻的 $n(t)$ 取值构成的噪声信号又要使得其对应的功率谱为一常数。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n其实，更一般地，对第 $k$ 个码元 $s_k(t)$ ，我们仅需认为其在 $[0,~kT_s]$ 上非0即可。↩\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n此处为方便讨论，不妨设 $s(t)$ 的能量是1。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n此处可以简单解释下为何可以不妨令 $\\hat{s}(t)=\\delta(t)$ ，注意到 $s(t)=\\displaystyle\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot\\hat{s}(t-nT_s)=\\hat{s}(t)*\\left(\\displaystyle\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot\\delta(t-nT_s)\\right)$ ，因此我们可以将输入信号视为 $\\displaystyle\\sum\\limits_{n=-\\infty}^{+\\infty}a_n\\cdot \\delta(t-nT_s)$ ，再在子系统 $\\mathscr{H}$ 首端级联一个单位脉冲响应为$\\hat{s}(t)$ 的系统以得到 $s(t)$ 。当然，当我们设 $\\hat{s}(t)=\\delta(t)$ 时，子系统 $\\mathscr{H}$ 的单位脉冲响应也要加入 $\\hat{s}(t)$ 。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-29T00:00:00Z","image":"https://posvirus.github.io/p/dic-006/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-006/","title":"基带信号的调制与解调"},{"content":" 本文是我在几年前学习《VLSI数字信号处理系统设计》这门课程时所做的笔记，此处进行简单整理，以供复习。\n一般通信系统 通信系统的定义： 通信系统是传输信息所需技术设备的总和。\n通信系统的一般模型：\n通信系统一般由信息源（信源）、发送设备、信道、接收设备、受信者（信宿） 构成，各成分的具体定义如下：\n信息源（信源）： 产生或发出消息的人或机器 发送设备： 将信源产生的消息信号变换成便于传送的形式 接收设备： 从带有干扰的接收信号中正确恢复出原始信号 受信者（信宿）： 接收消息的人或机器 同时，我们可对通信系统传输的信号进行分类：\n基带信号（Baseband）： 信源发出的没有经过调制（进行频谱搬移和变换）的原始电信号，其特点是信号的幅度在零频附近不全为零，在其他频率幅度全为零，对一个基带信号 $f(t)$ ，其性质可用数学语言描述为： $$ \\exists \\omega_H\u003e0,~\\text{s.t.}~F(\\omega)=0,~\\forall \\omega\u003e\\omega_H,~F(\\omega)=\\mathscr{F}\\{f(t)\\} $$ 频带/带通信号（Bandpass）： 被调制后的基带信号，又称为已调信号，在以 $|f|=f_c$ 为中心的一个频带内幅度不全为零，其中 $f_c\\gg 0$ ，叫做载波频率。 载波信号（Carrier）： 用于调制基带信号的载体，基带信号通过载波信号映射为带通信号，这个带通信号以某个频率 $f_c$ 为载波，这一过程通常被称为载波调制（Carrier modulation/demodulation）。 注： 在利用通信系统进行信号传输时，由于在近距离范围内基带信号的衰减不大，从而信号内容不会发生变化。因此在某些具有低通特性的有线信道中，特别是传输距离不太远的情况下，基带信号可以不经过调制而直接进行传输。如计算机内部并行总线上的信号全部都是基带信号，还有从计算机到监视器、打印机等外设的信号也都是基带传输的。在大多数的局域网直接使用基带脉冲信号传输，如以太网、令牌环网。\n但是，基带信号包含的低频分量不易通过无线传输，无线电磁波一般在空中传播的频率要高于100KHz（这是因为根据 $\\lambda f= c$ ，无线通信所使用的电磁波波长较短，进而具有更高的频率）。基带信号需要进行调制，与载波高频信号混频后变换到较高的频率，然后比较容易通过天线发射（天线长度应该至少达到 $0.25\\lambda\\sim 0.5\\lambda$ ，这也解释了为什么无线通信需要使用较短波长的电磁波，假设无线通信使用的频率为 $100~\\text{KHz}$，光速默认为 $3\\times10^8~\\text{m/s}$ ，则可计算出电磁波波长为 $\\lambda=c/f=3\\times 10^3~\\text{m}$ ）。因此自由空间通常传输的都是频带信号。\n通信系统的分类： 通信系统根据所传信息的信号表示形式，可分为模拟通信系统和数字通信系统：\n模拟通信系统： 利用模拟信号传输信息的系统，一般是将采集的信号直接进行传输。 数字通信系统： 利用数字信号传输信息的系统，一般是将信号转变为数字信号后再进行传输。 模拟通信系统正在逐步被数字通信系统取代，因为数字通信系统具备如下优点：\n抗干扰能力强，噪声不积累 易于采用纠错编码控制传输差错 易于加密处理，且保密度高 便于处理、变换和存储 易于集成，方便小型化 但数字通信系统在现阶段也存在着若干不足：\n数据率高 同步要求高 实现复杂度高 虽然数字通信系统存在一些不足之处，但瑕不掩瑜，本课程的剩余部分，我们仍以数字通信系统为主体进行研究。\n数字通信系统 数字通信系统的一般模型：\n读图可知，数字通信系统中，在发送设备与接收设备中分别存在着信道编码、信源编码与信道译码、信源译码两个过程，这是数字通信系统所独有的：\n信源编码： 信源编码是将信息转换成二进制数据，而后进行适当的压缩。 信源译码： 信源编码的逆过程。 信道编码： 信道编码是在信息传入信道前，对信息的二次编码过程，也叫差错控制编码，就是在发送端对原数据添加冗余信息，这些冗余信息是和原数据相关的，再在接收端根据这种相关性来检测和纠正传输过程产生的差错，从而对抗传输过程的干扰。 信道译码： 通过信道编码中加入的冗余信息恢复原信号的过程。 通信系统的分类 按通信业务分类： 电话通信系统、数据通信系统、图像通信系统、多媒体通信系统 按是否调制信号分类： 基带传输系统、频带传输（带通传输）系统 按传输媒质分类： 有线通信系统（以光纤通信为主）、无线通信系统（以无线电通信为主） 对无线电通信，我们又有进一步的分类： 按工作波段分类： 长波通信、短波通信、超短波通信、微波通信等系统 按接入方式分类： 频分多址、时分多址、码分多址等系统 按频带利用方式： 定频窄带通信、跳频通信、扩频通信等系统 按消息传送的方向与时间分类： 单工通信（Simplex）： 消息只能单向传输的通信工作方式（如广播、遥控、无线寻呼等） 半双工通信（Half Duplex）： 通信双方都具备收发能力，但收发不能同时工作（如对讲机等） 全双工通信（Full Duplex）： 收发双方可同时进行双向消息传输的方式（如电话等） ","date":"2025-11-18T00:00:00Z","image":"https://posvirus.github.io/p/dic-005/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-005/","title":"通信系统简介"},{"content":"本文主要讨论DIC中的 时钟分频器（Clock Divider） 电路设计，它主要用于实现对输入时钟的分频处理，其模块端口声明通常如下所示：\n1 2 3 4 5 6 7 module clk_divider ( input wire clk, // input clock input wire rst_n, // reset output reg clk_out // output clock ); /* internal logic */ endmodule 同时，我们不妨直接在此处给出用于时钟分频器测试的Testbench，以供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 module test (); // input clock generate reg clk; always #1 clk = ~clk; // T = 2ns // module instantiate reg rst_n; wire clk_out; clk_divider u_clk_divider ( .clk (clk ), .rst_n (rst_n ), .clk_out (clk_out ) ); // stimulus initial begin clk = 1\u0026#39;b0; rst_n = 1\u0026#39;b0; #10; @(posedge clk); rst_n = 1\u0026#39;b1; #10000; $stop; end // waveform initial begin $dumpfile(\u0026#34;wave.vcd\u0026#34;); $dumpvars(0, test); end endmodule 整数分频 顾名思义，整数分频是指输入时钟的频率$f_\\text{ref}$需要是输出时钟的频率$f_\\text{out}$的整倍数，即： $$ f_\\text{ref} = N \\times f_\\text{out}, N\\in \\mathbb{N}_+ $$ 这一部分的电路实现在网上的各种博客中都有非常详细的讨论，此处只作简单说明。一般而言，我们会将其分为偶数分频与奇数分频两类进行考查：\n偶数分频 对于偶数分频，假设分频数$N=2k$，则我们不难知道，如需保证分频时钟的占空比为50%，则输出时钟的高电平脉宽与低电平脉宽均为$k$个输入时钟周期。因此，我们容易通过计数器实现这一功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 module clk_divider #( parameter DIV_NUM = 4\u0026#39;d10, // should be set to even parameter CNT_WIDTH = 4 ) ( input wire clk, input wire rst_n, output reg clk_out ); localparam PULSE_WIDTH_CYC = DIV_NUM \u0026gt;\u0026gt; 1; // cycle counter reg [CNT_WIDTH-1:0] cyc_cnt; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin cyc_cnt \u0026lt;= {(CNT_WIDTH){1\u0026#39;b0}}; end else if (cyc_cnt == DIV_NUM - 1) begin cyc_cnt \u0026lt;= {(CNT_WIDTH){1\u0026#39;b0}}; end else begin cyc_cnt \u0026lt;= cyc_cnt + \u0026#39;b1; end end // output clock always @(*) begin if (cyc_cnt \u0026lt; PULSE_WIDTH_CYC) begin clk_out = 1\u0026#39;b0; end else begin clk_out = 1\u0026#39;b1; end end endmodule 注意，在偶数分频中，有一类非常特殊的情况，即$2^k$倍分频，对于这类分频器设计，一些博客给出的方案是这样的：\n采用触发器反向输出端连接到输入端的方式可实现二分频电路，随后将$k$个二分频电路的前级输出与后级时钟输入级联，即可构成$2^k$倍分频电路。\n对于这类方案，我们需要做一些额外的说明：这类利用触发器数据输出与时钟输入级联的方案一般只适用于全定制电路设计，即设计人员从晶体管级开始对电路的各部分进行精细设计与布局，而不是依赖标准单元库或自动化后端工具。\n如果我们使用RTL代码对该模块进行描述的话，在进行后端综合时，这样$k$个触发器级联的结构其实额外引入了$k$个时钟域（每一级触发器的输入时钟频率都不相同），从而需要人为引入额外的时序约束确保电路的正确建模（甚至某些EDA本身就不支持这类数据输出与时钟输入相连的静态时序分析）。另外，这种描述在一些形式化验证工具中也可能直接导致验证失败。\n后续或许会写一篇博客讨论综合时各类时钟如何进行约束，这里先Mark一下~\n所以，在使用RTL代码设计$2^k$倍分频器时，我们仍然推荐使用前文的计数器实现，其实从面积占用的角度看，对于$2^k$倍分频，两者对应的电路面积均$\\propto k$（假设电路面积主要由D触发器的个数决定），所以差异其实并不大。\n奇数分频 对于奇数分频，假设分频数$N=2k+1$，此时如需保证分频时钟的占空比为50%，则输出时钟的高电平脉宽与低电平脉宽均为$k+0.5$个输入时钟周期。这时我们会发现，前文基于计数器的实现方案失效了，因为计数器是输入时钟单边沿触发的，所以无法实现对半个时钟周期的计数。因此，我们需要进行分类讨论：\n第一，如果设计不严格要求输出时钟的占空比为50%，那么前文基于计数器的实现方案仍然可以复用，我们取高电平脉宽或低电平脉宽为$\\lceil k+0.5\\rceil$即可。\n第二，如果设计严格要求输出时钟的占空比为50%，则需要考虑如何处理对半个输入时钟周期的计数，此处，我们首先给出如下结论：\n对于输入时钟的$2k+1$倍分频，如果我们生成了高电平脉宽为$k$个输入时钟周期的时钟（记为$\\text{CP}$），同时将$\\text{CP}$移相半个输入时钟周期的时钟记为$\\text{CN}$，则占空比严格为50%的$2k+1$倍分频时钟$\\text{CLK}$为$\\text{CP}$与$\\text{CN}$进行或运算的结果。\n我们可以结合上图理解这一结论，当$\\text{CP}$与$\\text{CN}$进行或运算时，两者的高电平区间正好相差半个输入时钟周期，则运算结果的高电平脉宽即为$k+0.5$个输入时钟周期（对称地，我们也可以生成低电平脉宽为$k$个输入时钟周期的时钟，将其移相半个输入时钟周期后进行与运算）。\n于是，问题便化归为：如何将时钟$\\text{CP}$移相半个输入时钟周期？我们同样可以从全定制电路实现与RTL代码描述两个角度对其进行说明：\n对于全定制电路，我们仅需将$\\text{CP}$连接至一个负边沿触发的触发器的数据输入，并使用原输入时钟采样即可，可用RTL代码描述如下（注意！这里仅仅是以RTL代码作为电路描述方式，实际实现时不可使用RTL描述，因为很多综合工具并不支持单个电路中同时存在正/负边沿触发）：\n1 2 3 4 5 6 7 reg cn; always @(negedge clk) begin cn \u0026lt;= cp; end assign clk_out = cp | cn; 对于RTL描述，我们则可以同时例化两个前文基于计数器的分频器，一个使用负边沿触发，一个使用正边沿触发，最后两个分频器输出时钟的相位差即为半个输入时钟周期，基于前文clk_divider模块的RTL实现示例如下（由于该模块在进行奇数分频时，输出的是低电平脉宽为$k$个输入时钟周期的时钟，因此我们最后需要进行与运算）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 wire cp, cn, clk_out; clk_divider #( .DIV_NUM (3\u0026#39;d5 ), .CNT_WIDTH (3 ) ) u_clk_divider_p ( .clk (clk ), .rst_n (rst_n ), .clk_out (cp ) ); clk_divider #( .DIV_NUM (3\u0026#39;d5 ), .CNT_WIDTH (3 ) ) u_clk_divider_n ( .clk (~clk ), .rst_n (rst_n ), .clk_out (cn ) ); assign clk_out = cp \u0026amp; cn; 有理数分频 有理数分频的通用方法 除整数分频外，还有一类情况是有理数分频，它通常需要输出时钟的频率$f_\\text{out}$与输入时钟的频率$f_\\text{ref}$满足： $$ f_\\text{ref} = \\frac{p}{q}\\times f_\\text{out},~p,q\\in \\mathbb{N}_+,~p\u003eq $$ 上式中的$p\u0026gt;q$是为了保证$f_\\text{ref}\u0026gt;f_\\text{out}$，亦即保证我们在进行的是一个 “分频” 的行为而非 “倍频” 的行为。\n但这类需求在DIC中通常是无法实现的，观察输入/输出时钟的频率，对输入时钟的$p/q$倍分频实际上需要对输入时钟进行$q$倍频后，再进行$p$分频，而对于倍频，通常只能使用PLL等模拟方案实现。\n因此，这里我们其实只能实现一个近似的有理数分频方案，我们对上式进行变化，记输入时钟与输出时钟的周期分别为$T_\\text{ref}$与$T_\\text{out}$，则： $$ \\frac{1}{T_\\text{ref}}=\\frac{p}{q}\\times\\frac{1}{T_\\text{out}}~\\Rightarrow~q\\times T_\\text{out}=p\\times T_\\text{ref} $$ 上式说明，对输入时钟的$p/q$倍分频其实需要保证在$p$个输入时钟周期内，输出时钟需要经过$q$个输入时钟周期。\n在有理数分频的近似实现中，我们仅需保证在$p$个输入时钟周期内，输出时钟经过$q$个输入时钟周期这一条件即可，而无需考虑输入时钟的$q$个时钟周期是否均匀，占空比是否严格为50%。换言之，我们仅需在$p$个输入时钟周期内让输出时钟翻转$2q$次即可。\n但是，为了近似实现有理数分频的效果，我们仍然希望输出时钟的$2q$次翻转尽量均匀。在实际设计中，这通常是通过整数分频叠加的方式实现的，具体而言，如果我们能找到一个整数$k$，使得在$p$个输入时钟周期内，我们可以恰好实现对输入时钟的$q-m$次$k$分频和$m$次$k+1$分频，这样便可以从最大程度上保持输出时钟的均匀性1，从数学上描述，我们需要： $$ (q-m)\\times k+m\\times (k+1) = p,~m,k\\in\\mathbb{N}_+ $$ 以下，我们将通过求解得到$(m,k)$，首先，整理上式得到： $$ q\\times k + m=p $$ 两边同除$q$得到： $$ k=\\frac{p}{q}-\\frac{m}{q} $$ 注意到$m\u0026lt;q$，因此$m/q \u0026lt;1$，所以我们可以直接取： $$ k=\\left\\lfloor\\frac{p}{q}\\right\\rfloor $$ 进而： $$ m=p-q\\times k =p-q\\times\\left\\lfloor\\frac{p}{q}\\right\\rfloor=p~(\\text{mod}~ q) $$ 综上，求解得到的$(m,k)$为： $$ (m,k) = \\left(p~(\\text{mod}~ q),~\\left\\lfloor\\frac{p}{q}\\right\\rfloor\\right) $$ 请注意，在上述分析中，我们并没有规定$p$与$q$需要互质，换言之，对于一个确定的有理数分频设计，$k$是确定的，但是$m$是与$(p,~q)$相关的，我们可以对$(p,~q)$进行等比例缩放以对$m$进行缩放。比如，我们要实现5.4倍分频，则易得$k=5$，而对于$m$，我们既可以取$(p,~q)$为$(54,~10)$，此时$m=4$，即需要在54个输入时钟周期内，实现对输入时钟的6次5分频和4次6分频；也可以取$(p,~q)$为$(27,~5)$，此时$m=2$，即需要在27个输入时钟周期内，实现对输入时钟的3次5分频和2次6分频。\n$(p,~q)$的选取通常没有固定的规则，但我们至少需要保证$(p,~q)$适当大，这样可以在更大的时间尺度上实现对$k$分频与$k+1$分频的均匀分配，进而降低输出时钟的偏斜。\n至此，我们已经确定了$(m,k)$的取值，之后仅需在$p$个输入时钟周期内，实现对输入时钟的$q-m$次$k$分频和$m$次$k+1$分频即可。但是这里还有一个问题，我们应该如何确定$q-m$次$k$分频和$m$次$k+1$分频的先后顺序呢？\n对于这个问题，决策的根本依据肯定是希望通过对这$q$次分频进行合理排序，使得输出时钟的$2q$次翻转尽量均匀，关键是如何量化输出时钟翻转的 “均匀性” ，这里我们通常通过最小化若干次分频后，理想输出时钟周期数（以输入时钟周期为单位）与实际输出时钟周期数（以输入时钟周期为单位）的差值进行决策，这可以通过如下数学建模描述：\n对于输入时钟的一次$k$分频而言，分频后的时钟周期长度为$k$个输入时钟周期，其与理想的$p/q$分频的时钟周期长度差值为$t=p/q-k$个输入时钟周期；对于输入时钟的一次$k+1$分频而言，分频后的时钟周期长度为$k$个输入时钟周期，其与理想的$p/q$分频的时钟周期长度差值为$t-1$个输入时钟周期2。\n进而，我们得到了一个包含$q-m$个$t$与$m$个$t-1$的无序序列，且满足： $$ (q-m)\\times t+m\\times(t-1)=0 $$我们的目标即是找到将该无序序列排序为一个有序数组 $\\{a_n\\}$ 的方案，使得数组 $\\{S_n\\}$ ： $$ S_n=\\sum\\limits_{i=1}^na_i,~1\\leqslant i\\leqslant q $$ 满足在所有排序方案中，$\\max\\limits_{1\\leqslant n\\leqslant q}{|S_n|}$ 取最小值。\n以下，我们来解决上述问题：\n首先消去变量$t$，已知： $$ t=\\frac{p}{q}-k=\\frac{p-k\\times q}{q}=\\frac{m}{q}~\\Rightarrow~t-1=\\frac{m-q}{q} $$ 因此，我们若记有序数组$\\{a_n\\}$的前$n$项中$t$的个数为$x_n$，则： $$ S_n=\\sum\\limits_{i=1}^na_i=x_n\\times t+(n-x_n)\\times(t-1)=n\\times(t-1)+x_n $$ 进而： $$ \\left|S_n\\right|=\\left|x_n-\\frac{n\\times(q-m)}{q}\\right| $$ 直观看来，我们只需要保证$x_n$尽可能接近$n\\times (q-m)/q$即可。以下，我们给出一种方案，并证明该方案的最优性，该方案可使用伪代码描述如下：\n1 2 3 4 5 6 7 8 9 x = 0; // temporary variable for i = 1 to q if round(n * (q - m) / q) \u0026gt; x insert t; // div by k x = round(n * (q - m) / q); else insert (t - 1); // div by (k + 1) endif endfor 比如，对于前文的$(p,~q)=(54,~10)$的情况，需要对输入时钟进行6次5分频和4次6分频，这可通过如下过程确定分频顺序：\n$x=0$，$(q-m)/q=0.6$，则$[ 1\\times 0.6]=1\u0026gt;x$3，插入5分频，同时令$x=1$。 $[2\\times0.6]=1=x$，插入6分频，$x$保持不变。 $[3\\times 0.6]=2\u0026gt;x$，插入5分频，同时令$x=2$。 $[4\\times0.6]=2=x$，插入6分频，$x$保持不变。 $[5\\times0.6]=3\u0026gt;x$，插入5分频，同时令$x=3$。 $[6\\times0.6]=4\u0026gt;x$，插入5分频，同时令$x=4$。 $[7\\times0.6]=4=x$，插入6分频，$x$保持不变。 $[8\\times0.6]=5\u0026gt;x$，插入5分频，同时令$x=5$。 $[9\\times0.6]=5=x$，插入6分频，$x$保持不变。 $[10\\times0.6]=6\u0026gt;x$，插入5分频，同时令$x=6$。 综上，插入的顺序即为：$5,~6,~5,~6,~5,~5,~6,~5,~6,~5$。\n分析该方案，其实我们不难发现，这里的$x$其实就代表着有序数组前$n$项中$t$的个数，亦即： $$ x_n=\\left[\\frac{n\\times (q-m)}{q}\\right] $$ 这是因为在该方案的操作过程中，如果对于某个$n$，满足： $$ \\left[\\frac{n\\times (q-m)}{q}\\right]\\leqslant x,~\\left[\\frac{(n+1)\\times (q-m)}{q}\\right]\u003e x $$ 则由于： $$ \\left|\\frac{(n+1)\\times (q-m)}{q}-\\frac{n\\times (q-m)}{q}\\right|=\\frac{q-m}{q}\u003c1 $$ 因此根据$n\\times(q-m)/q$, $x$, $(n+1)\\times(q-m)/q$在数轴上的分布，一定有： $$ \\left[\\frac{(n+1)\\times (q-m)}{q}\\right]= x+1 $$ 换言之，$x$每次改变，一定只会递增1，而每次$x$改变时又对应着在有序数组中插入$t$的操作，递归地，可验证上述结论的正确性。\n最后，我们来证明该方案的最优性：\n我们构造新数列$\\{f_n\\}$，用于描述$n\\times(q-m)/q$的小数部分，即： $$ f_n=\\left\\{\\frac{n\\times(q-m)}{q}\\right\\},~1\\leqslant n\\leqslant q $$ 于是对于该方案，由于$x_n$是对$n\\times(q-m)/q$的四舍五入取整，因此不难得到： $$ \\left|S_n\\right|=\\left|x_n-\\frac{n\\times(q-m)}{q}\\right|=\\min\\{f_n,~1-f_n\\} $$ 进而： $$ \\max\\limits_{1\\leqslant n\\leqslant q}\\{|S_n|\\}=\\max\\limits_{1\\leqslant n\\leqslant q}\\{\\min\\{f_n,~1-f_n\\}\\}=K $$ 注意$K$是一个仅与$(p,~q)$有关的值，它与我们选择的排序方案无关。以下我们将证明，对于任意的排序方案，$\\max\\limits_{1\\leqslant n\\leqslant q}{|S_n|}$一定不小于$K$：假设一种排序方案，前$n$项中$t$的个数为$x_n$，则注意到$x_n$是整数，易得： $$ \\left|S_n\\right|=\\left|x_n-\\frac{n\\times(q-m)}{q}\\right|\\geqslant\\min\\{f_n,~1-f_n\\} $$ 进而： $$ \\max\\limits_{1\\leqslant n\\leqslant q}\\{|S_n|\\}\\geqslant\\max\\limits_{1\\leqslant n\\leqslant q}\\{\\min\\{f_n,~1-f_n\\}\\}=K $$ 综上，我们即证明了前文提及排序方案的最优性。\n注意前文的所有分析，是在确定对于给定的有理数分频，我们应当如何选择若干次整数分频进行近似，以及这若干次整数分频应当如何排序以保证输出时钟的翻转尽量均匀。这些过程都是在进行分频器的硬件实现前就确定的，并不需要通过RTL代码描述。\n在确定$q$次分频的排序方案后，我们便可进行分频器的RTL设计，我们不妨再以5.4倍分频为例，给出如下示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 module clk_divider ( input wire clk, input wire rst_n, output reg clk_out ); localparam FRAC_Q = 10; localparam FRAC_K = 5; localparam FRAC_ORDER = 10\u0026#39;b0101001010; localparam ALC_CNT_WIDTH = 4; localparam CYC_CNT_WIDTH = 3; // allocation counter reg [ALC_CNT_WIDTH-1:0] alc_cnt; reg [CYC_CNT_WIDTH-1:0] cyc_cnt; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin alc_cnt \u0026lt;= {(ALC_CNT_WIDTH){1\u0026#39;b0}}; end else if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b0) \u0026amp;\u0026amp; (cyc_cnt == FRAC_K)) begin alc_cnt \u0026lt;= (alc_cnt \u0026lt; FRAC_Q - 1) ? (alc_cnt + \u0026#39;b1) : ({(ALC_CNT_WIDTH){1\u0026#39;b0}}); end else if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b1) \u0026amp;\u0026amp; (cyc_cnt == FRAC_K + 1)) begin alc_cnt \u0026lt;= (alc_cnt \u0026lt; FRAC_Q - 1) ? (alc_cnt + \u0026#39;b1) : ({(ALC_CNT_WIDTH){1\u0026#39;b0}}); end else begin alc_cnt \u0026lt;= alc_cnt; end end // cycle counter always @(posedge clk or negedge rst_n) begin if (~rst_n) begin cyc_cnt \u0026lt;= {(CYC_CNT_WIDTH){1\u0026#39;b0}}; end else if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b0) \u0026amp;\u0026amp; (cyc_cnt == FRAC_K)) begin cyc_cnt \u0026lt;= \u0026#39;b1; end else if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b1) \u0026amp;\u0026amp; (cyc_cnt == FRAC_K + 1)) begin cyc_cnt \u0026lt;= \u0026#39;b1; end else begin cyc_cnt \u0026lt;= cyc_cnt + \u0026#39;b1; end end // output clock always @(*) begin if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b0) \u0026amp;\u0026amp; (cyc_cnt \u0026lt;= (FRAC_K \u0026gt;\u0026gt; 1))) begin clk_out = 1\u0026#39;b0; end else if ((FRAC_ORDER[alc_cnt] == 1\u0026#39;b1) \u0026amp;\u0026amp; (cyc_cnt \u0026lt;= ((FRAC_K + 1) \u0026gt;\u0026gt; 1))) begin clk_out = 1\u0026#39;b0; end else begin clk_out = 1\u0026#39;b1; end end endmodule 当然，需要指出的是，$k$与$k+1$中必有一者是奇数，因此在处理有理数分频时，我们同时也需要处理奇数分频。\n半整数分频 最后，我们讨论一种特殊的有理数分频，即对输入时钟进行 $n+0.5$倍分频 （简称半整数分频），此时我们知道，输出时钟的周期$T_\\text{out}$与输入时钟的周期$T_\\text{ref}$需满足： $$ T_\\text{out}=\\left(n+0.5\\right)\\times T_\\text{ref} $$ 但这里我们不难发现，对于半个输入时钟周期的延时，我们是有可能利用输入时钟的双边沿触发精确实现的，故可以对其进一步优化：\n以下，我们不妨先按照通用方法实现，则： $$ \\frac{p}{q}=\\frac{1}{2}+n=\\frac{2n+1}{2} $$ 因此，我们可取$(p,~q)=(2n+1,~2)$，则$(m,~k)=(1,~n)$，这说明我们可以在$2n+1$个输入时钟周期内，通过对输入时钟的一次$n$分频与一次$n+1$分频近似$n+0.5$分频的效果。\n以下，我们进行如下操作：\n以输入时钟上升沿触发，顺次进行$k+1$分频与$k$分频，各分频时钟的高电平脉宽均为$\\left\\lfloor k/2\\right\\rfloor$个输入时钟周期，得到输出时钟$\\text{CP}$。\n以输入时钟上升沿触发，顺次进行$k$分频与$k+1$分频，并将其移相半个时钟周期，各分频时钟的高电平脉宽均为$\\left\\lfloor k/2\\right\\rfloor$个输入时钟周期，得到输出时钟$\\text{CN}$。\n取$\\text{CLK}$为$\\text{CP}$与$\\text{CN}$进行或运算的结果，则$\\text{CLK}$的周期即为$k+0.5$个输入时钟周期。\n上述操作本质上是对$k+1$分频时钟与$k$分频时钟进行平均化操作，此处便不进行严格证明了，我们不妨以3.5倍分频为例，展示其效果：\n这种方法通常被称为双模前置小数分频法。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这里取$t-1\u0026lt;0$，代表分频后的时钟周期长度大于理想分频后的时钟周期长度。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这里的$[x]$代表对$x$进行四舍五入取整。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-11T00:00:00Z","image":"https://posvirus.github.io/p/dic-004/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-004/","title":"时钟分频"},{"content":"本文主要讨论DIC中的 序列检测器（Sequence Detector） 电路设计，这是一种非常经典的功能性电路，它通常用于检测二进制序列输入中的某个特定模式的子序列，其模块端口声明通常如下所示：\n1 2 3 4 5 6 7 8 module seq_detector ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); /* internal logic */ endmodule 序列检测问题的分类 目前网上的博客已对序列检测问题进行了非常详细的分类1，具体而言，我们可以从检测问题本身与电路设计两个方面对其进行分类：\n从序列检测问题本身，其可分为重复检测与非重复检测两类：\n重复检测指在输入数据流中，若已匹配序列的尾部与后续输入构成新的有效序列（即存在重叠部分），则允许连续多次触发匹配信号。检测器在完成一次匹配后，不强制回到初始状态。常用于需要捕获所有可能实例的场景（如通信协议中的帧头检测）。 非重复检测指一旦匹配到完整的目标序列，检测器立即复位到初始状态，忽略该序列尾部可能参与构成的新的有效序列。 重复匹配与非重复匹配的本质区别在于在完成匹配后的状态跳转。\n从电路设计角度，其可分为状态机型与移位寄存器型两类：\n状态机型电路即是对序列检测问题进行行为级建模，在各二进制比特输入之后判断是否匹配，若匹配则进入下一状态，不匹配则根据输入数据与序列检测的类型具体判断进入的下一状态。 移位寄存器型电路的思路则相对简单，其基本原理是目标序列与缓存数据的对比：我们可以使用一个与目标序列等位宽的移位寄存器缓存输入的序列，当该缓存序列与目标序列一致时，则代表匹配成功。 这两类电路的RTL描述都较为简单，此处不作赘述。\n序列检测器的电路设计 本节简要讨论状态机型与移位寄存器型两类序列检测器的门级电路实现。因为在某些面试中，除了手撕代码外，可能还涉及对电路原理图的绘制。\n对于状态机型序列检测器，该电路是非常典型的Mealy型状态机2，对于位宽为$N$的序列，可以建模一个状态位宽为$M=\\lceil\\log_2(N)\\rceil$的状态机实现序列检测，之后便化归为最基本的基于状态转换图推导状态转换方程的问题： $$ (Q_{n+1}^1,~Q_{n+1}^2, ~\\cdots,~Q_{n+1}^M) = \\vec{f}(Q_{n}^1,~Q_{n}^2, ~\\cdots,~Q_{n}^M,~\\text{Input}) $$ 得到状态转换方程后，我们可以绘制对应的状态机电路，而对序列匹配输出match，只需要再加一级比较当前状态与序列匹配状态是否相等的组合逻辑即可。\n对于移位寄存器型序列检测器，对于位宽为$N$的序列，我们只需要将$N$个D触发器级联构成移位寄存器，并将其各位的输出引出实现与目标序列的比较即可。\n序列检测器的参数化设计 在讨论完序列检测器的分类与电路实现后，我们需要考查状态机型与移位寄存器型两类序列检测器对重复检测与非重复检测两类序列检测问题的适配性。在一些博客中1，会给出“状态机型序列检测器可以同时处理重复检测与非重复检测两类序列检测问题，但移位寄存器型序列检测器只能处理重复检测序列检测问题”的结论，这一结论实际上是错误的，本节将进行简要讨论。\n首先，状态机型序列检测器可以同时处理重复检测与非重复检测两类序列检测问题，这一结论是正确的，因为状态转换逻辑可以根据问题类型灵活变化。\n但是，对于移位寄存器型序列检测器，其不仅可以处理序列的重复检测问题（这是显然的），也可以处理序列的非重复检测问题。对于非重复检测，我们需要意识到移位寄存器中存储的序列本身就是电路的 “状态” ，因此，我们只需将序列匹配输出信号match反馈至移位寄存器，使移位寄存器在序列匹配时复位即可。\n移位寄存器的复位：我们需要思考一个问题，移位寄存器的复位具体指什么？我们可以将清零与复位完全等价吗？答案是否定的，假设我们需要检测的序列是4'b0011，高位先输入，而我们将移位寄存器清零后，移位寄存器的最低位便是1'b0，此时我们如果输入3'b011，最低位的复位值移位至最高位，移位寄存器的值变为4'b0011，移位寄存器也会错误地将该序列视为匹配序列。\n所以，为避免这一点，移位寄存器的复位值需要依据匹配的序列进行指定。具体而言，我们必须保证移位寄存器各位的复位值与目标序列最高位相反（默认高位先输入），这样可以保证在移位寄存器复位到移位寄存器复位值完全被输入序列覆盖这一段时间内，不会发生错误的序列匹配。\n所以，基于上述说明，并不存在“状态机型序列检测器比移位寄存器型序列检测器更灵活”的说法，相反，移位寄存器简洁的结构与原理，使其可以实现序列匹配电路的参数化设计，而这是状态机型电路难以实现的：\n对于非重复检测，对应的序列检测电路可实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module seq_detector #( parameter SEQ = 8\u0026#39;h5A, parameter SEQ_LEN = 8 ) ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); // shift register reg [SEQ_LEN-1:0] shift_reg; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else begin shift_reg \u0026lt;= {shift_reg[SEQ_LEN-2:0], data_in}; // bit shift end end // compare output always @(posedge clk or negedge rst_n) begin if (~rst_n) begin match \u0026lt;= 1\u0026#39;b0; end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin match \u0026lt;= 1\u0026#39;b1; end else begin match \u0026lt;= 1\u0026#39;b0; end end endmodule 对于重复检测，我们只需消除序列匹配输出信号的反馈路径即可，对应的序列检测电路可实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module seq_detector #( parameter SEQ = 8\u0026#39;h5A, parameter SEQ_LEN = 8 ) ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); // shift register reg [SEQ_LEN-1:0] shift_reg; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else begin shift_reg \u0026lt;= {shift_reg[SEQ_LEN-2:0], data_in}; // bit shift end end // compare output always @(posedge clk or negedge rst_n) begin if (~rst_n) begin match \u0026lt;= 1\u0026#39;b0; end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin match \u0026lt;= 1\u0026#39;b1; end else begin match \u0026lt;= 1\u0026#39;b0; end end endmodule 同时我们提供一个简单的Testbench，其检测序列模式为4'b1001，对应输入序列为13'b1001001001001：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 module test (); // clock generate reg clk; always #1 clk = ~clk; // module instantiate reg rst_n, data_in; wire match; seq_detector #( .SEQ (4\u0026#39;b1001 ), .SEQ_LEN (4 ) ) u_seq_detector ( .clk (clk ), .rst_n (rst_n ), .data_in (data_in ), .match (match ) ); // stimulus reg [12:0] serial_in; initial begin clk = 1\u0026#39;b0; rst_n = 1\u0026#39;b0; data_in = 1\u0026#39;b0; serial_in = 13\u0026#39;b1001001001001; #10; @(posedge clk); rst_n = 1\u0026#39;b1; data_in = serial_in[12]; for (integer i = 11; i \u0026gt;= 0; i = i - 1) begin @(posedge clk); data_in = serial_in[i]; end @(posedge clk); $stop; end // waveform initial begin $dumpfile(\u0026#34;wave.vcd\u0026#34;); $dumpvars(0, test); end endmodule 另外，在电路面积上，假设需检测的序列位宽为$N$，则状态机型电路的面积$\\propto \\log N$（假设电路面积主要由D触发器的个数决定），而移位寄存器型电路的面积$\\propto N$。同时，移位寄存器型电路具有相对短的关键路径，因此可以达到相当高的工作频率。\n序列检测器（两种设计方法和四种检测模式|verilog代码|Testbench|仿真结果）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n输出信号不仅取决于当前状态，还取决于输入信号的值。对应地，Moore型状态机的输出信号只取决于当前状态。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-06T12:00:00Z","image":"https://posvirus.github.io/p/dic-003/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-003/","title":"序列检测"},{"content":"task与function的区别 任务（task）与函数（function）两类语句在标准中的 第10章（Tasks and functions） 做了详细讨论，以下我们以原文为基础进行讨论说明：\n[10.1] The following rules distinguish tasks from functions:\nA function shall execute in one simulation time unit; a task can contain time-controlling statements. A function cannot enable a task; a task can enable other tasks and functions. A function shall have at least one input type argument and shall not have an output or inout type argument; a task can have zero or more arguments of any type. A function shall return a single value; a task shall not return a value. 上文主要给出了task与function的四点不同：\n首先，函数必须在一个仿真时间单位内执行完毕；而任务可以包含控制仿真时间的语句。这句话的意思是函数不能消耗仿真时间。换言之，函数的执行被认为是瞬时完成的，在调用它的那个仿真时间点上立即返回结果。因此，函数内部不允许出现任何会延迟仿真时间的语句。而任务可以包含任何时序控制语句，因此它可以跨越多个仿真时间单位执行1。 函数不能 使能（enable）任务，而任务可以使能其它任务与函数。注意，这里的使能可以理解为调用并执行，即某个任务可以在其内部调用其它函数或任务，并使其在仿真运行时被触发执行。至于为什么规定函数不能使能任务，我们可以结合第一条差异理解，因为函数是瞬时执行完成的，如果在其中引入可跨越多个仿真时间单位执行的任务，则会导致未定义的行为。 函数至少需要有一个input类型的参数，且不能有output或inout类型的参数。而任务可以有任意个任意类型的参数。 函数需要一个返回值，而任务不应存在返回值。 [10.1] The purpose of a function is to respond to an input value by returning a single value. A task can support multiple goals and can calculate multiple result values. However, only the output or inout type arguments pass result values back from the invocation of a task. A function is used as an operand in an expression; the value of that operand is the value returned by the function.\n上文归纳了task与function语句的目的，总体而言，函数主要是为了就某一输入值返回单一的输出值，其通常作为表达式内的操作数。而任务则可以支持更灵活的功能，输出更多的返回值，任务的返回值通常通过output与inout类型的参数进行传递。\n有关task与function的其它注意点 本节主要结合标准说明有关task与function的一些其他知识点：\n[10.2.1] Tasks without the optional keyword automatic are static tasks, with all declared items being statically allocated. These items shall be shared across all uses of the task executing concurrently. Task with the optional keyword automatic are automatic tasks. All items declared inside automatic tasks are allocated dynamically for each invocation. Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through use of their hierarchical name.\n[10.4.1] The keyword automatic declares an automatic function that is reentrant, with all the function declarations allocated dynamically for each concurrent function call. Automatic function items cannot be accessed by hierarchical references. Automatic functions can be invoked through the use of their hierarchical name\n第一是函数与任务的调用，在该方面标准对函数与任务的规定是类似的，因此我们仅以任务为例进行说明：\n标准规定，如果定义的任务没有被automatic关键字修饰，则该任务为 静态任务（static task） ，这类任务内部的所有变量都是静态分配的，这意味着这些变量在仿真开始时就被分配好内存，并且在整个仿真过程中只有一份副本。此时，如果果多个块内同时调用同一个静态 task（例如在两个并行的 initial 块中），那么它们共享同一组内部变量。这可能会导致数据竞争：当一个调用修改了变量，另一个调用会看到这个修改，可能引发 不可预测的行为（UB） 。\n因此，标准引入了automatic关键字，如果我们使用该关键字修饰一个任务：\n1 2 3 task automatic my_auto_task; /* do something */ endtask 该任务会被声明为自动任务（automatic task） ，此时，对该任务的每次调用，都会动态分配一份新的内存空间，因此，多个并发调用之间互不干扰，各自拥有独立的变量副本，避免了数据竞争。\n但是，对于自动任务而言：\n你不能通过top.inst.my_auto_task.var之类的层次化引用语句访问任务内部的变量，因为自动任务的变量是动态分配的，可能同时存在多个实例，仿真器无法确定你要访问哪一个副本。 你可以通过top.inst.my_auto_task(...)指令的层次化调用语句来调用任务本身，只是不能读写它的内部变量。 第二，函数与任务都是可综合的，但需要指出，函数和任务综合出的电路都是组合逻辑，换言之，如果需要对函数与任务进行综合，你不应在其中引入任何时序控制语句。\n注意，有关函数与任务是否可综合，其实在标准中并没有进行说明。这是因为 可综合性（Synthesizability） 是一个由综合工具厂商定义和实现的概念，而不是语言标准本身强制规定的。一个 Verilog语句是否可综合，取决于综合工具能否将其转换为实际的硬件电路。\n对于第一条差异，多篇博客将其翻译为“函数只能与主模块共用同一个仿真时间单位，而任务可以定义自己的仿真时间单位”，这是不准确的。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-06T00:00:00Z","image":"https://posvirus.github.io/p/dic-002/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-002/","title":"task与function的区别"},{"content":"写在前面 这一系列博客主要用于记录我在 数字集成电路（Digital Integrated Circuit, DIC） 中遇到或偶然想到的一些问题，以及日常在各个平台看到的面试八股，以期为明年的秋招做一些准备。集成电路的知识较为繁杂，想要构建清晰的分类体系会消耗太多不必要的精力，所以这里统一以[DIC-XXX]为博客编号。\nChen Wenyao\nupdated at November 3rd, 2025\nVerilog中的有符号数 前几天，我在编写一个ALU模块，它需要同时支持有符号数与无符号数大小比较的功能，但我对这部分内容的了解恰巧比较模糊，所以想借本篇博客系统地探讨一下Verilog语法中与有符号数有关的话题。\n在写这篇博客之前，我试图在网上搜索相关的内容，但只找到了两类结果，一类是AI生成的💩，另一类倒是给出了一些简单结论，但是这些结论基本是作者在诸如Vivado之类的EDA上用几个简单的测试归纳总结得到的，所以每个作者得到的结论不尽相同，弄得我有些莫名其妙，不知道该信谁。\n这里我想提一句，我觉得上文提到的使用仿真器测试归纳Verilog语法特性是一种典型的错误行为（可以称之为DIC中的Spice Monkey），因为仿真器所反应的Verilog语法特性本身是遵循Verilog标准的，而这种行为其实是试图通过仿真器中的简单测试去 “逆向” Verilog标准中所描述的特性，这样最终得到的结论无论是在全面性还是准确性上肯定都存在一定欠缺。\n当然，这里可能有人会问，如果EDA本身对Verilog语法特性的支持与Verilog标准不一致怎么办呢，这就是EDA厂商需要考虑的事情了。作为IC设计人员，我觉得应该达成的一个共识是：我们应当面向标准设计，而不是面向EDA设计。\n所以，最好的方法是直接阅读Verilog标准，从标准中寻找答案。这里，我选择Verilog-2005标准（IEEE 1364-2005），它可以在这里找到。\n由于我主要关注的是在算数逻辑表达式中有符号数与无符号数的特性，因此以下我将主要选取 标准第5章（Expressions） 的相关内容，进行翻译以及归纳：\n表达式中的整型数 [5.1.3] A negative value for an integer with no base specifier shall be interpreted differently from an integer with a base specifier. An integer with no base specifier shall be interpreted as a signed value in twos-complement form. An integer with an unsigned base specifier shall be interpreted as an unsigned value.\n当整型数（integer）出现在表达式中：\n如果其没有基数标识符（base specifier, 如'd），则被视为有符号数处理； 如果其有基数标识符，但没有指定为有符号数（如'sd代表指定该数为有符号数），则被视为无符号数处理； 如果其有基数标识符，也被指定为有符号数，则被视为有符号数处理。 标准中给出了一些例子，用于辅助说明：\n1 2 3 4 5 6 7 integer IntA; IntA = -12 / 3; // The result is -4. IntA = -\u0026#39;d 12 / 3; // The result is 1431655761. IntA = -\u0026#39;sd 12 / 3; // The result is -4. IntA = -4\u0026#39;sd 12 / 3; // -4\u0026#39;sd12 is the negative of the 4-bit // quantity 1100, which is -4. -(-4) = 4. // The result is 1. 注意区分整型数与整型数变量，前者是一个常量，后者是使用integer作为类型声明的变量，这一节说明的其实是表达式中的整型数（非变量）的符号处理规则，比如-'d 12为无符号数，-'sd 12为有符号数等。\n算数表达式中的变量 [5.1.6] A value assigned to a reg variable or a net shall be treated as an unsigned value unless the reg variable or net has been explicitly declared to be signed. A value assigned to an integer, real or realtime variable shall be treated as signed. A value assigned to a time variable shall be treated as unsigned. Signed values, except for those assigned to real and realtime variables, shall use a twos-complement representation. Values assigned to real and realtime variables shall use a floating-point representation. Conversions between signed and unsigned values shall keep the same bit representation; only the interpretation changes.\n这里主要给出了算数表达式（进行算数运算的表达式）中一些变量类型（如wire, reg等）的默认符号类型，其可以归纳为下表：\nData Type Interpretation [net] Unsigned signed [net] Signed, 2\u0026rsquo;s complement reg Unsigned signed reg Signed, 2\u0026rsquo;s complement integer Signed, 2\u0026rsquo;s complement time Unsigned real, realtime Signed, floating point 我们同样可以结合例子进行辅助说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 integer intA; reg [15:0] regA; reg signed [15:0] regS; intA = -4\u0026#39;d12; regA = intA / 3; // expression result is -4, // intA is an integer data type, regA is 65532 regA = -4\u0026#39;d12; intA = regA / 3; // regA is 65524 // expression result is 21841, // regA is a reg data type intA = -4\u0026#39;d12 / 3; // expression result is 1431655761. // -4\u0026#39;d12 is effectively a 32-bit reg data type regA = -12 / 3; // expression result is -4, -12 is effectively // an integer data type. regA is 65532 regS = -12 / 3; // expression result is -4. regS is a signed reg regS = -4\u0026#39;sd12 / 3; // expression result is 1. -4\u0026#39;sd12 is actually 4. // The rules for integer division yield 4/3==1. 这里需要进行一些补充说明，以第一个例子为例，首先在intA = -4'd12;中，-4'd12为一个整型数，不涉及表达式运算，因此将其直接赋值给intA后，intA将其推断为有符号数-12。而在regA = intA / 3;中，intA为有符号数-12，因此其除以3的结果是-4（这里3也是一个整型数，在表达式中参与运算，没有基数标识符，被推断为有符号数），而赋值给regA后，由于regA没有被声明为signed reg，因此-4被推断为无符号数，亦即16'hfffb=65532。\n再看最后一个例子，-4'sd12也是一个整型数，且参与表达式运算，由于其存在基数标识符，且被指定为有符号数，因此在参与表达式运算时被推断为有符号数4（有符号数-12截位得到），进而表达式的值为1，而由于regS被声明为signed reg，因此1被推断为有符号数，二进制表示为16'h0001。\n比较运算符 [5.1.7] When one or both operands of a relational expression are unsigned, the expression shall be interpreted as a comparison between unsigned values. If the operands are of unequal bit lengths, the smaller operand shall be zero-extended to the size of the larger operand.\nWhen both operands are signed, the expression shall be interpreted as a comparison between signed values. If the operands are of unequal bit lengths, the smaller operand shall be sign-extended to the size of the larger operand.\nIf either operand is a real operand, then the other operand shall be converted to an equivalent real value and the expression shall be interpreted as a comparison between real values.\n这里给出在进行比较运算（包括大于/小于/等于/不等于等运算）时，运算符两侧的运算数的推断规则：\n只要比较运算符两侧的操作数有一个为无符号数，则比较运算被推断为无符号数间的比较，如果操作数位宽不匹配，则位宽较小者需要通过0位扩展使其与位宽较大者匹配。 只有比较运算符两侧的操作数均为有符号数，比较运算才被推断为有符号数间的比较，如果操作数位宽不匹配，则位宽较小者需要通过符号位扩展使其与位宽较大者匹配。 只要比较运算符两侧的操作数有一个为实数型（real），则比较运算被推断为实数间的比较，其余非实数操作数被转换为等价的实数。 移位运算符 [5.1.12] The logical right shift shall fill the vacated bit positions with zeroes. The arithmetic right shift shall fill the vacated bit positions with zeroes if the result type is unsigned. It shall fill the vacated bit positions with the value of the most significant (i.e., sign) bit of the left operand if the result type is signed. If the right operand has an x or z value, then the result shall be unknown. The right operand is always treated as an unsigned number and has no effect on the signedness of the result.\n这里给出在进行移位运算时，运算结果的推断规则：\n运算符的右操作数始终被推断为无符号数，且对运算结果无影响。 当使用逻辑右移（\u0026gt;\u0026gt;）时，运算结果的空位需要进行0位扩展。 当使用算数右移（\u0026gt;\u0026gt;\u0026gt;）时，如结果类型是有符号数，则空位需要进行符号位扩展；如结果类型是无符号数，则空位需要进行0位扩展。 表达式的符号推断规则 [5.5.1] The following are the rules for determining the resulting type of an expression:\nExpression type depends only on the operands. It does not depend on the left-hand side (if any). Decimal numbers are signed. Based_numbers are unsigned, except where the s notation is used in the base specifier (as in\u0026quot;4'sd12\u0026quot;). Bit-select results are unsigned, regardless of the operands. Part-select results are unsigned, regardless of the operands even if the part-select specifies the entire vector. Concatenate results are unsigned, regardless of the operands. Comparison results (1, 0) are unsigned, regardless of the operands. Reals converted to integers by type coercion are signed The sign and size of any self-determined operand are determined by the operand itself and independent of the remainder of the expression. For nonself-determined operands, the following rules apply: If any operand is real, the result is real. If any operand is unsigned, the result is unsigned, regardless of the operator. If all operands are signed, the result will be signed, regardless of operator, except when specified otherwise. 在前几节中，我们分别讨论了整型数常量，变量与特定运算符运算时的符号推断规则。综合来看，上述规则本质上约束的对象是操作数（比如比较运算符中，我们实际上是在根据比较运算符两侧的操作数类型推断在进行比较时，操作数本身应该视为有符号数还是无符号数），而在本节中，我们主要聚焦于对于一个一般的表达式而言，其运算结果的符号类型推断。标准中给出了如下的规则：\n表达式的符号类型只与操作数有关，与 表达式赋值的对象（LHS） 无关。 十进制数被推断为有符号数。 含基数标识符的操作数被推断为无符号数，除非使用s指定其为有符号数（如4'sd12）。 比特选择后的结果被推断为无符号数（如a[1]）。 部分选择后的结果被推断为无符号数（如b[4:2]）。 拼接运算后的结果被推断为无符号数。 比较运算的结果被推断为无符号数。 实数强制转换为整型数的结果被推断为有符号数。 对于自决操作数（self-determined operand），其符号类型只与操作数本身有关，与表达式其余部分独立。 对于非自决操作数，其符号推断遵循如下规则： 如果操作数中有一者为实数，则运算结果被推断为实数。 如果操作数中有一者为无符号数，则运算结果被推断为无符号数。 如果所有操作数均为有符号数，则运算结果被推断为有符号数。 对于上述规则，我们需要说明以下几点：\n首先，需要注意操作数与表达式是一个相对的概念，一个表达式可以作为一个更为复杂表达式中的操作数，比如(1 + 2) * (3 % 4)，我们也可以将(1 + 2)与(3 % 4)视为乘法运算的两个操作数。\n其次，第9条规则引入了自决操作数的概念，将其定义为符号类型只与操作数本身有关的操作数，这里其实只是对于这类操作数进行了形式上的定义，并没有引入新的推断规则。但是第10条规则引入了对非自决操作数的推断规则，因此有必要明确自决操作数究竟指什么：根据定义，自决操作数其实就是指本身就可以判定符号的操作数，比如之前的整型数-'sd12，或是第2-8条规则中规定的运算结果（比特选择，拼接运算，比较运算等）。这其实就意味着Verilog中的这些操作数的符号类型是明确的，不会因为表达式上下文而改变。\n但是，诸如reg regA，wire wireA这类变量，它们其实只有默认的符号推断，而它们在表达式中实际的符号推断是可变的，需要结合表达式本身确定，这也就是非自决操作数的概念，第10条规则规定了对非自决操作数的符号推断。\n但是，我们仔细阅读第10条规则，会发现一个问题，这里其实说明的是如何推断运算结果的符号类型，但是对于非自决操作数本身，这一条规则并没有说明其在参与运算时应如何进行符号推断，这一点其实在标准的5.5.2节中才提到：\n[5.5.2] The following are the steps for evaluating an expression:\nDetermine the expression size based upon the standard rules of expression size determination. Determine the sign of the expression using the rules outlined in 5.5.1. Propagate the type and size of the expression (or self-determined subexpression) back down to the context-determined operands of the expression. In general, any context-determined operand of an operator shall be the same type and size as the result of the operator. However, there are two exceptions: If the result type of the operator is real and if it has a context-determined operand that is not real, that operand shall be treated as if it were self-determined and then converted to real just before the operator is applied. The relational and equality operators have operands that are neither fully self-determined nor fully context-determined. The operands shall affect each other as if they were context-determined operands with a result type and size (maximum of the two operand sizes) determined from them. However, the actual result type shall always be 1 bit unsigned. The type and size of the operand shall be independent of the rest of the expression and vice versa. When propagation reaches a simple operand as defined in 5.2 (a primary as defined in A.8.4), then that operand shall be converted to the propagated type and size. If the operand must be extended, then it shall be sign-extended only if the propagated type is signed. 在这一部分其实说明了，对于非自决操作数，也就是标准中提及的上下文决定操作数（context-determined operand）其符号是通过表达式结果的符号类型向下传播确定的。但这里同样有两个例外：\n如果表达式结果是实数，则对于非实数的上下文决定操作数，需要先假定其为自决操作数，据此判断其取值，再将该值转换为实数。举一个例子，假设我们声明了一个变量reg [3:0] a = 4'b1111；，则对表达式a * 1.5而言，由于有实数1.5的存在，表达式结果被推断为实数，且a是一个非实数的非自决操作数。因此，我们需要先假定a为自决操作数，此时就直接使用a的默认符号推断，即无符号数，进而a的值就是15，再将其转换为实数15.0参与运算。 对于比较运算符，它的两个操作数不是严格的自决操作数或非自决操作数，因为两个操作数的符号推断是相互确定的，具体规则已在上文提及，此处不再赘述。 综上：表达式结果的符号本身是由所有操作数共同决定的规则推导出来的，它是一个自底向上 + 自顶向下结合的过程：\n首先，根据自决操作数符号类型，确定表达式结果的符号类型。 然后，再将表达式结果的符号类型应用到所有非自决操作数上，并进行运算。 ","date":"2025-11-04T00:00:00Z","image":"https://posvirus.github.io/p/dic-001/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-001/","title":"Verilog中的有符号数"},{"content":"单周期CPU架构简介 本节中，我们主要介绍在C阶段实现的支持RV32E ISA的单周期CPU，该CPU对应的架构图如上图所示，整体上分为取值（Instruction Fetch）、 译码（Instruction Decode） 与 执行（Instruction Excecution） 三个阶段。\n该CPU的工作原理与一些经典教材中的CPU完全类似，此处我们主要介绍几个设计中的注意点：\n第一是CPU的访存行为，该CPU通过DPI-C机制实现访存，在一条指令的完整执行流程中，最多存在两次访存行为，第一次是取指，第二次是访存指令的访存行为。此处我们通过NPC中提供的统一接口paddr_read()与paddr_write()实现。同时，由于RV32E架构通过内存映射IO实现CPU与外设的交互，因此CPU对外设的访问被统一抽象为访存指令。\n第二是CPU的异常响应机制实现，此处主要需要实现的是CPU的若干个CSR，以及对应用于实现异常响应机制的若干指令。由于CSR的行为与异常响应机制指令的相关性很强，故此处我们统一进行说明，总体上，与异常响应机制相关的指令主要可分为两类：\n一类是mret, ecall这类直接实现异常响应的指令，这类指令涉及对多个CSR的配置以及PC的跳转。 一类是csrrw, csrrs这类单纯对CSR进行操作的CSR指令，这类指令涉及对某个CSR的原子性读写（这里的 “原子性” 指对CSR的读-写（Read-Write）操作是原子的，即整个操作在单条指令内完成，不会被其他操作打断），这通常包括对CSR的读取，对CSR的写回与对通用寄存器的写回三个子操作。 综合上述说明，我们其实可以发现，对CSR实现本身而言，我们只需要将其实现为可读/写的寄存器堆即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module ysyx_25070184_Csr( input wire clk, input wire rst, input wire [`ysyx_25070184_CSR_ADDR_WIDTH-1:0] addr, // atomically operates one CSR input wire [`ysyx_25070184_CSR_OPTYPE-1:0] inst_type, input wire [`ysyx_25070184_ADDR_WIDTH-1:0] cur_pc, input wire [`ysyx_25070184_DATA_WIDTH-1:0] ecode, input wire [`ysyx_25070184_DATA_WIDTH-1:0] wdata, output reg [`ysyx_25070184_DATA_WIDTH-1:0] rdata ); // instantiate CSRs one by one reg [`ysyx_25070184_DATA_WIDTH-1:0] mstatus; // machine status registers reg [`ysyx_25070184_DATA_WIDTH-1:0] mcause; // machine cause register reg [`ysyx_25070184_DATA_WIDTH-1:0] mtvec; // machine trap-vector base-address register reg [`ysyx_25070184_DATA_WIDTH-1:0] mepc; // machine exception program counter endmodule 在该模块中，CSR的写入由指令类型inst_type与CSR指令中的地址字段addr共同确定，同时cur_pc（当前的PC值）, ecode（异常号）, wdata（CSR指令的写回值）用于传递写入CSR的值（因为在ecall指令中，需要同时写入多个CSR）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // CSRs write always @(posedge clk) begin if (rst) begin mstatus \u0026lt;= `ysyx_25070184_MSTATUS_RSTVAL; end else begin case (inst_type) `ysyx_25070184_CSR_ECALL: begin mstatus[`ysyx_25070184_MPIE_LOCATE] \u0026lt;= mstatus[`ysyx_25070184_MIE_LOCATE]; // MPIE = MIE mstatus[`ysyx_25070184_MIE_LOCATE] \u0026lt;= 1\u0026#39;b0; // reset MIE mepc \u0026lt;= cur_pc; // store current pc mcause \u0026lt;= ecode; // store exception code end `ysyx_25070184_CSR_CSRRS, `ysyx_25070184_CSR_CSRRW: begin case (addr) `ysyx_25070184_MSTATUS_ADDR: begin mstatus \u0026lt;= wdata; end `ysyx_25070184_MCAUSE_ADDR: begin mcause \u0026lt;= wdata; end `ysyx_25070184_MTVEC_ADDR: begin mtvec \u0026lt;= wdata; end `ysyx_25070184_MEPC_ADDR: begin mepc \u0026lt;= wdata; end default: begin // do nothing end endcase end `ysyx_25070184_CSR_MRET: begin mstatus[`ysyx_25070184_MIE_LOCATE] \u0026lt;= mstatus[`ysyx_25070184_MPIE_LOCATE]; // MIE = MPIE end default: begin // do nothing end endcase end end CSR的读取同样由指令类型inst_type与CSR指令中的地址字段addr共同确定，对于CSR指令，读出的CSR在执行阶段被作为操作数；对于mret与ecall指令，读出的CSR在执行阶段被作为下一条指令的PC值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // CSRs read always @(*) begin if (inst_type == `ysyx_25070184_CSR_ECALL) begin rdata = mtvec; end else if (inst_type == `ysyx_25070184_CSR_MRET) begin rdata = mepc; end else begin case (addr) `ysyx_25070184_MSTATUS_ADDR: begin rdata = mstatus; end `ysyx_25070184_MCAUSE_ADDR: begin rdata = mcause; end `ysyx_25070184_MTVEC_ADDR: begin rdata = mtvec; end `ysyx_25070184_MEPC_ADDR: begin rdata = mepc; end default: begin rdata = {`ysyx_25070184_DATA_WIDTH{1\u0026#39;b0}}; end endcase end end ALU的性能评估 单周期CPU中所使用的ALU架构如上图所示，其实现了加法器的复用，通过单个加法器实现了加法、减法、小于（有符号）、 小于（无符号） 与等于共5种运算。此处，我们主要探讨一下ALU性能评估中的一个注意点，而不再赘述ALU的具体实现原理。\n由于ALU通过纯组合逻辑实现，因此在使用Yosys-STA进行性能评估时，我们无法获取其时序方面的相关性能指标（如最大工作频率）。而对于纯组合逻辑模块而言，我们主要关注端到端最大组合逻辑延时这一性能指标，它可以评估当我们将该模块集成至存在时序逻辑的系统中时，该模块所能承载的最大工作频率。\n而当我们单独对ALU进行性能评估时，我们可以通过寄存器将ALU的输入/输出打一拍，将其转换为含时序逻辑的模块，从而实现对该性能指标的量化。\n","date":"2025-10-31T00:00:00Z","image":"https://posvirus.github.io/p/rv32e-npc/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rv32e-npc/","title":"RV32E单周期CPU的实现说明"},{"content":"RT-Thread上下文创建 首先，我们考虑RT-Thread中的上下文创建函数rt_hw_stack_init()的实现，观察其参数列表：\n1 rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) 该函数接收一个栈底指针stack_addr用于构建上下文，同时保证该上下文入口为tentry，参数为parameter，并返回这个上下文结构的指针。此外，若上下文对应的内核线程从tentry返回，则调用texit。\n这里首先需要解释，为什么在AM中，我们不允许内核线程从tentry返回：这主要是因为，入口为tentry的上下文是人工构造的，而在AM中构造上下文的功能函数kcontext()中，我们并没有为该入口构造相应的返回地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Context *kcontext(Area kstack, void (*entry)(void *), void *arg) { // instantiate a context Context *ret = (Context *)(kstack.end - sizeof(Context)); // create entry ret-\u0026gt;mepc = (uintptr_t)entry; // reset mstatus ret-\u0026gt;mstatus = (uintptr_t)0x1800; // function argument ret-\u0026gt;gpr[10] = (uintptr_t)arg; // other GPR settings ret-\u0026gt;gpr[0] = (uintptr_t)0; // $0 register ret-\u0026gt;gpr[2] = (uintptr_t)ret; // $sp register // return context pointer return ret; } 所以线程一旦从tentry返回，将会跳转至非法的地址，从而导致程序非法运行。\n回到rt_hw_stack_init()函数，首先，我们需要对输入的stack_addr进行对齐：\n1 2 3 4 /* align the incoming stack pointer */ rt_uint8_t *stk; stk = stack_addr + sizeof(uintptr_t); stk = (rt_uint8_t *)RT_ALIGN_DOWN((uintptr_t)stk, sizeof(uintptr_t)); 此处我们以sizeof(uintptr_t)为最小单位，对该地址进行向下对齐（因为栈底在内存分布上位于高位地址），而RT_ALIGN_DOWN是RT-Thread内部定义的宏。\n随后，由于对kcontext()函数而言，其接收的用于构建上下文的参数只有栈空间分布kstack，上下文入口entry以及向入口传递的参数arg，但是RT-Thread中的还存在一个texit参数，这就导致，我们需要构造一个包裹函数，这里称为tentry_wrapper()：\n1 2 3 4 5 6 7 static void tentry_wrapper(void *arg) { struct wrapper_args *stk_arg = (struct wrapper_args *)arg; // call tentry(parameter) first ((void (*)(void *))stk_arg-\u0026gt;tentry)(stk_arg-\u0026gt;parameter); // if return, call texit() ((void (*)())stk_arg-\u0026gt;texit)(); } 该包裹函数的作用是，接收一个void *类型的参数arg，该参数在函数内被强制类型转换为一个结构体类型wrapper_args，该类型包括三个字段：\n1 2 3 4 5 struct wrapper_args { void *tentry; void *texit; void *parameter; }; 其中tentry即为上下文的入口，parameter即为上下文入口tentry对应的参数，texit即为线程如果在tentry返回的话需要调用的函数，进而我们可以在tentry_wrapper()函数中先对tentry进行调用，随后对texit进行调用，这样一旦tentry返回，随后会调用texit进行处理。\n有了tentry_wrapper()函数，我们在创建上下文时实际上就可以通过如下形式调用kcontext()函数：\n1 kcontext([kstack], tentry_wrapper, [arg]); 以下，我们需要考虑的是kcontext()函数的另外两个参数应该如何设定，首先考虑arg参数，对于tentry_wrapper()函数，我们需要传递一个指向一个wrapper_args结构体的指针，这里就涉及到该结构体如何创建及存储的问题，不妨先在rt_hw_stack_init()函数中先初始化一个wrapper_args结构体：\n1 2 3 4 5 /* allocate function arguments */ struct wrapper_args tmp_args; tmp_args.tentry = tentry; tmp_args.texit = texit; tmp_args.parameter = parameter; 随后，我们需要确定该结构体存储的位置，首先，这个结构体肯定不能以临时变量进行存储，因为rt_hw_stack_init()函数实际上起到一个初始化上下文的功能，所以该函数中的临时变量是无法在程序的整个生命周期中都存在的。因此，一个合适的方法，就是将这个结构体复制到该上下文所在的栈上，此处可以直接先从栈底开始分配空间：\n1 2 3 4 5 6 /* re-allocate the stack pointer */ size_t arg_size = sizeof(struct wrapper_args); stk = stk - arg_size; /* Copy wrapper arguments to stack */ memcpy(stk, \u0026amp;tmp_args, arg_size); 此时，我们将stk下移sizeof(struct wrapper_args)，并调用memcpy()函数将结构体复制到这一段空间中，此时stk一方面指向的就是栈上存储的结构体，另一方面stk也可以作为kstack参数对应栈空间的栈底，以使kcontext()函数可以以stk为栈底构建上下文，于是rt_hw_stack_init()函数的剩余部分可以作如下实现：\n1 2 3 4 5 /* create stack area */ Area stack_area = { .end = stk }; /* return context pointer */ return (rt_uint8_t *)kcontext(stack_area, tentry_wrapper, (void *)stk); RT-Thread的上下文切换 为实现RT-Thread的上下文切换，我们需要实现3个函数：\n1 void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to); 首先，是rt_hw_context_switch()函数，其包含from与to两个参数，其都是指向上下文指针变量的指针（二级指针）。 它用于切换到to指向的上下文指针变量所指向的上下文，并将当前上下文的指针写入from指向的上下文指针变量中。\n1 void rt_hw_context_switch_to(rt_ubase_t to); 其次，是rt_hw_context_switch_to()函数，它只包含to一个参数，仅实现切换到to指向的上下文指针变量所指向的上下文这一功能，那么，该函数显然可以复用rt_hw_context_switch()实现：\n1 2 3 4 void rt_hw_context_switch_to(rt_ubase_t to) { // reuse function rt_hw_context_switch((rt_ubase_t)NULL, to); } 最后，我们需要实现RT-Thread对应的事件处理回调函数ev_handler()：\n1 static Context* ev_handler(Event e, Context *c); 通过上述分析，我们其实仅需实现rt_hw_context_switch()函数与ev_handler()函数即可，首先考查前者的实现：按PA讲义的说法，为了进行上下文切换, 我们可以通过yield()触发一次自陷, 在事件处理回调函数ev_handler()中识别出代处理事件后, 再处理to和from，为此，我们需要将to与from参数传递至ev_handler()。\n由于无法通过函数参数传递的方式传递to与from，同时也不适合直接通过全局变量的方式传递（多线程时存在风险），因此，我们考虑使用进程控制块（PCB, process control block）存储to与from，因为这一数据结构为各线程所独有，不会存在多线程的冲突。在RT-Thread中，PCB对应的结构体名称为rt_thread_t，可通过rt_thread_self()获取当前线程对应的PCB。\n1 rt_thread_t current = rt_thread_self(); 同时，rt_thread_t结构体中存在user_data字段，用于存储当前线程的私有用户数据，我们可以将to与from存储于该字段中：\n1 2 3 4 5 6 7 8 /* create private user data copy */ rt_ubase_t temp_user_data = current-\u0026gt;user_data; /* passing arguments */ rt_ubase_t param[2]; param[0] = to; param[1] = from; current-\u0026gt;user_data = (rt_ubase_t)param; 此处，我们还需要另外定义一个临时变量temp_user_data，作为当前线程原始user_data字段的备份。随后，我们便可调用yield()函数实现上下文切换，当切换回当前上下文时（即yield()返回时），再将临时变量内的user_data字段恢复：\n1 2 3 4 yield(); /* recover user data */ current-\u0026gt;user_data = temp_user_data; 随后，考虑事件处理回调函数ev_handler()的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static Context* ev_handler(Event e, Context *c) { rt_thread_t current; rt_ubase_t* param; switch (e.event) { case EVENT_YIELD: current = rt_thread_self(); param = (rt_ubase_t*)current-\u0026gt;user_data; rt_ubase_t to = param[0]; rt_ubase_t from = param[1]; if (from) *((Context **)from) = c; c = *(Context **)to; break; case EVENT_IRQ_TIMER: break; default: // printf(\u0026#34;Unhandled event ID = %d\\n\u0026#34;, e.event); } return c; } 阅读AM CTE的实现可知，事件处理回调函数是在上下文真正发生切换之前被调用的，因此，我们仍可通过rt_thread_self()函数获取当前的PCB，并提取from与to字段。\n","date":"2025-10-21T00:00:00Z","image":"https://posvirus.github.io/p/rt-thread/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rt-thread/","title":"RT-Thread的上下文"},{"content":"特权级与异常响应机制的关系 在PA3中，讲义同时引入了特权级与异常响应机制这两个概念，以下将简单阐述这两者之间的关系：\n以RISC-V架构为例：首先，RISC-V 定义了多个特权级（如Machine模式、Supervisor模式、User模式），权限逐级降低。用户程序通常在最低特权级（U模式）运行，无法直接访问关键系统资源，而当用户程序试图执行非法操作（如访问受保护内存、执行特权指令）时，会触发一个异常或中断。而此时，异常作为进入高特权级的入口，CPU会自动从当前特权级陷入（Trap）到一个预定义的更高特权级（通常是S模式或M模式）。\n其次，在更高特权级下，操作系统拥有足够的权限来分析异常原因、采取相应措施（如终止非法程序、调度其他任务等）。处理完毕后，操作系统通过特殊的返回指令（如 sret 或 mret）将控制权交还给用户程序，并返回到原来的特权级和程序断点继续执行。\nNEMU中CSR的实现 CSR本质仍为寄存器，因此在实现时与通用寄存器（GPR）类似，首先，我们可在CPU_state结构体中补充定义CSR：\n1 2 3 4 5 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; word_t csr[4]; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); 由于我们目前仅使用了mstatus，mepc，mcause与mtvec这4个CSR，因此仅例化4个CSR实例即可。\n同时，我们仿照GPR的实现，定义针对CSR的访问函数与宏：\n1 2 3 4 5 6 7 8 9 10 11 /* CSRs name mapping */ enum { MSTATUS = 0, MEPC, MCAUSE, MTVEC, }; static inline int check_csr_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; 4)); return idx; } #define csr(idx) (cpu.csr[check_csr_idx(idx)]) 同时，由于在RISC-V架构中，对各个CSR有唯一的编址，因此我们还需实现CSR编址与数组索引的映射：\n1 2 3 4 5 6 7 8 9 10 11 static inline int csr_addr_map(int addr) { switch (addr) { case 0x300: return MSTATUS; // Machine Status Registers case 0x305: return MTVEC; // Machine Trap-Vector Base-Address Register case 0x341: return MEPC; // Machine Exception Program Counter case 0x342: return MCAUSE; // Machine Cause Register default: printf(\u0026#34;Illegal CSR\u0026#39;s index: %03x!\\n\u0026#34;, addr); return -1; } } #define csr_map(addr) (csr(csr_addr_map(addr))) 此时，我们可以使用：\n1 csr_map(addr) 访问编址为addr的CSR，也可以使用：\n1 csr(NAME) 直接访问名称为NAME的CSR，如csr(MSTATUS)访问的即为mstatus。\n利用上述实现，我们可以很容易地在NEMU中实现与异常响应以及CSR相关的指令，包括ecall，mret，csrrw，csrrs。同时，在实现指令的过程中，可能涉及对CSR的位操作，因此，我们补充定义了如下2个宏：\n1 2 #define BITRST(x, bit) (x \u0026amp; ~(1u \u0026lt;\u0026lt; bit)) #define BITTO(x, src, tgt) (BITRST(x, tgt) | (((x \u0026gt;\u0026gt; src) \u0026amp; 1u) \u0026lt;\u0026lt; tgt)) 其中，BITRST(x, y)可以将x二进制表示中的第y位置零，BITTO(x, s, t)可以将x二进制表示中的第s位赋值给第t位。\nyield test的执行流程 首先，我们给出yield test的完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;amtest.h\u0026gt; Context *simple_trap(Event ev, Context *ctx) { switch(ev.event) { case EVENT_IRQ_TIMER: putch(\u0026#39;t\u0026#39;); break; case EVENT_IRQ_IODEV: putch(\u0026#39;d\u0026#39;); break; case EVENT_YIELD: putch(\u0026#39;y\u0026#39;); break; default: panic(\u0026#34;Unhandled event\u0026#34;); break; } return ctx; } void hello_intr() { printf(\u0026#34;Hello, AM World @ \u0026#34; __ISA__ \u0026#34;\\n\u0026#34;); printf(\u0026#34; t = timer, d = device, y = yield\\n\u0026#34;); io_read(AM_INPUT_CONFIG); iset(1); while (1) { for (volatile int i = 0; i \u0026lt; 1000000; i++) ; yield(); } } 当主函数调用hello_intr()函数并运行至yield()函数时，触发自陷操作，将发生如下行为：\n首先，yield()函数被执行，其行为如下：\n1 2 3 4 5 6 7 void yield() { #ifdef __riscv_e asm volatile(\u0026#34;li a5, -1; ecall\u0026#34;); #else asm volatile(\u0026#34;li a7, -1; ecall\u0026#34;); #endif } 可知，该函数会执行ecall指令。而ecall指令会配置mstatus，依据当前系统所处的模式将异常号保存在mcause中，保存当前的PC至mepc中（此处默认系统在M模式中，异常号为11），并跳转至mtvec中存储的地址，开始异常响应流程，这里ecall指令的逻辑是在NEMU中实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 word_t isa_raise_intr(word_t NO, vaddr_t epc) { /* TODO: Trigger an interrupt/exception with \u0026#39;NO\u0026#39;. * Then return the address of the interrupt/exception vector. */ /* TODO: correctly set mstatus register */ csr(MSTATUS) = BITTO(csr(MSTATUS), 3, 7); // MPIE = MIE csr(MSTATUS) = BITRST(csr(MSTATUS), 3); // MIE = 0 csr(MEPC) = epc; csr(MCAUSE) = NO; return csr(MTVEC); } 1 INSTPAT(\u0026#34;0000000 00000 00000 000 00000 11100 11\u0026#34;, ecall , N, NEMUERROR(s-\u0026gt;pc, s-\u0026gt;dnpc, 11)); 1 2 3 #define NEMUERROR(thispc, nextpc, code) do { \\ nextpc = isa_raise_intr(code, thispc); \\ } while (0) 为什么yield()函数中会有li a5, -1这一条指令：因为对于RISC-V架构而言，ecall指令本身不带参数，但是不同类型的异常都需要通过同样的ecall实现，为了方便操作系统区分异常类型，我们就需要通过额外的寄存器对其进行标识。\n更具体的内容可以参考：https://www.cnblogs.com/cilinmengye/p/18986213\n那么，程序是如何保证mtvec中存储的地址一定是指向异常响应的程序段的呢？这是通过cte_init()函数实现的：\n1 2 3 4 5 6 7 8 9 bool cte_init(Context*(*handler)(Event, Context*)) { // initialize exception entry asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; : : \u0026#34;r\u0026#34;(__am_asm_trap)); // register event handler user_handler = handler; return true; } 读该函数可知，程序随后会跳转至__am_asm_trap这一程序段所在位置，而该程序段由trap.S中的汇编程序给出，首先，其会对程序的上下文（所有GPR，CSR）进行压栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 .align 3 .globl __am_asm_trap __am_asm_trap: addi sp, sp, -CONTEXT_SIZE MAP(REGS, PUSH) csrr t0, mcause csrr t1, mstatus csrr t2, mepc STORE t0, OFFSET_CAUSE(sp) STORE t1, OFFSET_STATUS(sp) STORE t2, OFFSET_EPC(sp) # set mstatus.MPRV to pass difftest li a0, (1 \u0026lt;\u0026lt; 17) or t1, t1, a0 csrw mstatus, t1 随后，该程序段会调用__am_irq_handle()函数，该函数需要接收一个Context *类型的参数，因此我们使用mv指令，将栈指针sp作为参数传递给该函数，因为此时sp指向的正是先前通过压栈组织起的上下文结构体。\n1 2 mv a0, sp call __am_irq_handle 而__am_irq_handle()函数会执行如下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Context* __am_irq_handle(Context *c) { if (user_handler) { Event ev = {0}; switch (c-\u0026gt;mcause) { case 11: #ifdef __riscv_e if (c-\u0026gt;gpr[15] == -1) { // $a5 #else if (c-\u0026gt;gpr[17] == -1) { // $a7 #endif ev.event = EVENT_YIELD; // software: jump to next instruction c-\u0026gt;mepc += 4; break; } else { ev.event = EVENT_SYSCALL; break; } default: ev.event = EVENT_ERROR; break; } c = user_handler(ev, c); assert(c != NULL); } return c; } 此时，该函数会调用user_handler()函数，处理不同类型的异常，异常的类型是通过上下文结构体中保存的mcause以及GPR中保存的标识共同解析的，而此时的user_handler()函数被赋值为simple_trap()函数（在am-tests的主函数中首先将simple_trap()函数传参给cte_init()函数，随后在该函数中赋值user_handler()函数）。\n同时，对于自陷操作，ecall指令在mepc中保存的是自陷操作本身所在的PC, 因此软件需要对保存的PC加上4, 使得将来返回到自陷操作的下一条指令。\nsimple_trap()函数完成执行后，会一直返回至__am_asm_trap程序段调用__am_irq_handle()函数的位置，并开始恢复上下文，将上下文中的GPR与CSR逐个弹栈：\n1 2 3 4 5 6 7 8 9 LOAD t1, OFFSET_STATUS(sp) LOAD t2, OFFSET_EPC(sp) csrw mstatus, t1 csrw mepc, t2 MAP(REGS, POP) addi sp, sp, CONTEXT_SIZE mret 完成上下文恢复后，最后调用mret指令跳转回mepc所存储的地址，也就是最初执行ecall时的PC+4，而经过while (1)的死循环，又会重新运行到yield()函数，进而无限重复先前所述的流程，在程序运行结果中表现为不断调用simple_trap()函数并输出y。\n","date":"2025-10-14T00:00:00Z","image":"https://posvirus.github.io/p/yield/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/yield/","title":"NEMU异常响应机制的实现"},{"content":"NEMU对RV32E架构的适配 在原始的NEMU中，如果尝试使用RV32E架构的NEMU运行NEMU，会直接报错，为修复这一问题，我们需要对NEMU做如下修改：\n首先，在am-kernels/kernels/nemu文件夹中的Makefile中，我们通过build_am目标构建可在AM上运行的NEMU：\n1 2 3 4 build_am: $(MAKE) -C $(NEMU_HOME) $(ISA)-am_defconfig $(MAKE) -C $(NEMU_HOME) ARCH=$(ARCH) mainargs=$(mainargs) || \\ ($(MAKE) restore_config; false) 而这一依赖项会查找NEMU项目中的$(ISA)-am_defconfig文件，而目前NEMU项目的configs目录下缺少riscv32e-am_defconfig文件，需要予以补充：\n1 2 3 4 CONFIG_TARGET_AM=y # CONFIG_TRACE is not set CONFIG_MSIZE=0x2000000 CONFIG_DEVICE=y 随后，对于NEMU而言，其构建的可执行文件的名称，是通过NEMU项目根目录下Makefile的如下代码：\n1 2 3 GUEST_ISA ?= $(call remove_quote,$(CONFIG_ISA)) ENGINE ?= $(call remove_quote,$(CONFIG_ENGINE)) NAME = $(GUEST_ISA)-nemu-$(ENGINE) 以及AM项目根目录下Makefile的如下代码联合指定的：\n1 2 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) 这里的CONFIG_ISA在Kconfig中只会被配置为riscv32，而使用该架构的E扩展是通过CONFIG_RVE来配置的，这就导致，在NEMU项目的build目录下，生成的可执行文件为riscv32-nemu-interpreter-riscv32e-nemu.bin，随后我们会通过：\n1 2 3 4 5 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin 在NEMU上运行NEMU，但这里存在一个问题，这里指定的可执行文件中，ISA是在ARCH中提取的，因此如果我们输入ARCH=riscv32e-nemu的话，实际提取的ISA=riscv32e，这就导致riscv32e-nemu-interpreter-riscv32e-nemu.bin并不存在，因此，我们可以对该Makefile稍作修改，使其可以正常执行功能：\n1 2 3 4 5 6 7 8 9 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config @if [ \u0026#34;$(ISA)\u0026#34; = \u0026#34;riscv32e\u0026#34; ]; then \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/riscv32-nemu-interpreter-$(ARCH).bin; \\ else \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin; \\ fi AM程序的运行逻辑 如果我们在am-kernels/kernels/nemu/目录下，执行\n1 make ARCH=$ISA-nemu mainargs=$executable_file_path 这会让我们在NEMU上运行一个载入可执行程序镜像的NEMU，假设我们利用此方法运行am-kernels/kernels目录下的打字游戏，那么打字游戏是如何实现配置外层NEMU的设备进行读取按键/刷新屏幕的呢？此处将简单进行说明：\n首先，此时整个系统的层次如下：\n1 [OUTER NEMU]--\u0026gt;[INNER NEMU]--\u0026gt;[TYPING-GAME] 打字游戏的可执行文件镜像将被加载至内层NEMU中，而内存NEMU的可执行文件镜像又被加载至外层NEMU中。\n因此，当打字游戏首先调用IOE API实现设备配置时，由于其运行在内层NEMU上，因此其会调用内层NEMU设备的回调函数：\n1 [OUTER NEMU DEVICE] ??? [INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] 但是，内层NEMU设备是如何将配置传递给外层NEMU的呢？这就涉及到当定义CONFIG_TARGET_AM时，内存NEMU设备的回调函数行为会重新被定义，比如，对于VGA而言，其更新屏幕的逻辑如下：\n1 2 3 4 5 static void init_screen() {} static inline void update_screen() { io_write(AM_GPU_FBDRAW, 0, 0, vmem, screen_width(), screen_height(), true); } 可知，内层NEMU此时也调用了IOE API，而由于其运行在外层NEMU上，此处的IOE API便会调用外层设备的回调函数，而此时API的作用也是将自身设备的配置传递给外层NEMU的设备，比如这里的update_screen()函数，其行为即是将整个页面按照vmem的取值更新。\n1 [OUTER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] ","date":"2025-10-11T00:00:00Z","image":"https://posvirus.github.io/p/nemu-run-nemu/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-run-nemu/","title":"使用RV32E架构的NEMU运行NEMU"},{"content":"设备实时时钟的实现 在PA2中，我们只被要求实现AM_TIMER_UPTIME，即系统启动后的微秒数，而此处为了更好的展示效果，我们将实现AM_TIMER_RTC，实现对当前真实时间的读取。\n在AM的timer.c中我们可以看到，rtc共有second、minute、hour、day、month与year共6个字段，为此，我们需要在NEMU的中为这些字段分配相应的空间，但是，如果我们为每个字段都分配一个32位的空间，时钟设备的地址空间会与其它设备产生交叠，但我们又不希望修改整个地址空间映射，应该如何解决这个问题呢？\n我们注意到，second、minute、hour、day、month这些字段，它们的取值其实非常有限，以至于我们分配8位/16位的空间给它们就足够了，所以，我们通过下面这种方式，将这6个字段压缩至2个32位空间中：\n1 2 // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] 于是我们仅需再为时钟申请8个字节的地址空间即可：\n1 2 3 4 5 6 7 8 9 void init_timer() { rtc_port_base = (uint32_t *)new_space(16); #ifdef CONFIG_HAS_PORT_IO add_pio_map (\u0026#34;rtc\u0026#34;, CONFIG_RTC_PORT, rtc_port_base, 16, rtc_io_handler); #else add_mmio_map(\u0026#34;rtc\u0026#34;, CONFIG_RTC_MMIO, rtc_port_base, 16, rtc_io_handler); #endif IFNDEF(CONFIG_TARGET_AM, add_alarm_handle(timer_intr)); } 而对于这些字段的赋值，我们调用time.h中的time()函数获取当前时间，并调用localtime()函数将其格式化即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void rtc_io_handler(uint32_t offset, int len, bool is_write) { assert(offset == 0 || offset == 4 || offset == 8 || offset == 12); if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { uint64_t us = get_time(); rtc_port_base[0] = (uint32_t)us; rtc_port_base[1] = us \u0026gt;\u0026gt; 32; time_t timep; struct tm *p; time(\u0026amp;timep); p = localtime(\u0026amp;timep); // rtc register allocation // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] rtc_port_base[2] = (((uint32_t)p-\u0026gt;tm_year) \u0026lt;\u0026lt; 16) | ((uint32_t)p-\u0026gt;tm_sec); rtc_port_base[3] = (((uint32_t)p-\u0026gt;tm_mon) \u0026lt;\u0026lt; 24) | (((uint32_t)p-\u0026gt;tm_mday) \u0026lt;\u0026lt; 16) | (((uint32_t)p-\u0026gt;tm_hour) \u0026lt;\u0026lt; 8) | ((uint32_t)p-\u0026gt;tm_min); } } 最后，我们即可在AM中的timer.c中实现字段的解码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void __am_timer_rtc(AM_TIMER_RTC_T *rtc) { // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] uint32_t time_cmb0 = inl(RTC_ADDR + 8); uint32_t time_cmb1 = inl(RTC_ADDR + 12); rtc-\u0026gt;second = (int)(time_cmb0 \u0026amp; ((uint32_t)0xffffu)); rtc-\u0026gt;minute = (int)(time_cmb1 \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;hour = (int)((time_cmb1 \u0026gt;\u0026gt; 8) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;day = (int)((time_cmb1 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;month = 1 + (int)((time_cmb1 \u0026gt;\u0026gt; 24) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;year = 1900 + (int)((time_cmb0 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffffu)); } 此处，我们需要注意，localtime()函数解码后的tm_year字段是相对1900年经过的年份，tm_mon字段则将12个月编码为0-11。\n另外，我们需要解释一下为什么rtc_io_handler()中会存在如下语句：\n1 if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { } 这是因为对AM而言，读取AM_TIME_UPTIME时：\n1 2 3 4 5 6 7 8 9 void __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) { // read RTC register uint32_t time_msb = inl(RTC_ADDR + 4); uint32_t time_lsb = inl(RTC_ADDR); ; // convert to uptime uptime-\u0026gt;us = (((uint64_t)time_msb) \u0026lt;\u0026lt; 32) + (uint64_t)time_lsb; } 我们会分别对该时间的高32位与低32位进行读取，而我们只希望rtc_io_handler()函数中的us在读取高32位（即offset为4）时进行更新，因为如果us在两次读取中均进行更新，假设读取高32位时us对应取值为{32'h0, 32'hffffffff}，而读取低32位时us对应取值为{32'h1, 32'h00001234}，那么我们最终读取的结果就是{32'h0, 32'h00001234}，这显然与真实值存在较大的误差。因此，我们让us只在第一次读取时（此处为读取高32位）进行更新，以保证读取结果的正确性。\n对于AM_TIME_RTC而言，我们也做了类似的处理，只不过因为AM_TIME_RTC的最小时间单位为秒，所以发生上述错误的几率小了许多。\n功能更强大的sprintf()函数 在运行设备测试时，我们需要在klib中实现功能更强大的I/O输出函数，为此，我们需要对先前实现的sprintf()函数进行优化，优化主要集中在两方面：\n首先，需要完整实现stdio.c中的函数，这涉及到对当前已实现函数的重构与复用。 其次，需要增加打印函数的功能，其需要识别前导0与固定位宽的标识符，如%02d，因为在设备测试中会使用到该功能。 stdio.c中库函数的完整实现 在原来的stdio.c实现中，我们直接对sprintf()函数进行实现，而没有实现剩余的函数，但是通过探究发现，将函数的功能主体集中于sprintf()函数中实现并不是最优选项，为追求函数实现的可复用性，一个较好的实现策略如下：\n首先，实现vsprintf()函数，该函数会接收一个va_list变量来对输入中的标识符进行例化。\n其次，基于vsprintf()函数，实现sprintf()函数与printf()函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int printf(const char *fmt, ...) { char buf[STR_MAX]; // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(buf, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); // put string to terminal putstr(buf); return strlen(buf); } 1 2 3 4 5 6 7 8 9 10 11 12 int sprintf(char *out, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(out, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); return strlen(out); } 此时，我们只需要将sprintf()函数的可变输入创建为一个va_list变量，随后调用vsprintf()函数即可。printf()函数也同理，我们只需利用vsprintf()函数将输出暂存于一个字符数组中，随后使用putstr()宏将其输出即可。\n最后，基于vsprintf()函数，实现vsnprintf()函数，并基于vsnprintf()函数实现snprintf()函数即可，复用方法类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int vsnprintf(char *out, size_t n, const char *fmt, va_list ap) { char buf[STR_MAX]; if (vsprintf(buf, fmt, ap) \u0026lt; 0) return -1; if (n == 0) return strlen(buf); strncpy(out, buf, n-1); out[n-1] = \u0026#39;\\0\u0026#39;; // ensure there is an EOL return strlen(buf); } int snprintf(char *out, size_t n, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); int ret = vsnprintf(out, n, fmt, args); // end of args extraction va_end(args); return ret; } 打印函数的功能扩展 为了增加对前导0与固定位宽的识别功能，我们需要扩展stdio.c中存储标识符的结构体SP_Token：\n1 2 3 4 5 6 typedef struct sp_token { int type; char str[256]; int len; // limited string length (unlimited len = -1) bool pad; // 1: \u0026#39;0\u0026#39;; 0: \u0026#39; \u0026#39;; (only used in number) } SP_Token; 这里为其增加了2个字段，len代表该标识符对应实际字符串的长度（不限制长度则取-1），pad则代表使用空格还是0进行前导填充。\n随后，在sp_make_token()函数中，我们需要在识别到%字符后，补充对前导0与固定位宽的识别逻辑，随后再进行后续识别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // set initial state sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; // %0, zero filled number if (fmt[position] == \u0026#39;0\u0026#39;) { sp_tokens[nr_sp_token].pad = true; position = position + 1; } // limited length data if ((fmt[position] \u0026gt; \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { int str_len = (int)(fmt[position] - \u0026#39;0\u0026#39;); // MSB position = position + 1; while ((fmt[position] \u0026gt;= \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { str_len = 10 * str_len + (int)(fmt[position] - \u0026#39;0\u0026#39;); position = position + 1; } sp_tokens[nr_sp_token].len = str_len; } /* ... */ return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } 最后，在将标识符对应输入参数映射为字符串后，我们需要额外依据标识符结构体中的len与pad字段为其添加前导填充：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static char *cutstr(char *re, int len, bool pad) { int str_len = strlen(re); if ((len == -1) || (len \u0026lt;= str_len)) return re; char buf[256]; memset(buf, (pad) ? (\u0026#39;0\u0026#39;) : (\u0026#39; \u0026#39;), len - str_len); buf[len - str_len] = \u0026#39;\\0\u0026#39;; if ((re[0] == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; (pad)) { // negative number with \u0026#39;0\u0026#39; filling strcat(buf, re + 1); strcpy(re + 1, buf); } else { strcat(buf, re); strcpy(re, buf); } return re; } 这里需要注意，对于负数，其前导填充如果是空格，则填充在负号前；如果是0，则填充在负号与数字之间。\n","date":"2025-10-05T00:00:00Z","image":"https://posvirus.github.io/p/rtc-and-sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rtc-and-sprintf/","title":"设备实时时钟与更强大的sprintf()函数"},{"content":"NEMU中设备初始化的流程 NEMU中各设备的初始化遵循一个统一的流程，以下将作简要说明：\n首先，设备会调用new_space()函数，这会从I/O地址空间中分配指定大小的空间给该设备，该函数在map.c中实现：\n1 2 3 4 5 6 7 8 9 10 11 static uint8_t *io_space = NULL; static uint8_t *p_space = NULL; uint8_t* new_space(int size) { uint8_t *p = p_space; // page aligned; size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; p_space += size; assert(p_space - io_space \u0026lt; IO_SPACE_MAX); return p; } 为解释该函数的作用，我们首先需要明确map.c中另一个函数init_map()的作用，该函数在device.c中的init_device()函数中被调用，用于初始化I/O地址空间，在完成初始化后才会调用各设备的初始化函数，将地址空间分配给各个设备。\n1 2 3 4 5 void init_map() { io_space = malloc(IO_SPACE_MAX); assert(io_space); p_space = io_space; } 这里init_map()函数通过malloc()函数创建了一个大小为IO_SPACE_MAX的空间，并将p_space与io_space均指向该空间起始位置。这里p_space实际用于指示当前未分配空间的起始位置，io_space则始终执行I/O地址空间的起始位置。\n注意，I/O地址空间在NEMU整个生命周期中都需要存在，且当NEMU退出时，操作系统会自动回收所有分配的内存，所以我们无需手动释放动态分配的空间。\n随后在设备初始化中调用new_space()函数，它会首先将p_space赋值给指针p，即将p指向当前未分配空间的起始位置，也是即将分配给该设备空间的初始位置。随后，我们对size进行向上取整的操作，使size变为PAGE_SIZE的整数倍：\n1 size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; 我们可以结合实际简要理解这段代码，假设PAGE_SIZE取1ul \u0026lt;\u0026lt; 12（即4096），这里size + (PAGE_SIZE - 1)的操作确保了：\n当size为PAGE_SIZE整数倍时，size + (PAGE_SIZE - 1)仍在当前页的范围内。 当size不为PAGE_SIZE整数倍时，size + (PAGE_SIZE - 1)会进入下一页的范围内。 随后，利用PAGE_MASK，我们可以将size + (PAGE_SIZE - 1)二进制表示中的低若干位清零，从而实现取整的操作，比如PAGE_SIZE取1ul \u0026lt;\u0026lt; 12时，PAGE_MASK可取(1ul \u0026lt;\u0026lt; 12) - 1，该数二进制表示的低12位均为0，从而与该数按位与后一定是PAGE_SIZE的倍数，且size + (PAGE_SIZE - 1)的操作保证最终分配的空间大小一定不小于原始请求的大小。\n完成对齐后，我们可以移动p_space指针，将size大小的空间标记为已分配，同时检查是否有足够的空间可以分配，如有，则返回指针p，代表空间分配完成。\n随后，设备会调用add_mmio_map()函数（这里我们只考虑MMIO），这一函数在mmio.c中实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static IOMap maps[NR_MAP] = {}; static int nr_map = 0; static void report_mmio_overlap(const char *name1, paddr_t l1, paddr_t r1, const char *name2, paddr_t l2, paddr_t r2) { panic(\u0026#34;MMIO region %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;] is overlapped \u0026#34; \u0026#34;with %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, name1, l1, r1, name2, l2, r2); } /* device interface */ void add_mmio_map(const char *name, paddr_t addr, void *space, uint32_t len, io_callback_t callback) { assert(nr_map \u0026lt; NR_MAP); paddr_t left = addr, right = addr + len - 1; if (in_pmem(left) || in_pmem(right)) { report_mmio_overlap(name, left, right, \u0026#34;pmem\u0026#34;, PMEM_LEFT, PMEM_RIGHT); } for (int i = 0; i \u0026lt; nr_map; i++) { if (left \u0026lt;= maps[i].high \u0026amp;\u0026amp; right \u0026gt;= maps[i].low) { report_mmio_overlap(name, left, right, maps[i].name, maps[i].low, maps[i].high); } } maps[nr_map] = (IOMap){ .name = name, .low = addr, .high = addr + len - 1, .space = space, .callback = callback }; Log(\u0026#34;Add mmio map \u0026#39;%s\u0026#39; at [\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, maps[nr_map].name, maps[nr_map].low, maps[nr_map].high); nr_map ++; } 这一函数主要创建一个IOMap结构体，该结构体存储了内存地址空间与I/O地址空间的映射关系，它的定义在map.h中：\n1 2 3 4 5 6 7 8 typedef struct { const char *name; // we treat ioaddr_t as paddr_t here paddr_t low; paddr_t high; void *space; io_callback_t callback; } IOMap; 主要包括以下字段：\nname：设备名称。 low/high：用于映射的内存地址空间的上/下边界。 space：指向设备I/O地址空间起始位置的指针。 callback：设备回调函数指针，指向各设备的回调函数。 了解IOMap的定义后，add_mmio_map()函数本身的实现是简单的，首先需要判断映射的内存地址空间与物理内存地址空间、已注册的设备内存地址空间是否重叠，如果不重叠，创建结构体即可。\n有了IOMap结构体后，我们便可在NEMU中使用map_read()函数与map_write()函数来访问设备并调用各设备的回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 word_t map_read(paddr_t addr, int len, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; invoke_callback(map-\u0026gt;callback, offset, len, false); // prepare data to read word_t ret = host_read(map-\u0026gt;space + offset, len); return ret; } void map_write(paddr_t addr, int len, word_t data, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; host_write(map-\u0026gt;space + offset, len, data); invoke_callback(map-\u0026gt;callback, offset, len, true); } mainargs的传递 当我们在测试程序目录下输入mainargs参数时，测试程序目录下的Makefile会先包含AM_HOME目录下（abstract-machine）的主Makefile，而这一主Makefile又会使用以下语句包含特定架构的Makefile：\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk 特定架构的Makefile又会包含其所运行平台（nemu/npc/native）的Makefile，以riscv32-nemu.mk为例，其包含：\n1 include $(AM_HOME)/scripts/platform/nemu.mk 最终，当我们使用make run时，mainargs会被传递到运行平台（nemu/npc/native）的Makefile中，以NEMU为例：\n1 2 3 4 5 insert-arg: image @python $(AM_HOME)/tools/insert-arg.py $(IMAGE).bin $(MAINARGS_MAX_LEN) \u0026#34;$(MAINARGS_PLACEHOLDER)\u0026#34; \u0026#34;$(mainargs)\u0026#34; run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin 此时，run目标会依赖insert-arg目标，而insert-arg目标会调用Python程序insert-arg.py，mainargs便作为该Python程序的输入参数，那么，这段Python程序主要在做什么呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python3 from sys import argv bin = argv[1] max_len = int(argv[2]) placeholder = argv[3] mainargs = argv[4] if len(mainargs) \u0026gt;= max_len: print(\u0026#34;Error: mainargs should not be longer than {0} bytes\\n\u0026#34;.format( max_len)) exit(1) print(\u0026#34;mainargs={0}\u0026#34;.format(mainargs)) fp = open(bin, \u0026#39;r+b\u0026#39;) data = fp.read() idx = data.find(str.encode(placeholder)) if idx == -1: print(\u0026#34;Error: placeholder not found!\\n\u0026#34;) exit(1) fp.seek(idx) mainargs_pad = str.encode(mainargs)+ ((max_len - len(mainargs)) * str.encode(\u0026#34;\\0\u0026#34;)) if len(mainargs_pad) != max_len: print(\u0026#34;Error: len(mainargs_pad) != max_len\\n\u0026#34;) exit(1) fp.write(mainargs_pad) fp.close() 首先，它会将mainargs打印出来（但这个打印并对应hello程序中输出mainargs的打印行为，后者所hello程序本身内置的），同时向编译后的可执行文件注入mainargs参数。随后，在trm.c中，我们便可将mainargs参数通过_trm_init()函数注入到main函数中：\n1 2 3 4 5 6 static const char mainargs[MAINARGS_MAX_LEN] = MAINARGS_PLACEHOLDER; // defined in CFLAGS void _trm_init() { int ret = main(mainargs); halt(ret); } ","date":"2025-10-04T00:00:00Z","image":"https://posvirus.github.io/p/device-note/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/device-note/","title":"NEMU的设备实现注意事项"},{"content":"此处，我们主要关注向NPC中集成DiffTest时的一些注意事项：\nCPU状态的存储 在运行DiffTest时，我们需要比较REF与DUT的CPU的状态是否一致，而NPC先前未定义存储CPU状态的结构体（因为CPU的状态实际存储在RTL代码中），为方便DiffTest的传参，我们补充定义存储CPU状态的结构体CPU_state，以及它对应的初始化函数与状态同步函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct { word_t grf[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } CPU_state; CPU_state cpu; // defining struct facilitates parameter passing void load_cpu(Vtop* top) { cpu.pc = top-\u0026gt;inst_addr; long long temp_grf; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { gpr((long long)i, \u0026amp;temp_grf); cpu.grf[i] = (word_t)temp_grf; } } // the NPC RegisterFile has no reset signal, // so the initial value of gpr need to be given manually void init_cpu() { cpu.pc = RESET_VECTOR; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { cpu.grf[i] = 0; } } 这里，我们首先定义了load_cpu()函数，它会将当前CPU模块中的PC寄存器与寄存器堆的值传递至cpu中。其次，我们还补充定义了init_cpu()函数，这是因为，目前我们在init_monitor()函数中进行DiffTest的初始化，而该函数在主函数中会先于系统仿真复位函数执行，为保证cpu可以正确获取CPU模块复位的状态，我们需要手动为cpu中的字段赋值。\nRV32E指令集的适配 NEMU的Kconfig中有一个RVE的选项，用于将NEMU的指令集架构指定为RV32E，选中该选项后，会在生成CONFIG_RVE的宏定义，为使NEMU适配RV32E指令集，我们需要对NEMU代码进行相应更改，修改主要集中于对NEMU的寄存器堆访问，需要根据CONFIG_RVE判断寄存器的总数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void isa_reg_display() { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { printf(\u0026#34;%s\\t0x%08x\\t%d\\n\u0026#34;, regs[reg_cnt], gpr(reg_cnt), gpr(reg_cnt)); } // extra print PC register printf(\u0026#34;pc\\t0x%08x\\t%d\\n\u0026#34;, cpu.pc, cpu.pc); } word_t isa_reg_str2val(const char *s, bool *success) { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { if (strcmp(s, regs[reg_cnt]) == 0) { *success = true; return gpr(reg_cnt); } } // extra find pc register if (strcmp(s, \u0026#34;pc\u0026#34;) == 0) { *success = true; return cpu.pc; } *success = false; printf(\u0026#34;register %s not found!\\n\u0026#34;, s); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) { int reg_num = MUXDEF(CONFIG_RVE, 16, 32); extern const char* regs[]; for (int i = 0; i \u0026lt; reg_num; i++) { if (!difftest_check_reg(regs[i], pc, ref_r-\u0026gt;gpr[i], cpu.gpr[i])) return false; } if (!difftest_check_reg(\u0026#34;pc\u0026#34;, pc, ref_r-\u0026gt;pc, cpu.pc)) return false; return true; } NEMU作为REF的自动化编译 在集成DiffTest时，我们需要将NEMU编译成动态库文件，并在NPC中动态链接该动态库文件，从而实现NEMU作为REF的DiffTest。但是，我们实际上不希望在每次运行NPC的DiffTest时，还要进入NEMU的目录下手动修改NEMU的配置并编译动态库文件，我们希望的一个理想的操作流是：\n在NPC的Kconfig中使能DiffTest后，构建NPC时会自动配置NEMU并编译NEMU的动态库文件。 NEMU的配置在NPC运行DiffTest后不应发生任何更改。 为此，我们实现如下的Makefile：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 define remove_quote $(strip $(subst \u0026#34;,,$(1))) endef ifdef CONFIG_DIFFTEST DIFF_REF_PATH = $(NEMU_HOME) DIFF_REF_SO = $(NEMU_HOME)/build/$(call remove_quote,$(CONFIG_ISA))-$(call remove_quote,$(CONFIG_DIFFTEST_REF_NAME))-$(call remove_quote,$(CONFIG_ENGINE))-so MKFLAGS = GUEST_ISA=$(call remove_quote,$(CONFIG_ISA)) SHARE=1 ENGINE=$(call remove_quote,$(CONFIG_ENGINE)) ARGS_DIFF = --diff=$(DIFF_REF_SO) # Backup and restore NEMU config files NEMU_AUTO_CONF = $(NEMU_HOME)/include/config/auto.conf NEMU_AUTOCONF_H = $(NEMU_HOME)/include/generated/autoconf.h NEMU_AUTO_CONF_BK = $(NEMU_HOME)/include/config/auto.conf.bk NEMU_AUTOCONF_H_BK = $(NEMU_HOME)/include/generated/autoconf.h.bk backup-nemu: @echo \u0026#34;Backing up NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF) ]; then \\ cp $(NEMU_AUTO_CONF) $(NEMU_AUTO_CONF_BK); \\ sed -i \u0026#39;/^CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_TRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ISA/d\u0026#39; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA=\\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA_riscv=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^CONFIG_RVE=\u0026#39; $(NEMU_AUTO_CONF); then \\ echo \u0026#34;CONFIG_RVE=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ fi; \\ fi; \\ fi @if [ -f $(NEMU_AUTOCONF_H) ]; then \\ cp $(NEMU_AUTOCONF_H) $(NEMU_AUTOCONF_H_BK); \\ sed -i \u0026#39;/^#define CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_TRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ISA/d\u0026#39; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA \\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA_riscv 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^#define CONFIG_RVE\u0026#39; $(NEMU_AUTOCONF_H); then \\ echo \u0026#34;#define CONFIG_RVE 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ fi; \\ fi; \\ fi restore-nemu: @echo \u0026#34;Restoring NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF_BK) ]; then \\ mv $(NEMU_AUTO_CONF_BK) $(NEMU_AUTO_CONF); \\ fi @if [ -f $(NEMU_AUTOCONF_H_BK) ]; then \\ mv $(NEMU_AUTOCONF_H_BK) $(NEMU_AUTOCONF_H); \\ fi ifdef CONFIG_DIFFTEST_REF_NEMU $(DIFF_REF_SO): @$(MAKE) backup-nemu @$(MAKE) -s -C $(DIFF_REF_PATH) $(MKFLAGS) @$(MAKE) restore-nemu endif .PHONY: $(DIFF_REF_SO) backup-nemu restore-nemu endif 该Makefile的基本结构参考了nemu/tools/difftest.mk，其中DIFF_REF_SO即为REF的动态库文件，当将该Makefile包含在主Makefile中，即可通过：\n1 2 3 4 5 run: $(VERILOG_INPUT) $(VRC_INPUT) ifdef CONFIG_DIFFTEST @echo \u0026#34;-------- REF COMPILE ---------\u0026#34; @$(MAKE) $(DIFF_REF_SO) endif 调用并构建NEMU的动态库文件。以下，我们将解释该Makefile是如何实现对NEMU的配置及恢复的，这主要包括两方面：\n首先，在DIFF_REF_SO的MKFLAGS中，我们将通过Makfile传递NEMU的GUEST_ISA、SHARE与ENGINE参数。此处设置SHARE=1，NEMU便会自动编译成动态库文件。\n其次，当NEMU作为REF时，我们需要除能NEMU配置中一些非必要的功能，比如itrace、ftrace、mtrace等，因为这些功能本身具有输出功能，如果编译动态库文件中包含这些功能，在NPC中运行DiffTest时将会混杂NEMU的输出，造成功能异常。\n为此，我们定义了backup-nemu与restore-nemu两个目标，前者用于将NEMU通过Kconfig生成的配置文件（autoconf.h与auto.conf）保存为副本，并修改配置文件的配置项；后者则用于将副本重新加载为NEMU配置文件。在backup-nemu中，我们修改的配置主要包括：\n除能CONFIG_TARGET_NATIVE_ELF，保证NEMU编译成动态库文件，此处之所以没有补充定义CONFIG_TARGET_SHARE，是因为定义该配置的效果完全等同于在构建时传递SHARE=1。 除能NEMU的指令集架构，将其统一设置为RISCV32，这使得即使我们没有使用RISCV32架构的NEMU，仍然可以在NPC中成功编译RISCV32架构的NEMU动态库文件。 除能NEMU的itrace，mtrace，ftrace功能。 除能NEMU的sdb表达式求值测试功能。 当NPC指令集架构为RV32E，在NEMU中补充定义CONFIG_RVE，将其指令集架构修改为RV32E。 DiffTest的时序问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 static void trace_and_difftest(Vtop *top) { #ifdef CONFIG_ITRACE log_write(\u0026#34;%s\\n\u0026#34;, logbuf); #endif if (g_print_step) { IFDEF(CONFIG_ITRACE, puts(logbuf)); } #ifdef CONFIG_DIFFTEST pc_get(\u0026amp;pc_d, \u0026amp;dnpc_d); load_cpu(top); difftest_step((vaddr_t)pc_d, (vaddr_t)dnpc_d); // current-cycle difftest #endif } static void exec_once(Vtop *top, VerilatedContext *contextp, VerilatedFstC *tfp, bool rst) { if (rst) { EDGE_TRG_EVENT(top, top-\u0026gt;rst = 0; top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); } #ifdef CONFIG_ITRACE IRingBuffer_write(top); #endif half_cycle(top, contextp, tfp); EDGE_TRG(top); half_cycle(top, contextp, tfp); #ifdef CONFIG_FTRACE int type_ft; long long int pc_ft, dnpc_ft; ftrace_type(\u0026amp;type_ft); pc_get(\u0026amp;pc_ft, \u0026amp;dnpc_ft); switch (type_ft) { case 1: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, false); break; case 2: print_return((vaddr_t)pc_ft); break; case 3: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, true); break; default: break; } #endif #ifdef CONFIG_ITRACE char *p = logbuf; p += snprintf(p, MAX_LOGBUF_LEN, FMT_WORD \u0026#34;:\u0026#34;, top-\u0026gt;inst_addr); int i; uint8_t *inst = (uint8_t *)\u0026amp;top-\u0026gt;inst; for (i = 4 - 1; i \u0026gt;= 0; i --) { p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } memset(p, \u0026#39; \u0026#39;, 1); p += 1; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, logbuf + MAX_LOGBUF_LEN - p, top-\u0026gt;inst_addr, (uint8_t *)\u0026amp;top-\u0026gt;inst, 4); #endif EDGE_TRG_EVENT(top, top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); // next instruction fetch } 由于我们采用自定义的宏EDGE_TRG_EVENT()来实现对Verilator生成文件的激励，这会在实现DiffTest时带来一些时序问题，具体而言：NPC中定义的exec_once()函数实际上仿真的是从当前时钟周期时钟上升沿开始，到下一时钟周期上升沿前的时间，这使得当该函数执行完成，当前指令还没有对寄存器堆进行写回操作（这需要等到下一时钟上升沿后），寄存器堆内部的取值还没有更新，因此，如果像NEMU中，在exec_once()执行完成后直接进行DiffTest，便会引发错误。\n为此，我们调整了exec_once()函数的执行顺序，将其仿真的时间修改为从当前时钟周期时钟上升沿后开始，到下一时钟上升沿后结束，即在exec_once()函数中会预取下一周期的指令。同时，我们需要额外保证在系统复位后，exec_once()函数中也会预取第一周期的指令。\n","date":"2025-09-30T00:00:00Z","image":"https://posvirus.github.io/p/npc-note2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note2/","title":"NPC实现时的注意事项（2）"},{"content":"NPC指令的反汇编 当直接在NPC中使用capstone项目提供的反汇编功能，并将NEMU中的disasm.c复制到NPC中，会出现报错。具体而言，我们需要对disasm.c中的几个函数指针进行显示强制类型转换：\n1 2 3 4 5 6 7 8 9 cs_err (*cs_open_dl)(cs_arch arch, cs_mode mode, csh *handle) = NULL; cs_open_dl = reinterpret_cast\u0026lt;cs_err (*)(cs_arch, cs_mode, csh*)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_open\u0026#34;)); assert(cs_open_dl); cs_disasm_dl = reinterpret_cast\u0026lt;size_t (*)(csh, const uint8_t*, size_t, uint64_t, size_t, cs_insn**)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_disasm\u0026#34;)); assert(cs_disasm_dl); cs_free_dl = reinterpret_cast\u0026lt;void (*)(cs_insn*, size_t)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_free\u0026#34;)); assert(cs_free_dl); NPC中sdb命令行的实现 sdb命令行需要调用readline.h库实现，在C++中，由于readline是一个动态库，编译的时候需要加上-lreadline，不然会找不到相关的函数。在Verilator中，我们可以直接使用-LDFLAG加载这一动态库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # load readline library (used for sdb) LDFLAGS_VR += -lreadline run: $(VERILOG_INPUT) $(VRC_INPUT) @rm -rf input.vc @echo \u0026#34;$(INPUT_FLAG)\u0026#34; | cat \u0026gt; input.vc @echo @echo \u0026#34;---------- VERILATE ----------\u0026#34; @rm -rf $(OBJ_PATH)/* @@$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ $(addprefix -LDFLAGS , $(LDFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $^ sdb扫描NPC寄存器的实现 我们考虑通过DPI-C实现，请注意DPI-C实际上是双向的，即：我可以在RTL代码中调用C++中实现的函数（import），也可以在C++代码中调用RTL代码中定义的任务（export）。在sdb中实现扫描NPC寄存器显然属于后者，即我们需要在RTL代码中定义一个读取寄存器的任务，再在C++代码中调用该任务：\n1 2 3 4 5 6 7 8 9 10 11 12 export \u0026#34;DPI-C\u0026#34; task gpr; task gpr; input longint addr; // 64-bit space output longint data; // 64-bit space if (addr == -1) begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, cur_pc}; end else begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, u_ysyx_25070184_IDU.u_ysyx_25070184_RegisterFile.rf[addr[`ysyx_25070184_REG_ADDR_WIDTH-1:0]]}; end endtask 在实现该任务时，有以下几点需要注意：\n这里我们将任务名定义成gpr，这样我们就可以在C++代码中通过gpr(N)读取第N个寄存器的值，保持其与NEMU代码中的一致性。 我们将任务定义在顶层模块中，这样可以同时读取PC寄存器与通用寄存器。 为防止RTL代码与C++代码中复杂的类型转换，我们统一将addr与data类型定义为longint，这样可以直接映射至C++中的long long类型，且对32/64位的CPU均不会产生溢出。 Verilator的优化输出 Verilator编译的原始输出相对比较冗杂，难以在其中提取有效信息，我希望可以通过修改Makefile将其输出优化为NEMU的规整编译输出。但是NEMU是基于多个Makefile的嵌套，实现对项目的逐文件编译，在NPC中较难实现这一点（一般我们是将需要编译的文件一次性在Makefile中嵌入Verilator编译指令中）。\n于是，我这里采用了一种取巧的方法，直接将Verilator的原始编译输出重定向并依据其输出格式进行信息提取，从而实现规整输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $(VERILATOR_INPUT) $^ 2\u0026gt;\u0026amp;1 | \\ while IFS= read -r line; do \\ if [[ \u0026#34;$$line\u0026#34; == *\u0026#34;g++\u0026#34;* ]]; then \\ last_word=$$(echo \u0026#34;$$line\u0026#34; | awk \u0026#39;{print $$NF}\u0026#39;); \\ if [[ \u0026#34;$$last_word\u0026#34; == *\u0026#34;.cpp\u0026#34; ]]; then \\ echo \u0026#34;[CXX] $$last_word\u0026#34;; \\ else \\ echo \u0026#34;[BUILD] $$last_word\u0026#34;; \\ fi; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;python3\u0026#34;* ]] \u0026amp;\u0026amp; [[ \u0026#34;$$line\u0026#34; == *\u0026#34;.cpp\u0026#34;* ]]; then \\ echo \u0026#34;$$line\u0026#34; | grep -o \u0026#39;[^ ]*\\.cpp\u0026#39; | while read -r cpp_file; do \\ echo \u0026#34;[PYTHON] verilator include: $$cpp_file\u0026#34;; \\ done; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;echo\u0026#34;* ]] || [[ \u0026#34;$$line\u0026#34; == *\u0026#34;rm\u0026#34;* ]]; then \\ continue; \\ else \\ echo \u0026#34;$$line\u0026#34;; \\ fi; \\ done sdb退出指令的优化 在实现NPC时，发现NEMU sdb中的退出指令（q）有一个bug，原始的cmd_q()函数通常实现如下：\n1 2 3 4 static int cmd_q(char *args) { nemu_state.state = NEMU_QUIT; return -1; } 这会导致在运行am-kernels中的测试程序时，如果没有使用批处理模式，且程序最终HIT BAD TRAP，此时直接使用退出指令退出，NEMU的状态会被重置为NEMU_QUIT，导致最后is_exit_status_bad()函数的返回值仍为0，这使得程序虽然测试失败，但最终仍会返回PASS的结果。\n为此，我们需要额外对运行退出指令时NEMU的状态进行判断，如果程序非正常退出，则保持程序当前的状态：\n1 2 3 4 5 6 7 8 9 10 static int cmd_q(char *args) { // if nemu hits bad trap, hold state if ((nemu_state.state == NEMU_ABORT) || ((nemu_state.state == NEMU_END) \u0026amp;\u0026amp; (nemu_state.halt_ret != 0))) { // do nothing } else { nemu_state.state = NEMU_QUIT; } return -1; } 这里其实还有另外一个问题，就是如果在程序运行过程中退出，是否需要保留当前NEMU的状态？此处我们暂时认为无需保留，即NEMU的状态会被重置为NEMU_QUIT，程序测试会返回PASS的结果。\nNPC默认程序的日志输出 在NPC中直接运行默认程序，会发现每条日志输出都会在命令行中重复输出两次，这主要是因为在init_log()函数中：\n1 2 3 4 5 6 7 8 9 void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } log_fp被初始化为stdout，这使得log_write()在调用fprintf()函数时，也会直接将日志输出至命令行中。\n为解决这一点，我们只需在Makfile中加入：\n1 override ARGS ?= --log=$(BUILD_PATH)/npc-log.txt 使得运行NPC默认程序时的日志会输出至构建目录的npc-log.txt中即可。\n","date":"2025-09-25T00:00:00Z","image":"https://posvirus.github.io/p/npc-note1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note1/","title":"NPC实现时的注意事项（1）"},{"content":"在讲义中提到，当使用difftest_regcpy()传递DUT与REF的寄存器状态时，需要DUT的寄存器顺序与REF保持一致。此处我将说明如何检查这一点：\n首先，对于NEMU，RISCV32架构的寄存器顺序在reg.c中定义：\n1 2 3 4 5 6 const char *regs[] = { \u0026#34;$0\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; 以下我们只需要查看RISCV32的REF（即Spike）中，寄存器的顺序是否与之一致即可，首先，在tool目录下的difftest.cc中可见：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sim_t::diff_get_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { ctx-\u0026gt;gpr[i] = state-\u0026gt;XPR[i]; } ctx-\u0026gt;pc = state-\u0026gt;pc; } void sim_t::diff_set_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { state-\u0026gt;XPR.write(i, (sword_t)ctx-\u0026gt;gpr[i]); } state-\u0026gt;pc = ctx-\u0026gt;pc; } 其中gpr[]是NEMU中的通用寄存器成员，而XPR[]则应该是Spike中对应的通用寄存器成员，于是，我们可以进一步在Spike的项目目录下搜索该成员定义，最后发现在regnames.cc中定义了Spike对应的寄存器顺序：\n1 2 3 4 5 6 const char* xpr_name[] = { \u0026#34;zero\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; 经验证，即可发现DUT与REF的寄存器顺序是一致的，无需额外调整。\n","date":"2025-08-24T00:00:00Z","image":"https://posvirus.github.io/p/difftest-gpr/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/difftest-gpr/","title":"DiffTest中的寄存器一致性"},{"content":"native可执行文件的生成 在AM Makefile中，我们会通过：\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk 包含架构相关的Makefile，当我们指定ARCH=native时，包含的Makefile内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 AM_SRCS := native/trm.c \\ native/ioe.c \\ native/cte.c \\ native/trap.S \\ native/vme.c \\ native/mpe.c \\ native/platform.c \\ native/ioe/input.c \\ native/ioe/timer.c \\ native/ioe/gpu.c \\ native/ioe/uart.c \\ native/ioe/audio.c \\ native/ioe/disk.c \\ CFLAGS += -fpie $(shell sdl2-config --cflags) ASFLAGS += -fpie -pie comma = , LDFLAGS_CXX = $(addprefix -Wl$(comma), $(LDFLAGS)) -pie -ldl $(shell sdl2-config --libs) run: image $(IMAGE).elf gdb: image gdb -ex \u0026#34;handle SIGUSR1 SIGUSR2 SIGSEGV noprint nostop\u0026#34; $(IMAGE).elf 首先，该Makefile会定义AM_SRCS，包含GNU/Linux默认的运行时环境native用于实现AM API的所有源文件，该变量会在am路径下的Makefile中被使用，作为SRC进行编译：\n1 2 3 4 5 NAME := am SRCS = $(addprefix src/, $(AM_SRCS)) INC_PATH += $(AM_HOME)/am/src include $(AM_HOME)/Makefile 随后，该Makefile会补充native架构下对应的编译选项，这部分我们暂且不作说明。\n最后，该Makefile定义了run与gdb两个目标，分别用于直接执行$(IMAGE).elf与调试执行$(IMAGE).elf。\nMakefile的错误码 使用如下指令在native架构下执行测试：\n1 make ARCH=native ALL=$PROGRAM run 如若执行失败，则会返回：\n1 make[1]: *** [run] Error 1 此处我们将分析这里错误码1的来源：首先，我们知道测试程序的正确与错误是通过程序中的check()函数实现的，于是我们可查看该函数的实现，在trap.h中：\n1 2 3 void check(bool cond) { if (!cond) halt(1); } 据此可观察到，当条件cond为false时，函数会调用halt(1)，该函数应该是控制错误码的核心函数，于是我们寻找该函数的定义，在AM的trm.c中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void halt(int code) { const char *fmt = \u0026#34;Exit code = 40h\\n\u0026#34;; for (const char *p = fmt; *p; p++) { char ch = *p; if (ch == \u0026#39;0\u0026#39; || ch == \u0026#39;4\u0026#39;) { ch = \u0026#34;0123456789abcdef\u0026#34;[(code \u0026gt;\u0026gt; (ch - \u0026#39;0\u0026#39;)) \u0026amp; 0xf]; } putch(ch); } __am_exit_platform(code); putstr(\u0026#34;Should not reach here!\\n\u0026#34;); while (1); } 不难发现，halt()函数的code参数即用于控制错误码。为验证这一点，我们不妨将check()函数中的halt(1)改为halt(3)，再次运行某个程序，并打印对应的错误输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Building add-run [native] # Building am-archive [native] + CC src/native/cte.c + CC src/native/vme.c + CC src/native/mpe.c + CC src/native/platform.c + CC src/native/ioe/audio.c + AR -\u0026gt; build/am-native.a # Building klib-archive [native] + CC src/stdio.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-native.a + CC tests/add.c # Creating image [native] + LD -\u0026gt; build/add-native.elf Exit code = 03h make[1]: *** [/home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk:21: run] Error 3 test list [1 item(s)]: add [ add] ***FAIL*** 此时可观察到，程序的错误码输出已变成3。\nklib的链接 框架代码编译到native的时候默认链接到glibc, 我们需要把这些库函数的调用链接到我们编写的klib来进行测试. 我们可以通过在klib.h 中通过定义宏__NATIVE_USE_KLIB__来把库函数链接到klib。该功能的实现原理如下：\n编译阶段： 在klib的库函数实现中包含如下字段： 1 2 3 #if !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__) ... #endif 该字段表明，如果程序在非native架构下编译，或在native架构下编译且定义了__NATIVE_USE_KLIB__，则编译该文件中的函数实现。 链接阶段： 链接器会按顺序处理目标文件和库。自定义实现的符号会优先被链接，而不是系统标准库中的相同符号（因为链接器默认先处理显式指定的目标文件，后处理库）。 ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-2/","title":"AM Makefile解读（2）"},{"content":"此处说明ftrace实现的一些相关注意事项：\nELF文件的解析 参考讲义，我们可以使用man 5 elf查看ELF文件的结构（可视化结构如上图所示）。这里主要说明如何对其进行解析：\n首先，需要指出，ELF文件本质上还是一个文件，所以我们可以使用fread(), fopen()等对文件相关的标准库函数对其进行读取。其次，基于ELF文件的结构，我们需要查找并存储所有函数符号的地址（Value）及对应大小（Size），需要经过如下步骤：\n阅读ELF文件的Header，使用fread()函数将其写入一个ElfN_Ehdr结构体中，并从中提取： Section Header Table（节头表）的地址偏移量（e_shoff）。 节头表的表项个数（亦即表的行数，e_shnum）。 Section Header String Table（节头名字表）对应的节头表表项索引值（e_shstrndx）。这里需要指出，对于节头表的每一个表项，均索引ELF文件中的一个实体区域，节头表的各表项仅用于记录这个实体的各种参数（如名字、地址偏移量、大小与表项个数等等），而存在一个称为节头名字表的实体，专门用于储存节头表各表项的名字，且节头表同样会存在一个表项索引它。所以如果我们向获取节头表中的某个表项的名字，我们就需要先读取节头名字表，再根据表项提供的参数在节头名字表内定位到该表项对应的名字。 根据提取的参数，查找节头表中节头名字表对应的表项，使用fread()函数将其写入一个ElfN_Shdr结构体中，并从中提取： 节头名字表对应的地址偏移量（sh_offset）。 依据节头名字表的地址偏移量，我们即可定位到节头名字表，随后开始扫描节头表的各表项，使用fread()函数循环将各表项写入一个ElfN_Shdr结构体中，并根据表项的sh_name字段在节头名字表中读取定位该表项的名字，我们需要查找两个表项： 名字为.symtab的表项：符号表，用于存储程序中的符号，我们需要获取其对应的地址偏移量（sh_offset）与表项个数（这里可以使用符号表总大小sh_size与符号表单个表项的大小sh_entsize相除得到）。 名字为.strtab的表项：符号名字表，用于存储符号表中各表项的名字，它与符号表的关系类似节头名字表与节头表的关系。我们需要获取其对应的地址偏移量（sh_offset）与大小（sh_size）。 完成表项的查找后，依据符号表的地址偏移量，我们可定位到符号表，随后便可开始查找函数符号对应的表项，具体原理是使用fread()函数循环将各表项写入一个ElfN_Sym结构体中，并提取其中的st_info字段，使用ELFN_ST_TYPE()宏即可从该字段中解析得到该符号表项的类型，如果是STT_FUNC（函数符号对应的类型），则存储该表项的地址（st_value）与大小（st_size）。 同时，对于函数符号对应的表项，我们同样可以依据该表项的st_name字段，在符号名字表中定位并存储相应的函数名。 基于上述流程，即可完成对ELF文件的解析。\n函数调用与返回的判断 函数调用与返回的判断需要参考RISCV的ABI（Application Binary Interface，应用程序二进制接口，它定义了应用程序之间或应用程序和操作系统之间进行二进制级交互时必须遵循的规则和约定）。具体而言，RISCV的函数调用与返回主要涉及使用jal与jalr指令对ra寄存器进行写入与读取，包括：\n函数调用： 将当前发生函数调用的pc存储在ra中，主要分为两种情况： 使用jal，则指令应当形如jal ra func，将当前pc存储于ra后，直接跳转至func。 使用jalr，则指令应当形如jalr ra imm(rs1)，将当前pc存储于ra后，跳转至imm(rs1)指向的func。 函数返回： 读取ra存储的pc并跳转，RISCV有专用的伪指令ret用于函数返回，该指令展开后为：jalr zero 0(ra)。 因此，我们仅需在NEMU ISA的jal，jalr指令实现中增加对函数调用与函数返回的判断即可：\n1 2 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); INSTPAT(\u0026#34;??????? ????? ????? ??? ????? 11011 11\u0026#34;, jal , J, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = s-\u0026gt;pc + imm; if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); 对应地，我们需要在ELF文件中的函数符号解析完成后，增加对应的函数调用与返回的打印函数。\n尾调用的处理 单纯基于上述逻辑实现的ftrace无法处理函数的尾调用，因为函数发生尾调用时，不会将当前发生调用的pc存储在ra中，只会使用jalr zero 0(rs1)直接跳转至func。为实现对尾调用的追踪，我们需要增加以下三点功能：\n在NEMU ISA的jalr指令实现中增加对函数尾调用的判断： 1 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false); else if ((rd == 0) \u0026amp;\u0026amp; (imm == 0)) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, true)); 修改函数调用的打印函数print_call()，增加对尾调用的识别功能，当发生尾调用时，该函数会存储尾调用函数对应的调用深度、PC值至一个全局静态结构体数组中： 1 2 3 4 5 6 7 8 9 10 11 12 13 void print_call(vaddr_t pc, vaddr_t dnpc, bool tail) { int idx = check_func(dnpc); if (idx \u0026lt; 0) return; func_depth++; flog_write(FMT_PADDR \u0026#34;: %*scall [%s@\u0026#34; FMT_PADDR \u0026#34;]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name, dnpc); if (tail) { tail_hdr[tail_nr].pc = pc; tail_hdr[tail_nr++].depth = func_depth - 1; } } 修改函数返回的打印函数print_return()，增加对尾调用的处理，当调用该函数时，该函数会在存储尾调用函数的结构体数组中查找当前是否存在尾调用函数，若存在，则一并输出函数返回信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void print_return(vaddr_t pc) { int idx = check_func(pc); if (idx \u0026lt; 0) return; flog_write(FMT_PADDR \u0026#34;: %*sret [%s]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name); func_depth--; // tail call handler (recursion) if (tail_nr \u0026gt; 0) { if (tail_hdr[tail_nr-1].depth == func_depth) { tail_nr--; print_return(tail_hdr[tail_nr].pc); } } } 注意print_return()函数中对尾调用函数的查找是递归的，因为可能存在连续嵌套的尾调用。 ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/ftrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/ftrace/","title":"ftrace实现的注意事项"},{"content":"mtrace本身实现非常简单，此处仅列举在实现过程中遇到的若干细节：\nmtrace写入NEMU Log文件 对于mtrace这种大规模输出，我们不能仅通过printf()函数将其打印在终端上，而要将其写入NEMU的Log文件中，NEMU提供了一个log_write()函数用于实现这一点，它可将指定字符串写入NEMU的Log文件nemu-log.txt。\n这时我产生了一个疑问，在log_write()函数中并没有指定写入文件的参数，NEMU是如何通过该函数写入指定的Log文件呢？于是，我自然需要去查看log_write()的定义，在utils.h中：\n1 2 3 4 5 6 7 8 9 10 #define log_write(...) IFDEF(CONFIG_TARGET_NATIVE_ELF, \\ do { \\ extern FILE* log_fp; \\ extern bool log_enable(); \\ if (log_enable() \u0026amp;\u0026amp; log_fp != NULL) { \\ fprintf(log_fp, __VA_ARGS__); \\ fflush(log_fp); \\ } \\ } while (0) \\ ) 据此可见，log_write()函数只是一段宏定义，这里的文件通过log_fp指定，而log_fp受到extern关键字修饰，这说明它的定义来自其他的文件，我们继续搜索log_fp的定义，在log.c中：\n1 2 3 4 5 6 7 8 9 10 11 FILE *log_fp = NULL; void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } 据此可知，log_fp是通过init_log()函数赋值的，当通过init_log()指定NEMU的Log文件log_file，log_fp便会被赋值为指向该文件的指针，而init_log()函数在monitor.c中被调用，NEMU的Log文件是通过命令行参数-l指定的。\nmtrace的配置项 我们仿照itrace的配置项，给出了mtrace的基本配置项：\n1 2 3 4 5 6 7 8 9 config MTRACE depends on TRACE \u0026amp;\u0026amp; TARGET_NATIVE_ELF \u0026amp;\u0026amp; ENGINE_INTERPRETER bool \u0026#34;Enable memory tracer\u0026#34; default y config MTRACE_COND depends on MTRACE string \u0026#34;Only trace memory when the condition is true\u0026#34; default \u0026#34;true\u0026#34; 有关Kconfig的相关语法，可参考：Kconfig 语法分析详解。\n配置完成后，在启动mtrace记录访存行为时，我发现一个奇怪的现象，似乎依据Log文件的输出，每条指令都在访存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 [MTRACE-R]: [0x80000da4] --\u0026gt; 0x032 0x80000da4: 40 f7 07 b3 sub\ta5, a4, a5 [MTRACE-R]: [0x80000da8] --\u0026gt; 0x032 0x80000da8: 01 87 97 93 slli\ta5, a5, 0x18 [MTRACE-R]: [0x80000dac] --\u0026gt; 0x032 0x80000dac: 41 87 d7 93 srai\ta5, a5, 0x18 [MTRACE-R]: [0x80000db0] --\u0026gt; 0x032 0x80000db0: fe 07 80 e3 beqz\ta5, -0x20 [MTRACE-R]: [0x80000d90] --\u0026gt; 0x032 0x80000d90: 00 15 05 13 addi\ta0, a0, 1 [MTRACE-R]: [0x80000d94] --\u0026gt; 0x032 0x80000d94: 02 07 04 63 beqz\ta4, 0x28 [MTRACE-R]: [0x80000d98] --\u0026gt; 0x032 [MTRACE-R]: [0x800010a1] --\u0026gt; 0x008 0x80000d98: 00 05 c7 83 lbu\ta5, 0(a1) [MTRACE-R]: [0x80000d9c] --\u0026gt; 0x032 [MTRACE-R]: [0x80009fc1] --\u0026gt; 0x008 0x80000d9c: 00 05 47 03 lbu\ta4, 0(a0) [MTRACE-R]: [0x80000da0] --\u0026gt; 0x032 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 一开始我以为是mtrace功能上有bug，后来才恍然大悟，因为每条指令的取指都天然存在一次访存行为！但是，如讲义中所说，有时我可能只会关心某一段内存区间的访问，从而希望mtrace减少输出。因此，我又在Kconfig中增加了如下配置项：\n1 2 3 4 5 6 7 8 9 config MTRACE_MIN depends on MTRACE hex \u0026#34;Lower bound for memory tracing (unit: number of bytes)\u0026#34; default 0x00000000 config MTRACE_MAX depends on MTRACE hex \u0026#34;Upper bound for memory tracing (unit: number of bytes)\u0026#34; default 0xffffffff 这两个配置项限制了mtrace的追踪内存区间，其取值采用hex类型，因为我们通常习惯通过十六进制表示内存地址。\n","date":"2025-08-07T00:00:00Z","image":"https://posvirus.github.io/p/mtrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/mtrace/","title":"mtrace实现的注意事项"},{"content":"指令环形缓冲器（Instruction Ring Buffer, 下文简称IRB）的实现基于一个简化的环形缓冲器结构，具体而言，其可基于一个仅具有循环（覆盖）写入的队列实现，且队列单次写入的数据量均为1（即单个指令对应的反汇编输出）。基于上述分析，我们可定义如下的IRB：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define NR_RB 16 // instruction register typedef struct ireg { char logbuf[128]; int valid; } IReg; // instruction ring buffer typedef struct iringbuffer { IReg i_buf[NR_RB]; int end; } IRingBuffer; 上述代码中，一个固定容量为16的IRB由iringbuffer结构体定义，其中包含存储指令反汇编输出的结构体数组i_buf，以及用于存储当前写入的数组元素索引end，对于存储指令反汇编输出的结构体ireg，其包含定长字符数组logbuf与标记存储内容有效的指示位valid。\n以下，我们可以使用实现监视点的类似方法，直接例化一个全局静态的IRB，使NEMU可通过我们提供的接口对IRB进行操作：\n1 static IRingBuffer iring_buf; 对IRB的操作可分为三种：对IRB的初始化、对IRB的单次写入与IRB的内容输出。为此，我们定义了如下三种方法：\n1 2 3 4 5 6 7 8 // initialize instruction ring buffer void IRingBuffer_init(); // write one log into instruction ring buffer int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst); // print contents of instruction ring buffer void IRingBuffer_print(); IRingBuffer_init()函数实现如下：\n1 2 3 4 5 6 7 void IRingBuffer_init() { for (int i = 0; i \u0026lt; NR_RB; i++) { iring_buf.i_buf[i].valid = 0; } iring_buf.end = 0; Log(\u0026#34;Instruction ring buffer initialization success. Buffer storage: %d insts.\u0026#34;, NR_RB); }; IRB的初始化较为简单，我们仅需将i_buf所有元素的指示位置零，并将索引end指向数组首个元素即可。同时，IRB的初始化可在NEMU monitor的初始化函数init_monitor()中实现：\n1 2 /* Initialize the instruction ring buffer. */ IFDEF(CONFIG_ITRACE, IRingBuffer_init()); IRingBuffer_write()函数的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst) { // check illegal inst input if (inst == NULL) return -1; char *p = iring_buf.i_buf[iring_buf.end].logbuf; p += snprintf(p, sizeof(iring_buf.i_buf[iring_buf.end].logbuf), FMT_WORD \u0026#34;:\u0026#34;, pc); int i; int ilen = snpc - pc; #ifdef CONFIG_ISA_x86 for (i = 0; i \u0026lt; ilen; i++) { #else for (i = ilen - 1; i \u0026gt;= 0; i--) { #endif p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } int ilen_max = MUXDEF(CONFIG_ISA_x86, 8, 4); int space_len = ilen_max - ilen; if (space_len \u0026lt; 0) space_len = 0; space_len = space_len * 3 + 1; memset(p, \u0026#39; \u0026#39;, space_len); p += space_len; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, iring_buf.i_buf[iring_buf.end].logbuf + sizeof(iring_buf.i_buf[iring_buf.end].logbuf) - p, MUXDEF(CONFIG_ISA_x86, snpc, pc), inst, ilen); iring_buf.i_buf[iring_buf.end].valid = 1; // end pointer increment iring_buf.end = (iring_buf.end + 1) % NR_RB; return 0; }; 该函数接收当前取值的PC值pc、下一静态PC值snpc与当前取出的指令inst，并通过exec_once()函数中相同的解码方式将其转换为反汇编输出存储至i_buf中，并将对应指示位置位。随后，将数组索引递增，此处通过模运算使数组索引不发生越界，并实现覆盖写入的功能。\n我们可在isa_exec_once()函数中调用该函数，该函数应当在指令取指后立刻被调用，因为如果当前指令执行出错，我们也需要在NEMU异常退出前存储当前指令的反汇编输出：\n1 2 3 4 5 6 7 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); #ifdef CONFIG_ITRACE IRingBuffer_write(s-\u0026gt;pc, s-\u0026gt;snpc, (uint8_t *)\u0026amp;s-\u0026gt;isa.inst); #endif return decode_exec(s); } IRingBuffer_print()函数的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 void IRingBuffer_print() { for (int i = 0; i \u0026lt; NR_RB; i++) { if (iring_buf.i_buf[i].valid == 1) { if (((i + 1) % NR_RB) == iring_buf.end) { printf(\u0026#34; --\u0026gt; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } else { printf(\u0026#34; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } } } }; 此处，我们分两种情况打印i_buf中的反汇编输出，当((i + 1) % NR_RB) == iring_buf.end为真时，代表当前指令为程序发生异常时执行的指令（因为在写入反汇编输出后会对索引递增，故此处使用i+1），使用--\u0026gt;标识该指令，其余指令均正常打印即可。\n该函数可插入NEMU异常终止的所有程序段中，目前仅插入assert_fail_msg()函数中，后续可通过更多测试继续完善。\n","date":"2025-08-04T00:00:00Z","image":"https://posvirus.github.io/p/iringbuf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/iringbuf/","title":"指令环形缓冲器实现"},{"content":"在PA2中，笔者被要求实现一个简单的sprintf()函数，其目前仅需实现对%s与%d标识符的支持即可。此处，笔者对其进行了进一步增强，使其可支持更多种标识符，并具有扩展实现更多标识符的能力，其目前可支持的标识符列举如下：\n标识符 含义 %d 位宽不限的十进制有符号数 %u 位宽不限的十进制无符号数 %o 位宽不限的八进制无符号数 %x 位宽不限的十六进制无符号数（字母小写） %X 位宽不限的十六进制无符号数（字母小写） %lu 位宽不限的无符号整型 %llu 位宽不限的无符号长整型 %s 字符串 %c 单个字符 %p 指针地址 %% 字符% 此处，为保证sprintf()函数具有识别更多标识符的扩展性，在编写sprint()函数时采用了模块化设计，其设计原理类似于NEMU表达式求值中对表达式中token的提取，以下是具体实现：\nsprintf()函数分三个阶段，第一阶段是对含标识符字符串的解析，第二阶段是对标识符对应参数的转换，第三阶段则是目标字符串的生成。\n1 2 3 4 5 6 7 8 9 10 11 12 /* sprintf arguments */ enum { SP_CHAR, SP_UDEC, SP_UUSG, SP_UOCT, SP_Uhex, SP_UHEX, SP_ULOU, SP_ULLU, SP_USTR, SP_USCH, SP_UPTR, }; /* sprintf tokens */ typedef struct sp_token { int type; char str[256]; } SP_Token; 在第一阶段，我们首先定义了若干枚举变量，用于代表各种标识符类型（以及普通单字符），其次，我们定义结构体SP_Token，该结构体用于存储对含标识符字符串的解析结果，每个结构体代表从含标识符字符串解析出的一个token，包含该token的类型type（属于枚举变量中的一者）与token对应转换后的字符串str。\n1 2 static SP_Token sp_tokens[SP_NR_MAX] __attribute__((used)) = {}; static int nr_sp_token __attribute__((used)) = 0; 同时，我们在stdio.c中定义全局静态SP_Token数组sp_tokens，用于存储每次对含标识符字符串的解析结果，同时定义nr_sp_token指示当前解析结果的token数量。\n以下，我们定义静态函数sp_make_token()完成对含标识符字符串的解析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // %d, unlimited length decimal if (fmt[position] == \u0026#39;d\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UDEC; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %u, unlimited length unsign if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UUSG; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %o, unlimited length octal if (fmt[position] == \u0026#39;o\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UOCT; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %x, unlimited length hexadecimal (lower) if (fmt[position] == \u0026#39;x\u0026#39;) { sp_tokens[nr_sp_token].type = SP_Uhex; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %X, unlimited length hexadecimal (upper) if (fmt[position] == \u0026#39;X\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UHEX; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if(fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %lu, unlimited length uint32_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULOU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if (fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %llu, unlimited length uint64_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULLU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } return false; } // %s, unlimited length string if (fmt[position] == \u0026#39;s\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %c, single char if (fmt[position] == \u0026#39;c\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USCH; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %p, value of a pointer if (fmt[position] == \u0026#39;p\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UPTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %%, char \u0026#39;%\u0026#39; if (fmt[position] == \u0026#39;%\u0026#39;) { sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } 此处的解析逻辑与表达式求值中的token解析逻辑类似，只是此处我们实现的是基本的库函数，因此无法使用正则表达式进行快速匹配，需要逐字符进行判断。在该函数中，我们会将含标识符字符串顺序转换为token数组，同时指明各token类型type。对普通字符，我们在该函数中还会指明其token在标识符转换后的字符串str（因其无需转换，但是需要在普通字符后追加'\\0'）。\n完成token解析逻辑后，我们可在sprintf()函数中调用该函数，并进行第二、三阶段的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 int sprintf(char *out, const char *fmt, ...) { // detect invalid behavior if (!sp_make_token(fmt)) { return -1; } // va-args initialization va_list args; va_start(args, fmt); // args-to-string convert for (int i = 0; i \u0026lt; nr_sp_token; i++) { switch (sp_tokens[i].type) { case SP_CHAR: // directly skip break; case SP_UDEC: // str-to-dec convert str2sig(va_arg(args, int), sp_tokens[i].str, 10, false); break; case SP_UUSG: // str-to-unsign convert str2u(va_arg(args, unsigned int), sp_tokens[i].str); break; case SP_UOCT: // str-to-oct convert str2sig(va_arg(args, int), sp_tokens[i].str, 8, false); break; case SP_Uhex: // str-to-hex convert (lower) str2sig(va_arg(args, int), sp_tokens[i].str, 16, false); break; case SP_UHEX: // str-to-hex convert (upper) str2sig(va_arg(args, int), sp_tokens[i].str, 16, true); break; case SP_ULOU: // str-to-long-unsign convert str2lu(va_arg(args, size_t), sp_tokens[i].str); break; case SP_ULLU: // str-to-long-long-unsign convert str2llu(va_arg(args, unsigned long long), sp_tokens[i].str); break; case SP_USTR: // str copy strcpy(sp_tokens[i].str, va_arg(args, char *)); break; case SP_USCH: // char copy sp_tokens[i].str[0] = (char) va_arg(args, int); sp_tokens[i].str[1] = \u0026#39;\\0\u0026#39;; break; case SP_UPTR: // pointer value str2ptr(va_arg(args, void *), sp_tokens[i].str); break; default: // do nothing break; } } // end of args extraction va_end(args); // str-cat to result str strcpy(out, sp_tokens[0].str); for (int i = 1; i \u0026lt; nr_sp_token; i++) { strcat(out, sp_tokens[i].str); } return strlen(out); } 首先，我们会进行含标识符字符串的解析，并判断解析结果是否成功，若不成功，则返回一个负值（sprintf()函数的逻辑是，当函数执行成功，会返回打印字符串的长度，反之会返回一个负值）。\n其次，我们使用stdarg.h库中的相关函数，逐个解析标识符对应的参数并转换成字符串，赋值给对应token的str变量。此处需要实现多个数据类型向字符串转换的函数，由于笔者并不希望实现标准库中功能较复杂的转换函数，因此此处的函数均自由命名，并被声明为静态函数防止外部调用。\n我们可以简单以指针向字符串的转换函数为例进行说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 static char *str2ptr(void *num, char *re) { // avoid illegal input assert(re != NULL); char *pre = re; char num_buf[32] = {0}; // number buffer (fixed width) int ptr = 0; size_t unum = (size_t) num; size_t udiv; // NULL pointer if (num == NULL) { *pre = \u0026#39;(\u0026#39;; pre++; *pre = \u0026#39;n\u0026#39;; pre++; *pre = \u0026#39;i\u0026#39;; pre++; *pre = \u0026#39;l\u0026#39;; pre++; *pre = \u0026#39;)\u0026#39;; return re; } if (unum == 0) { re[0] = \u0026#39;0\u0026#39;; re[1] = \u0026#39;x\u0026#39;; re[2] = \u0026#39;0\u0026#39;; re[3] = \u0026#39;\\0\u0026#39;; return re; } *pre = \u0026#39;0\u0026#39;; pre++; *pre = \u0026#39;x\u0026#39;; pre++; // loop for conversion while (unum \u0026gt; 0) { udiv = unum % 16; if (udiv \u0026lt; 10) { num_buf[ptr++] = udiv + \u0026#39;0\u0026#39;; } else { num_buf[ptr++] = udiv - 10 + \u0026#39;a\u0026#39;; } unum = unum / 16; } // number order inversion for (int i = 0; i \u0026lt; ptr; i++) { *pre = num_buf[ptr-i-1]; pre++; } // add EOL *pre = \u0026#39;\\0\u0026#39;; return re; } 该函数接收指针num，并将字符串转换结果赋值给re，为此，首先我们需要判断指针num是否为NULL，如是，则按标准形式直接返回字符串(nil)；其次，我们将指针num强制类型转换为uint32_t类型变量unum（因为目前实现的处理器是32位地址）；最后，我们仅需将unum转换为字符串即可，这在实现上是简单的。同时需注意，指针地址为0x...的形式，以十六进制（小写）打印，在实现时需要额外增加逻辑。\n在第三阶段，我们仅需通过循环，使用strcat()函数将所有的token对应的字符串进行拼接即可（当然，对第一个token，我们需要使用strcpy()）。\n另外，我们额外编写了用于测试sprintf()函数的客户程序，其在native与NEMU下均可通过测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026#34;trap.h\u0026#34; char buf[128]; int main() { // basic string sprintf(buf, \u0026#34;%s\u0026#34;, \u0026#34;Hello world!\u0026#34;); check(strcmp(buf, \u0026#34;Hello world!\u0026#34;) == 0); // decimal format sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, 12806, 12923); check(strcmp(buf, \u0026#34;117 + 12806 = 12923\u0026#34;) == 0); sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, -12806, -12689); check(strcmp(buf, \u0026#34;117 + -12806 = -12689\u0026#34;) == 0); sprintf(buf, \u0026#34;0x%x in hex is %d\u0026#34;, 255, 255); check(strcmp(buf, \u0026#34;0xff in hex is 255\u0026#34;) == 0); // unsigned sprintf(buf, \u0026#34;%u\u0026#34;, 4294967295U); check(strcmp(buf, \u0026#34;4294967295\u0026#34;) == 0); // octal sprintf(buf, \u0026#34;Octal: %o\u0026#34;, 63); check(strcmp(buf, \u0026#34;Octal: 77\u0026#34;) == 0); // hexadecimal (case specify) sprintf(buf, \u0026#34;Hex lower: %x\u0026#34;, 255); check(strcmp(buf, \u0026#34;Hex lower: ff\u0026#34;) == 0); sprintf(buf, \u0026#34;Hex upper: %X\u0026#34;, 0xBCDAABCD); check(strcmp(buf, \u0026#34;Hex upper: BCDAABCD\u0026#34;) == 0); // unsigned long sprintf(buf, \u0026#34;Long: %lu\u0026#34;, 123456789UL); check(strcmp(buf, \u0026#34;Long: 123456789\u0026#34;) == 0); // unsigned long long sprintf(buf, \u0026#34;Long long: %llu\u0026#34;, 1234567890123456ULL); check(strcmp(buf, \u0026#34;Long long: 1234567890123456\u0026#34;) == 0); // char sprintf(buf, \u0026#34;Char: %c\u0026#34;, \u0026#39;A\u0026#39;); check(strcmp(buf, \u0026#34;Char: A\u0026#34;) == 0); // pointer volatile int *x = (volatile int *)0x0061fe1c; sprintf(buf, \u0026#34;Pointer: %p\u0026#34;, x); check(strcmp(buf, \u0026#34;Pointer: 0x61fe1c\u0026#34;) == 0); // NULL pointer sprintf(buf, \u0026#34;Null ptr: %p\u0026#34;, NULL); check(strcmp(buf, \u0026#34;Null ptr: (nil)\u0026#34;) == 0); // mixed format sprintf(buf, \u0026#34;Mixed: %d %s %c 0x%x\u0026#34;, 42, \u0026#34;test\u0026#34;, \u0026#39;Z\u0026#39;, 255); check(strcmp(buf, \u0026#34;Mixed: 42 test Z 0xff\u0026#34;) == 0); // boundary value sprintf(buf, \u0026#34;Min int: %d, Max uint: %u\u0026#34;, -2147483647-1, 4294967295U); check(strcmp(buf, \u0026#34;Min int: -2147483648, Max uint: 4294967295\u0026#34;) == 0); // special string sprintf(buf, \u0026#34;Newline: %s\u0026#34;, \u0026#34;a\\nb\u0026#34;); check(strcmp(buf, \u0026#34;Newline: a\\nb\u0026#34;) == 0); // char \u0026#39;%\u0026#39; sprintf(buf, \u0026#34;100%% guaranteed\u0026#34;); check(strcmp(buf, \u0026#34;100% guaranteed\u0026#34;) == 0); return 0; } 在测试指针的程序段中，我们对指针进行直接赋值，并通过volatile关键字防止编译器优化。\n","date":"2025-07-27T00:00:00Z","image":"https://posvirus.github.io/p/sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/sprintf/","title":"功能更强大的sprintf()函数"},{"content":"首先，通过RTFSC，我们发现NEMU的批处理模式是通过sdb.c中的一个变量is_batch_mode控制的：\n1 2 3 4 5 6 7 void sdb_mainloop() { if (is_batch_mode) { cmd_c(NULL); return; } /* other logic */ } 在sdb的主循环中，当这个变量为true时，会直接通过调用cmd_c()执行用户程序并返回，不再启动sdb。但是这个变量在当前文件声明的默认值为false，如何将其变为true呢？我们很快又会发现sdb_set_batch_mode()这个函数：\n1 2 3 void sdb_set_batch_mode() { is_batch_mode = true; } 不难发现，通过调用这个函数就可以让NEMU进入批处理模式！此时我们只需要寻找NEMU在什么位置调用了这个函数，不难发现它的调用位置在monitor.c的parse_args()函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static int parse_args(int argc, char *argv[]) { const struct option table[] = { {\u0026#34;batch\u0026#34; , no_argument , NULL, \u0026#39;b\u0026#39;}, {\u0026#34;log\u0026#34; , required_argument, NULL, \u0026#39;l\u0026#39;}, {\u0026#34;diff\u0026#34; , required_argument, NULL, \u0026#39;d\u0026#39;}, {\u0026#34;port\u0026#34; , required_argument, NULL, \u0026#39;p\u0026#39;}, {\u0026#34;help\u0026#34; , no_argument , NULL, \u0026#39;h\u0026#39;}, {0 , 0 , NULL, 0 }, }; int o; while ( (o = getopt_long(argc, argv, \u0026#34;-bhl:d:p:\u0026#34;, table, NULL)) != -1) { switch (o) { case \u0026#39;b\u0026#39;: sdb_set_batch_mode(); break; case \u0026#39;p\u0026#39;: sscanf(optarg, \u0026#34;%d\u0026#34;, \u0026amp;difftest_port); break; case \u0026#39;l\u0026#39;: log_file = optarg; break; case \u0026#39;d\u0026#39;: diff_so_file = optarg; break; case 1: img_file = optarg; return 0; default: printf(\u0026#34;Usage: %s [OPTION...] IMAGE [args]\\n\\n\u0026#34;, argv[0]); printf(\u0026#34;\\t-b,--batch run with batch mode\\n\u0026#34;); printf(\u0026#34;\\t-l,--log=FILE output log to FILE\\n\u0026#34;); printf(\u0026#34;\\t-d,--diff=REF_SO run DiffTest with reference REF_SO\\n\u0026#34;); printf(\u0026#34;\\t-p,--port=PORT run DiffTest with port PORT\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); exit(0); } } return 0; } 这段代码是用于解析init_monitor()函数传入的argc与argv参数的，而init_monitor()的argc与argv参数又是通过main()函数传递的，不难发现，当参数中包括-b一项时，就会使得NEMU进入批处理模式。\n那么，我们可以回忆一下，我们是如何运行NEMU的？似乎是通过Makefile构建一个run的目标实现的，因此，我们需要进一步去寻找run对应的构建规则，它在nemu/scripts/native.mk下：\n1 2 3 4 5 6 7 8 IMG ?= NEMU_EXEC := $(BINARY) $(ARGS) $(IMG) run-env: $(BINARY) $(DIFF_REF_SO) run: run-env $(call git_commit, \u0026#34;run NEMU\u0026#34;) $(NEMU_EXEC) 不难发现，当构建run这个目标时，会使用NEMU_EXEC构建NEMU，而参数又是通过ARGS来传递的，那么，当我们运行AM时，是通过什么方式传递ARGS参数的呢？在AM的scripts/platform/nemu.mk中，我们不难发现：\n1 2 3 4 5 6 NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt /* other logic */ run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin 因此，当AM运行NEMU时，会通过命令行直接传递ARGS参数，而对应需要传递的参数由NEMUFLAGS指定，因此，我们最终只需添加：\n1 NEMUFLAGS += -b 即可实现默认以批处理模式运行NEMU。在cpu-tests路径下重新运行一遍全部测试：\n1 make ARCH=riscv32-nemu run 发现确实在运行NEMU时不会再启用sdb了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # Building recursion-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/recursion.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/recursion-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/recursion-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/recursion-riscv32-nemu.bin, size = 728 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000026c [src/cpu/cpu-exec.c:92 statistic] host time spent = 4,025 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 4,545 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 1,129,192 inst/s # Building div-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/div.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/div-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/div-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/div-riscv32-nemu.bin, size = 404 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000124 [src/cpu/cpu-exec.c:92 statistic] host time spent = 877 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 868 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 989,737 inst/s ","date":"2025-07-24T00:00:00Z","image":"https://posvirus.github.io/p/batch/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/batch/","title":"如何让NEMU以批处理模式运行？"},{"content":"提供可读性更强的Makefile版本 1 2 3 html: cat Makefile | sed \u0026#39;s/^\\([^#]\\)/ \\1/g\u0026#39; | markdown_py \u0026gt; Makefile.html .PHONY: html 首先，该Makefile给出了一个html目标，用于生成可读性更强的Makefile，其具体实现原理是，首先通过cat以输出Makefile的所有内容至标准输出，并通过管道将其传递至sed指令，sed会通过正则表达式匹配所有非注释行，并将所有非注释行的第一个非#字符前加入四个空格。这时，该Makefile的所有注释行在Markdown语法中会被识别为标题；所有非注释行则会被识别为代码块（因为插入了四个空格）1。\n最后，再调用markdown_py将其转换为HTML格式，并重定向至Makefile.html中。\n基本配置与运行检查 1 2 3 4 ifeq ($(MAKECMDGOALS),) MAKECMDGOALS = image .DEFAULT_GOAL = image endif 首先，我们会检查Makefile执行的目标，这里通过一个环境变量MAKECMDGOALS引用，当该值为空时，说明我们仅输入了make，此时将MAKECMDGOALS设置为image，代表默认创建一个裸机镜像。同时将另一个环境变量.DEFAULT_GOAL也设置为image，请注意，.DEFAULT_GOALS会真正地将Makefile的执行目标设定为image，而我们此处将MAKECMDGOALS设置为image的目的是为了后续的配置与运行检查。\n1 2 3 4 ifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),) ... ### Checks end here endif 其次，我们会使用findstring检查MAKECMDGOALS是否是clean、clean-all、html中的一者，如果是，则该判断为false，我们会跳过该段运行环境检查，这里需要注意的是，ifeq与对应的endif离得很远，需要明确中间的语句均只有在判断为真的时候才执行。\n1 $(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)]) 在命令行中输出对应的构建模板，其中MAKECMDGOALS是该Makefile对应的构建目标，NAME是AM其他子目录下的Makefile定义的变量，比如在src下的Makefile对应的NAME为am，而ARCH则为在输入make时指令的架构变量，回忆PA2的前一节，我们在运行cpu-tests时使用过如下形式的make指令进行构建：\n1 make ARCH=$ISA-nemu ALL=dummy run 此处我们即指定了ARCH变量对应的值。\n1 2 3 ifeq ($(wildcard $(AM_HOME)/am/include/am.h),) $(error $$AM_HOME must be an AbstractMachine repo) endif 接着，Makefile会检查环境变量AM_HOME是否设置正确，此处主要使用wildcard查找am.h文件是否存在，如果存在则说明正确。\n1 2 3 4 ARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk))) ifeq ($(filter $(ARCHS), $(ARCH)), ) $(error Expected $$ARCH in {$(ARCHS)}, Got \u0026#34;$(ARCH)\u0026#34;) endif 随后，我们会检查通过命令行传输的架构信息ARCH是否在项目中存在对应的Makefile，为此，我们使用ls指令列举scripts子目录下的所有.mk文件，直接运行该指令的输出为：\n1 2 3 4 5 6 /home/chenwy/ysyx-workbench/abstract-machine/scripts/loongarch32r-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/mips32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv64-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/spike.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86_64-qemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-npc.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32mini-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-qemu.mk 我们使用notdir函数过滤文件前的文件夹路径，需要指出，notdir是一个Makfile函数而非bash指令。\n接着，我们使用basename指令（这是一条指令）获取这些文件的文件名，并将其赋值给ARCHS，代表AM目前支持的架构集合。进而，我们即可使用filter函数（这同样是一个Makefile函数）判断ARCH对应的架构是否存在于ARCHS中，如不存在则报错。\n1 2 3 ARCH_SPLIT = $(subst -, ,$(ARCH)) ISA = $(word 1,$(ARCH_SPLIT)) PLATFORM = $(word 2,$(ARCH_SPLIT)) 以下，确定架构有效后，我们可以使用subst函数将ARCH连接平台与ISA的连字符-替换为空格，再使用word函数分别提取对应的ISA（如riscv32等）与平台（nemu、qemu与npc等）。\n1 2 3 ifeq ($(flavor SRCS), undefined) $(error Nothing to build) endif 最后，我们使用flavor函数检查SRC，即需要构建的源文件是否被定义，若未定义则同样报错。\n此处需要指出，SRCS与之前的NAME类似，都是通过其他Makefile定义，再包含该Makefile给出的，因此我们事实上无法通过这个Makefile构建某个目标（当然html除外），而应当是其它Makefile调用该Makefile进行构建。\n至此，基本配置与运行检查完毕。\n编译目标定义 1 2 3 WORK_DIR = $(shell pwd) DST_DIR = $(WORK_DIR)/build/$(ARCH) $(shell mkdir -p $(DST_DIR)) 首先，我们定义工作目录WORK_DIR为当前目录，同时定义编译输出目录DST_DIR为工作目录下build目录中对应的$(ARCH)子目录，并使用mkdir -p创建该目录。\n1 2 3 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) ARCHIVE = $(WORK_DIR)/build/$(NAME)-$(ARCH).a 其次，IMAGE_REL定义了最终的可执行文件$(NAME)-$(ARCH)的相对路径，同时使用IMAGE调用abspath函数定义其绝对路径，ARCHIVE则定义了归档文件$(NAME)-$(ARCH).a对应的绝对路径。\n1 2 3 4 5 6 OBJS = $(addprefix $(DST_DIR)/, $(addsuffix .o, $(basename $(SRCS)))) LIBS := $(sort $(LIBS) am klib) # lazy evaluation (\u0026#34;=\u0026#34;) causes infinite recursions LINKAGE = $(OBJS) \\ $(addsuffix -$(ARCH).a, $(join \\ $(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))), \\ $(LIBS) )) 接着，我们定义了编译的输出中间文件文件路径OBJS，该定义首先通过basename指令获取SRCS的文件名，并使用addsuffix函数将文件后缀置为.o，随后使用addprefix将中间文件路径统一指定为输出目录DST_DIR下。\n而我们继续可以定义库文件所在路径LIBS，通过立即赋值:=可以避免该定义被递归展开2，同时使用sort避免重复定义，这是因为LIBS可能在其它Makefile中也被定义，因此可能本身就包含am或klib，故此处需要去重处理。\n最后，我们收集所有需要被链接的文件，包括OBJS以及归档文件（如am-$(ARCH).a、klib-$(ARCH).a）。\n这里需要对LINKAGE与ARCHIVE进行一个对比，LINKAGE是我们在生成裸机镜像时需要使用的，所有需要链接的文件，它包含了编译输出的所有中间文件OBJS以及LIBS对应的所有归档文件。而ARCHIVE对应的是一个局部性的概念，是指某一个文件夹调用该Makefile时，生成的归档文件（在该Makefile后续逻辑中我们会知道，生成裸机镜像image与生成归档文件archive是两个相对独立的目标）。因此，在PA2前一节我们运行cpu-tests时，对应的make输出如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Building am-archive [riscv32-nemu] + CC src/platform/nemu/trm.c + CC src/platform/nemu/ioe/ioe.c + CC src/platform/nemu/ioe/timer.c + CC src/platform/nemu/ioe/input.c + CC src/platform/nemu/ioe/gpu.c + CC src/platform/nemu/ioe/audio.c + CC src/platform/nemu/ioe/disk.c + CC src/platform/nemu/mpe.c + AS src/riscv/nemu/start.S + CC src/riscv/nemu/cte.c + AS src/riscv/nemu/trap.S + CC src/riscv/nemu/vme.c + AR -\u0026gt; build/am-riscv32-nemu.a # Building klib-archive [riscv32-nemu] + CC src/stdio.c + CC src/int64.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-riscv32-nemu.a + CC tests/dummy.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/dummy-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/dummy-riscv32-nemu.bin 我们可以知道，这个make其实包含三个步骤：\n第一步： 将am目录下的源文件编译，并打包为归档文件am-riscv32-nemu.a（即为ARCHIVE）。 第二步： 将klib目录下的源文件编译，并打包为归档文件klib-riscv32-nemu.a（即为ARCHIVE）。 第三步： 编译客户程序dummy.c，并将其与之前生成的归档文件一起链接为可执行文件（即为LINKAGE）。 编译选项设置 1 2 3 4 5 6 7 8 AS = $(CROSS_COMPILE)gcc CC = $(CROSS_COMPILE)gcc CXX = $(CROSS_COMPILE)g++ LD = $(CROSS_COMPILE)ld AR = $(CROSS_COMPILE)ar OBJDUMP = $(CROSS_COMPILE)objdump OBJCOPY = $(CROSS_COMPILE)objcopy READELF = $(CROSS_COMPILE)readelf 首先定义交叉编译所需的工具名，这里的CROSS_COMPILE在$(AM_HOME)/scripts/isa中的Makefile被定义。\n1 2 INC_PATH += $(WORK_DIR)/include $(addsuffix /include/, $(addprefix $(AM_HOME)/, $(LIBS))) INCFLAGS += $(addprefix -I, $(INC_PATH)) 随后定义包含的路径，包括当前路径下的include与AM库文件LIBS下的include，并在其前加入-I作为INCFLAGS供编译器使用。\n1 2 3 4 5 6 7 8 9 10 11 ARCH_H := arch/$(ARCH).h CFLAGS += -O2 -MMD -Wall -Werror $(INCFLAGS) \\ -D__ISA__=\\\u0026#34;$(ISA)\\\u0026#34; -D__ISA_$(shell echo $(ISA) | tr a-z A-Z)__ \\ -D__ARCH__=$(ARCH) -D__ARCH_$(shell echo $(ARCH) | tr a-z A-Z | tr - _) \\ -D__PLATFORM__=$(PLATFORM) -D__PLATFORM_$(shell echo $(PLATFORM) | tr a-z A-Z | tr - _) \\ -DARCH_H=\\\u0026#34;$(ARCH_H)\\\u0026#34; \\ -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \\ -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden CXXFLAGS += $(CFLAGS) -ffreestanding -fno-rtti -fno-exceptions ASFLAGS += -MMD $(INCFLAGS) LDFLAGS += -z noexecstack $(addprefix -T, $(LDSCRIPTS)) 这里定义具体的编译/链接选项，此处不作说明。\n1 -include $(AM_HOME)/scripts/$(ARCH).mk 同时，我们包含ARCH架构的Makefile，对前面的选项进行进一步配置。\n目标构建规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ### Rule (compile): a single `.c` -\u0026gt; `.o` (gcc) $(DST_DIR)/%.o: %.c @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CC $\u0026lt; @$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cc` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cc @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cpp` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cpp @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.S` -\u0026gt; `.o` (gcc, which preprocesses and calls as) $(DST_DIR)/%.o: %.S @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + AS $\u0026lt; @$(AS) $(ASFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (recursive make): build a dependent library (am, klib, ...) $(LIBS): %: @$(MAKE) -s -C $(AM_HOME)/$* archive ### Rule (link): objects (`*.o`) and libraries (`*.a`) -\u0026gt; `IMAGE.elf`, the final ELF binary to be packed into image (ld) $(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS) @echo \\# Creating image [$(ARCH)] @echo + LD \u0026#34;-\u0026gt;\u0026#34; $(IMAGE_REL).elf ifneq ($(filter $(ARCH),native),) @$(CXX) -o $@ -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX) else @$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group endif ### Rule (archive): objects (`*.o`) -\u0026gt; `ARCHIVE.a` (ar) $(ARCHIVE): $(OBJS) @echo + AR \u0026#34;-\u0026gt;\u0026#34; $(shell realpath $@ --relative-to .) @$(AR) rcs $@ $^ ### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD` -include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS)))) 这部分是具体的目标构建规则，不作赘述。\n构建顺序定义 1 2 3 4 5 image: image-dep archive: $(ARCHIVE) image-dep: $(LIBS) $(IMAGE).elf .NOTPARALLEL: image-dep .PHONY: image image-dep archive run $(LIBS) 这部分定义了各个目标的依赖关系，当我们构建裸机镜像image时，需要首先构建$(LIBS)及$(IMAGE).elf，$(IMAGE).elf的构建依赖于LINKAGE，这包含了OBJS与LIBS对应的归档文件两部分，构建$(LIBS)时，我们便会使用make archive创建其对应的归档文件。而OBJS的构建则依赖于目标构建规则中的单文件编译。\n至此，我们大致梳理了AM的Makefile架构及实现原理。\n简书Markdown用法：4个空格标记代码块的说明\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMakefile中:=, =, ?=和+=的含义\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-07-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-1/","title":"AM Makefile解读（1）"},{"content":"首先，exec_once()会接收Decode结构体指针 s，以及当前的PC值pc，pc比较好理解，它通常是通过CPU_state结构体cpu中的pc成员传递的，RV32 ISA的CPU_state结构体定义在isa-def.h中：\n1 2 3 4 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); 包含一个寄存器堆与PC寄存器，可以这样说，CPU_state结构体定义了处理器核的状态。\nDecode结构体被定义在decode.h中：\n1 2 3 4 5 6 7 typedef struct Decode { vaddr_t pc; vaddr_t snpc; // static next pc vaddr_t dnpc; // dynamic next pc ISADecodeInfo isa; IFDEF(CONFIG_ITRACE, char logbuf[128]); } Decode; 其定义了当前PC值，以及该指令执行后的下一PC值（这里暂时不说明静态/动态有什么区别），其次，它还定义了一个ISADecodeInfo结构体成员isa，其定义在isa-def.h中：\n1 2 3 typedef struct { uint32_t inst; } MUXDEF(CONFIG_RV64, riscv64_ISADecodeInfo, riscv32_ISADecodeInfo); 不难看出，这其实就是当前的指令。\nexec_once()接收这两个参数后，会首先将CPU的当前PC值pc传递至s中，并将s中的当前PC值与下一静态PC值均设为CPU的当前PC值pc。\n随后，exec_once()会调用isa_exec_once()函数，并将s传递进入该函数，该函数执行完成后，代表当前指令执行完成，随后exec_once()会将s中的下一动态PC值dnpc置为CPU的当前PC值pc，代表执行完成。\n因此，完成指令执行的核心函数是isa_exec_once()，它被定义在inst.c中：\n1 2 3 4 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); return decode_exec(s); } 其使用inst_fetch()获取当前指令（IF），并使用decode_exec()进行指令译码（ID）与执行（EX）。\ninst_fetch()定义在ifetch.h中：\n1 2 3 4 5 static inline uint32_t inst_fetch(vaddr_t *pc, int len) { uint32_t inst = vaddr_ifetch(*pc, len); (*pc) += len; return inst; } 它实际上首先读取了当前PC值对应的指令（并返回），并将s的下一静态PC值加4。其中vaddr_ifetch()定义在vaddr.c中，它目前就是一条简单的读取内存的指令。\n这里，我们就可以理解下一静态PC值与下一动态PC值的区别，下一静态PC值是指在物理存储上，存储于当前指令后的下一条指令的地址，在以字节编址的32位CPU上，成立snpc = pc + 4，下一动态PC值则是在当前指令真正执行完成后，对应的下一PC值，由于跳转指令的存在，其与下一静态PC值并不一定一致。\ndecode_exec()中有较多的宏定义，此处我们修改NEMU的Makefile，使其可以通过：\n1 make raw 输出NEMU各文件对应的预处理文件，在inst.i中，即可获得对应宏展开的结果。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/exec-once/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/exec-once/","title":"exec_once()函数执行逻辑"},{"content":"div指令 1 2 3 4 5 6 7 8 9 10 11 12 XReg src1 = X[rs1]; XReg src2 = X[rs2]; XReg signed_min = (xlen() == 32) ? $signed({1\u0026#39;b1, {31{1\u0026#39;b0}}}) : {1\u0026#39;b1, {63{1\u0026#39;b0}}}; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else if ((src1 == signed_min) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG / -1) X[rd] = signed_min; } else { X[rd] = $signed(src1) / $signed(src2); } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 100 ????? 01100 11\u0026#34;, div , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (~(word_t)0) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (min_val) : ((sword_t)(src1) / (sword_t)(src2)))); divu指令 1 2 3 4 5 6 7 8 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else { X[rd] = src1 / src2; } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 101 ????? 01100 11\u0026#34;, divu , R, R(rd) = (src2 == 0) ? (~(word_t)0) : (src1 / src2)); rem指令 1 2 3 4 5 6 7 8 9 10 11 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = src1; } else if ((src1 == {1\u0026#39;b1, {MXLEN - 1{1\u0026#39;b0}}}) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG % -1) X[rd] = 0; } else { X[rd] = $signed(src1) % $signed(src2); } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 110 ????? 01100 11\u0026#34;, rem , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (src1) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (0) : ((sword_t)(src1) % (sword_t)(src2)))); remu指令 1 2 3 4 5 6 7 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { X[rd] = src1; } else { X[rd] = src1 % src2; } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 111 ????? 01100 11\u0026#34;, remu , R, R(rd) = (src2 == 0) ? (src1) : (src1 % src2)); ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/riscv32m/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/riscv32m/","title":"RV32M扩展指令的执行逻辑"},{"content":"在使用-march=rv32im_zicsr对测试程序进行编译时，会发现测试对应的除法与取余操作（有符号/无符号）不能被正确编译至div等RV32M扩展指令，原以为是指令集架构选择错误，后续发现是因为当除数是常量时，（如a / 10），编译器可能用更高效的移位/乘法序列替代除法指令或取余指令，为防止该优化，可以在变量声明前加入volatile关键字，指示该变量随时可变，从而限制其优化。\n以下给出一个可以正确编译出RV32M扩展指令的测试程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;trap.h\u0026#34; #define N 10 int signed_arr[N] = {-128, -486, -312, -211, -154, 0, 11113, 26785, 3232, 488976}; unsigned unsigned_arr[N] = {0, 1112, 25678, 33425, 43455, 543421, 634567, 778789, 845653, 92442}; int main() { for (int i = 0; i \u0026lt; N; i++) { for (volatile int j = -N; j \u0026lt;= N; j++) { if (j == 0) { continue; } int quotient, remainder; quotient = signed_arr[i] / j; remainder = signed_arr[i] % j; check(signed_arr[i] == j * quotient + remainder); if (signed_arr[i] \u0026gt;= 0) { check(remainder \u0026gt;= 0 \u0026amp;\u0026amp; remainder \u0026lt; (j \u0026gt; 0 ? j : -j)); } else { check(remainder \u0026lt;= 0 \u0026amp;\u0026amp; remainder \u0026gt; (j \u0026gt; 0 ? -j : j)); } } } for (int i = 0; i \u0026lt; N; i++) { for (volatile unsigned j = 1; j \u0026lt;= N; j++) { unsigned quotient, remainder; quotient = unsigned_arr[i] / j; remainder = unsigned_arr[i] % j; check(unsigned_arr[i] == j * quotient + remainder); check(remainder \u0026lt; j); } } // overflow test volatile int dividend = 1 \u0026lt;\u0026lt; 31; volatile int divisor = -1; int quotient = dividend / divisor; int remainder = dividend % divisor; check(quotient == dividend); check(remainder == 0); return 0; } 对应编译结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 80000000 \u0026lt;_start\u0026gt;: 80000000:\t00000413 li\ts0,0 80000004:\t00009117 auipc\tsp,0x9 80000008:\tffc10113 addi\tsp,sp,-4 # 80009000 \u0026lt;_end\u0026gt; 8000000c:\t1e0000ef jal\tra,800001ec \u0026lt;_trm_init\u0026gt; 80000010 \u0026lt;check\u0026gt;: 80000010:\t00050463 beqz\ta0,80000018 \u0026lt;check+0x8\u0026gt; 80000014:\t00008067 ret 80000018:\tff010113 addi\tsp,sp,-16 8000001c:\t00100513 li\ta0,1 80000020:\t00112623 sw\tra,12(sp) 80000024:\t1bc000ef jal\tra,800001e0 \u0026lt;halt\u0026gt; 80000028 \u0026lt;main\u0026gt;: 80000028:\tfd010113 addi\tsp,sp,-48 8000002c:\t02912223 sw\ts1,36(sp) 80000030:\t03212023 sw\ts2,32(sp) 80000034:\t01312e23 sw\ts3,28(sp) 80000038:\t01412c23 sw\ts4,24(sp) 8000003c:\t02112623 sw\tra,44(sp) 80000040:\t02812423 sw\ts0,40(sp) 80000044:\t01512a23 sw\ts5,20(sp) 80000048:\t00000917 auipc\ts2,0x0 8000004c:\t20490913 addi\ts2,s2,516 # 8000024c \u0026lt;signed_arr\u0026gt; 80000050:\t00000a17 auipc\ts4,0x0 80000054:\t224a0a13 addi\ts4,s4,548 # 80000274 \u0026lt;unsigned_arr\u0026gt; 80000058:\tff600993 li\ts3,-10 8000005c:\t00a00493 li\ts1,10 80000060:\t01312023 sw\ts3,0(sp) 80000064:\t00012783 lw\ta5,0(sp) 80000068:\t06f4c663 blt\ts1,a5,800000d4 \u0026lt;main+0xac\u0026gt; 8000006c:\t00012783 lw\ta5,0(sp) 80000070:\t04078863 beqz\ta5,800000c0 \u0026lt;main+0x98\u0026gt; 80000074:\t00092a83 lw\ts5,0(s2) 80000078:\t00012503 lw\ta0,0(sp) 8000007c:\t00012403 lw\ts0,0(sp) 80000080:\t00012783 lw\ta5,0(sp) 80000084:\t02aac533 div\ta0,s5,a0 80000088:\t028ae433 rem\ts0,s5,s0 8000008c:\t02f50533 mul\ta0,a0,a5 80000090:\t00850533 add\ta0,a0,s0 80000094:\t41550533 sub\ta0,a0,s5 80000098:\t00153513 seqz\ta0,a0 8000009c:\tf75ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000a0:\t00000513 li\ta0,0 800000a4:\t120ac063 bltz\ts5,800001c4 \u0026lt;main+0x19c\u0026gt; 800000a8:\t00044a63 bltz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800000ac:\t00012783 lw\ta5,0(sp) 800000b0:\t00012503 lw\ta0,0(sp) 800000b4:\t10f05463 blez\ta5,800001bc \u0026lt;main+0x194\u0026gt; 800000b8:\t00a42533 slt\ta0,s0,a0 800000bc:\tf55ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000c0:\t00012783 lw\ta5,0(sp) 800000c4:\t00178793 addi\ta5,a5,1 800000c8:\t00f12023 sw\ta5,0(sp) 800000cc:\t00012783 lw\ta5,0(sp) 800000d0:\tf8f4dee3 bge\ts1,a5,8000006c \u0026lt;main+0x44\u0026gt; 800000d4:\t00490913 addi\ts2,s2,4 800000d8:\tf94914e3 bne\ts2,s4,80000060 \u0026lt;main+0x38\u0026gt; 800000dc:\t00000917 auipc\ts2,0x0 800000e0:\t19890913 addi\ts2,s2,408 # 80000274 \u0026lt;unsigned_arr\u0026gt; 800000e4:\t00000a17 auipc\ts4,0x0 800000e8:\t1b8a0a13 addi\ts4,s4,440 # 8000029c \u0026lt;_bss_start\u0026gt; 800000ec:\t00100993 li\ts3,1 800000f0:\t00a00493 li\ts1,10 800000f4:\t01312223 sw\ts3,4(sp) 800000f8:\t00412783 lw\ta5,4(sp) 800000fc:\t04f4e863 bltu\ts1,a5,8000014c \u0026lt;main+0x124\u0026gt; 80000100:\t00092a83 lw\ts5,0(s2) 80000104:\t00412503 lw\ta0,4(sp) 80000108:\t00412403 lw\ts0,4(sp) 8000010c:\t00412783 lw\ta5,4(sp) 80000110:\t02aad533 divu\ta0,s5,a0 80000114:\t028af433 remu\ts0,s5,s0 80000118:\t02f50533 mul\ta0,a0,a5 8000011c:\t00850533 add\ta0,a0,s0 80000120:\t41550533 sub\ta0,a0,s5 80000124:\t00153513 seqz\ta0,a0 80000128:\tee9ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000012c:\t00412503 lw\ta0,4(sp) 80000130:\t00a43533 sltu\ta0,s0,a0 80000134:\teddff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000138:\t00412783 lw\ta5,4(sp) 8000013c:\t00178793 addi\ta5,a5,1 80000140:\t00f12223 sw\ta5,4(sp) 80000144:\t00412783 lw\ta5,4(sp) 80000148:\tfaf4fee3 bgeu\ts1,a5,80000104 \u0026lt;main+0xdc\u0026gt; 8000014c:\t00490913 addi\ts2,s2,4 80000150:\tfb4912e3 bne\ts2,s4,800000f4 \u0026lt;main+0xcc\u0026gt; 80000154:\t800007b7 lui\ta5,0x80000 80000158:\t00f12423 sw\ta5,8(sp) 8000015c:\tfff00793 li\ta5,-1 80000160:\t00f12623 sw\ta5,12(sp) 80000164:\t00812503 lw\ta0,8(sp) 80000168:\t00c12783 lw\ta5,12(sp) 8000016c:\t00812403 lw\ts0,8(sp) 80000170:\t00c12703 lw\ta4,12(sp) 80000174:\t02f54533 div\ta0,a0,a5 80000178:\t00812783 lw\ta5,8(sp) 8000017c:\t02e46433 rem\ts0,s0,a4 80000180:\t40f50533 sub\ta0,a0,a5 80000184:\t00153513 seqz\ta0,a0 80000188:\te89ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000018c:\t00143513 seqz\ta0,s0 80000190:\te81ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000194:\t02c12083 lw\tra,44(sp) 80000198:\t02812403 lw\ts0,40(sp) 8000019c:\t02412483 lw\ts1,36(sp) 800001a0:\t02012903 lw\ts2,32(sp) 800001a4:\t01c12983 lw\ts3,28(sp) 800001a8:\t01812a03 lw\ts4,24(sp) 800001ac:\t01412a83 lw\ts5,20(sp) 800001b0:\t00000513 li\ta0,0 800001b4:\t03010113 addi\tsp,sp,48 800001b8:\t00008067 ret 800001bc:\t40a00533 neg\ta0,a0 800001c0:\tef9ff06f j\t800000b8 \u0026lt;main+0x90\u0026gt; 800001c4:\tee804ce3 bgtz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800001c8:\t00012783 lw\ta5,0(sp) 800001cc:\t00012503 lw\ta0,0(sp) 800001d0:\t00f05463 blez\ta5,800001d8 \u0026lt;main+0x1b0\u0026gt; 800001d4:\t40a00533 neg\ta0,a0 800001d8:\t00852533 slt\ta0,a0,s0 800001dc:\tee1ff06f j\t800000bc \u0026lt;main+0x94\u0026gt; 800001e0 \u0026lt;halt\u0026gt;: 800001e0:\t00050513 mv\ta0,a0 800001e4:\t00100073 ebreak 800001e8:\t0000006f j\t800001e8 \u0026lt;halt+0x8\u0026gt; 800001ec \u0026lt;_trm_init\u0026gt;: 800001ec:\tff010113 addi\tsp,sp,-16 800001f0:\t00000517 auipc\ta0,0x0 800001f4:\t01c50513 addi\ta0,a0,28 # 8000020c \u0026lt;_etext\u0026gt; 800001f8:\t00112623 sw\tra,12(sp) 800001fc:\te2dff0ef jal\tra,80000028 \u0026lt;main\u0026gt; 80000200:\t00050513 mv\ta0,a0 80000204:\t00100073 ebreak 80000208:\t0000006f j\t80000208 \u0026lt;_trm_init+0x1c\u0026gt; ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/div/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/div/","title":"关于div等RV32M指令无法编译的问题"},{"content":"在NPC中使用C++实现存储器时，对NEMU中的存储器写入/读出函数有了一些新的认识，现总结如下：\n此处我们为方便说明，仅考查与物理存储器直接交互的函数，即pmem，NEMU首先在paddr.c中定义了两个static函数，分别为pmem_read()与pmem_write()，用于对pmem进行直接读写。\n同时，因为这两个函数被声明为static，其无法通过其他文件访问/调用，因此paddr.c中还定义了外部访问的接口paddr_read()与paddr_write()，这两个函数会对输入的地址进行有效性检测，随后再通过调用pmem_read()与pmem_write()实现存储器访问。\n我们再看pmem_read()与pmem_write()的具体实现：\n对pmem_read()：\n1 2 3 4 static word_t pmem_read(paddr_t addr, int len) { word_t ret = host_read(guest_to_host(addr), len); return ret; } 该函数内部会嵌套调用两个函数，guest_to_host()与host_read()，其中guest_to_host()用于将输入的pmem的物理地址addr转换成实际PC存储器中的地址，实现如下：\n1 uint8_t* guest_to_host(paddr_t paddr) { return pmem + paddr - CONFIG_MBASE; } 具体实现原理即为通过pmem所在的基址，加上paddr - CONFIG_MBASE的偏移量，即获得了对应的PC存储器地址，其中CONFIG_BASE代表pmem的最低地址。\n同时注意，由于该函数输出的是字节编址的实际PC存储器地址，因此对应的返回类型是uint8_t*，为一个无符号字节类型的指针。\n再看host_read()的实现，在host.h中：\n1 2 3 4 5 6 7 8 9 static inline word_t host_read(void *addr, int len) { switch (len) { case 1: return *(uint8_t *)addr; case 2: return *(uint16_t *)addr; case 4: return *(uint32_t *)addr; IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr); default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0); } } 这里其实是依据读出字节数len的取值，对实际PC存储器地址进行强制类型转换，并通过解引用*获取对应的值，比如当len = 2时，代表需要读取2字节数据，因此我们将addr强制类型转换为uint16_t*类型，使其指向一个双字节存储空间，再通过解引用获得该存储空间对应的值。\npaddr_write()的实现原理类似，此处不作赘述。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/nemu-memory/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-memory/","title":"关于NEMU存储器访问的细节"},{"content":"在使用Verilator对RTL代码进行仿真时，其仿真原理与普通RTL代码编写的Testbench存在差异，具体而言，在Verilator中，仿真步长这一概念是需要通过wrapper文件自行控制的，我们需要明确仿真在哪些时间点需要采样并eval()，而在传统RTL代码编写的Testbench中，仿真步长通常是通过timescale声明的，EDA会识别并自动设置仿真步长。\n这种原理上的差异会造成Verilator与传统EDA在仿真时存在两方面的区别：\n性能上的差异： Verilator的仿真原理其实可概括为“当用户需要时，才对某个时间点采样与eval()”，而传统EDA的仿真原理则可简单理解为“定步长对每个时间点都进行采样与eval()“。因此，Verilator相对而言可以较敏捷地完成仿真，因为在仿真过程中，其实并没有对所有时间点均进行采样与eval()。 波形质量上的差异： 传统EDA的定步长仿真使得其仿真获得的波形具有相当高的可信度，基本可以与实测波形等同。但Verilator的波形质量高度依赖于wrapper文件的写法，一个低质量或写法错误的wrapper文件完全有可能生成与实际情况完全不同的波形，举一个简单的例子，假设我们一直仅对模块进行激励而不调用eval()，那么波形不会有任何有效信息，更具体一些，如果我们改变某个端口的激励值而未及时进行eval()，可能导致某个信号值在波形中被错误地延迟一个或多个时钟周期。 因此，有必要探究有效的wrapper文件写法，因为当我们需要通过波形对模块进行debug时，我们自然不希望最后发现是wrapper文件的写法导致生成不符合预期的波形。\n首先，我们需要明确，在wrapper文件中，其主要实现了两类操作，第一是实现激励信号的变化并重新对被测模块进行eval()，第二则是实现波形中时间的推移，为此，我们给出一个模式化的wrapper文件写法：\n1 2 3 #define Vtop Vysyx_25070184_top // nickname #define CLK_NAME clk // clock name #define CLK_HALF_PERIOD 5 // clock period / 2 在文件开头，我们实现了几个宏定义，将被测顶层模块名统一为top，将时钟名称统一为CLK_NAME，并定义仿真时的半时钟周期长度CLK_HALF_PERIOD。\n1 2 #define EDGE_TRG_EVENT(top, event) do { top-\u0026gt;CLK_NAME = !top-\u0026gt;CLK_NAME; top-\u0026gt;eval(); event; top-\u0026gt;eval(); } while (0) #define EDGE_TRG(top) EDGE_TRG_EVENT(top, ) 其次，我们实现了另外两个宏定义，用于实现激励信号的变化，EDGE_TRG_EVENT宏用于实现一个被时钟边沿驱动的事件event，其主要会进行如下两个操作：\n翻转当前时钟取值，进行eval()。 执行事件event，再次进行eval()。 这个宏定义其实相当于传统RTL实现的Testbench中的@(posedge/negedge clk) event;。\n另外一个宏定义EDGE_TRG则相当于仅对时钟进行翻转并eval()，而不存在其他事件的执行。\n最后，我们定义另外一个函数half_cycle()实现波形时间的推移：\n1 2 3 4 5 void half_cycle(Vtop* top, VerilatedContext* contextp, VerilatedFstC *tfp) { top-\u0026gt;eval(); contextp-\u0026gt;timeInc(CLK_HALF_PERIOD); tfp-\u0026gt;dump(contextp-\u0026gt;time()); } 该函数会在波形中产生半时钟周期的时间推移，因为在狭义的同步时序电路中，半时钟周期相当于一个最小的时间步长，在这一时间间隔内不应当有任何信号存在变化。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/verilator/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/verilator/","title":"浅析Verilator的wrapper文件写法"}]
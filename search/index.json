[{"content":"RT-Thread上下文创建 首先，我们考虑RT-Thread中的上下文创建函数rt_hw_stack_init()的实现，观察其参数列表：\n1 rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) 该函数接收一个栈底指针stack_addr用于构建上下文，同时保证该上下文入口为tentry，参数为parameter，并返回这个上下文结构的指针。此外，若上下文对应的内核线程从tentry返回，则调用texit。\n这里首先需要解释，为什么在AM中，我们不允许内核线程从tentry返回：这主要是因为，入口为tentry的上下文是人工构造的，而在AM中构造上下文的功能函数kcontext()中，我们并没有为该入口构造相应的返回地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Context *kcontext(Area kstack, void (*entry)(void *), void *arg) { // instantiate a context Context *ret = (Context *)(kstack.end - sizeof(Context)); // create entry ret-\u0026gt;mepc = (uintptr_t)entry; // reset mstatus ret-\u0026gt;mstatus = (uintptr_t)0x1800; // function argument ret-\u0026gt;gpr[10] = (uintptr_t)arg; // other GPR settings ret-\u0026gt;gpr[0] = (uintptr_t)0; // $0 register ret-\u0026gt;gpr[2] = (uintptr_t)ret; // $sp register // return context pointer return ret; } 所以线程一旦从tentry返回，将会跳转至非法的地址，从而导致程序非法运行。\n回到rt_hw_stack_init()函数，首先，我们需要对输入的stack_addr进行对齐：\n1 2 3 4 /* align the incoming stack pointer */ rt_uint8_t *stk; stk = stack_addr + sizeof(uintptr_t); stk = (rt_uint8_t *)RT_ALIGN_DOWN((uintptr_t)stk, sizeof(uintptr_t)); 此处我们以sizeof(uintptr_t)为最小单位，对该地址进行向下对齐（因为栈底在内存分布上位于高位地址），而RT_ALIGN_DOWN是RT-Thread内部定义的宏。\n随后，由于对kcontext()函数而言，其接收的用于构建上下文的参数只有栈空间分布kstack，上下文入口entry以及向入口传递的参数arg，但是RT-Thread中的还存在一个texit参数，这就导致，我们需要构造一个包裹函数，这里称为tentry_wrapper()：\n1 2 3 4 5 6 7 static void tentry_wrapper(void *arg) { struct wrapper_args *stk_arg = (struct wrapper_args *)arg; // call tentry(parameter) first ((void (*)(void *))stk_arg-\u0026gt;tentry)(stk_arg-\u0026gt;parameter); // if return, call texit() ((void (*)())stk_arg-\u0026gt;texit)(); } 该包裹函数的作用是，接收一个void *类型的参数arg，该参数在函数内被强制类型转换为一个结构体类型wrapper_args，该类型包括三个字段：\n1 2 3 4 5 struct wrapper_args { void *tentry; void *texit; void *parameter; }; 其中tentry即为上下文的入口，parameter即为上下文入口tentry对应的参数，texit即为线程如果在tentry返回的话需要调用的函数，进而我们可以在tentry_wrapper()函数中先对tentry进行调用，随后对texit进行调用，这样一旦tentry返回，随后会调用texit进行处理。\n有了tentry_wrapper()函数，我们在创建上下文时实际上就可以通过如下形式调用kcontext()函数：\n1 kcontext([kstack], tentry_wrapper, [arg]); 以下，我们需要考虑的是kcontext()函数的另外两个参数应该如何设定，首先考虑arg参数，对于tentry_wrapper()函数，我们需要传递一个指向一个wrapper_args结构体的指针，这里就涉及到该结构体如何创建及存储的问题，不妨先在rt_hw_stack_init()函数中先初始化一个wrapper_args结构体：\n1 2 3 4 5 /* allocate function arguments */ struct wrapper_args tmp_args; tmp_args.tentry = tentry; tmp_args.texit = texit; tmp_args.parameter = parameter; 随后，我们需要确定该结构体存储的位置，首先，这个结构体肯定不能以临时变量进行存储，因为rt_hw_stack_init()函数实际上起到一个初始化上下文的功能，所以该函数中的临时变量是无法在程序的整个生命周期中都存在的。因此，一个合适的方法，就是将这个结构体复制到该上下文所在的栈上，此处可以直接先从栈底开始分配空间：\n1 2 3 4 5 6 /* re-allocate the stack pointer */ size_t arg_size = sizeof(struct wrapper_args); stk = stk - arg_size; /* Copy wrapper arguments to stack */ memcpy(stk, \u0026amp;tmp_args, arg_size); 此时，我们将stk下移sizeof(struct wrapper_args)，并调用memcpy()函数将结构体复制到这一段空间中，此时stk一方面指向的就是栈上存储的结构体，另一方面stk也可以作为kstack参数对应栈空间的栈底，以使kcontext()函数可以以stk为栈底构建上下文，于是rt_hw_stack_init()函数的剩余部分可以作如下实现：\n1 2 3 4 5 /* create stack area */ Area stack_area = { .end = stk }; /* return context pointer */ return (rt_uint8_t *)kcontext(stack_area, tentry_wrapper, (void *)stk); RT-Thread的上下文切换 为实现RT-Thread的上下文切换，我们需要实现3个函数：\n1 void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to); 首先，是rt_hw_context_switch()函数，其包含from与to两个参数，其都是指向上下文指针变量的指针（二级指针）。 它用于切换到to指向的上下文指针变量所指向的上下文，并将当前上下文的指针写入from指向的上下文指针变量中。\n1 void rt_hw_context_switch_to(rt_ubase_t to); 其次，是rt_hw_context_switch_to()函数，它只包含to一个参数，仅实现切换到to指向的上下文指针变量所指向的上下文这一功能，那么，该函数显然可以复用rt_hw_context_switch()实现：\n1 2 3 4 void rt_hw_context_switch_to(rt_ubase_t to) { // reuse function rt_hw_context_switch((rt_ubase_t)NULL, to); } 最后，我们需要实现RT-Thread对应的事件处理回调函数ev_handler()：\n1 static Context* ev_handler(Event e, Context *c); 通过上述分析，我们其实仅需实现rt_hw_context_switch()函数与ev_handler()函数即可，首先考查前者的实现：按PA讲义的说法，为了进行上下文切换, 我们可以通过yield()触发一次自陷, 在事件处理回调函数ev_handler()中识别出代处理事件后, 再处理to和from，为此，我们需要将to与from参数传递至ev_handler()。\n由于无法通过函数参数传递的方式传递to与from，同时也不适合直接通过全局变量的方式传递（多线程时存在风险），因此，我们考虑使用进程控制块（PCB, process control block）存储to与from，因为这一数据结构为各线程所独有，不会存在多线程的冲突。在RT-Thread中，PCB对应的结构体名称为rt_thread_t，可通过rt_thread_self()获取当前线程对应的PCB。\n1 rt_thread_t current = rt_thread_self(); 同时，rt_thread_t结构体中存在user_data字段，用于存储当前线程的私有用户数据，我们可以将to与from存储于该字段中：\n1 2 3 4 5 6 7 8 /* create private user data copy */ rt_ubase_t temp_user_data = current-\u0026gt;user_data; /* passing arguments */ rt_ubase_t param[2]; param[0] = to; param[1] = from; current-\u0026gt;user_data = (rt_ubase_t)param; 此处，我们还需要另外定义一个临时变量temp_user_data，作为当前线程原始user_data字段的备份。随后，我们便可调用yield()函数实现上下文切换，当切换回当前上下文时（即yield()返回时），再将临时变量内的user_data字段恢复：\n1 2 3 4 yield(); /* recover user data */ current-\u0026gt;user_data = temp_user_data; 随后，考虑事件处理回调函数ev_handler()的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static Context* ev_handler(Event e, Context *c) { rt_thread_t current; rt_ubase_t* param; switch (e.event) { case EVENT_YIELD: current = rt_thread_self(); param = (rt_ubase_t*)current-\u0026gt;user_data; rt_ubase_t to = param[0]; rt_ubase_t from = param[1]; if (from) *((Context **)from) = c; c = *(Context **)to; break; case EVENT_IRQ_TIMER: break; default: // printf(\u0026#34;Unhandled event ID = %d\\n\u0026#34;, e.event); } return c; } 阅读AM CTE的实现可知，事件处理回调函数是在上下文真正发生切换之前被调用的，因此，我们仍可通过rt_thread_self()函数获取当前的PCB，并提取from与to字段。\n","date":"2025-10-21T00:00:00Z","image":"https://posvirus.github.io/p/rt-thread/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rt-thread/","title":"RT-Thread的上下文"},{"content":"特权级与异常响应机制的关系 在PA3中，讲义同时引入了特权级与异常响应机制这两个概念，以下将简单阐述这两者之间的关系：\n以RISC-V架构为例：首先，RISC-V 定义了多个特权级（如Machine模式、Supervisor模式、User模式），权限逐级降低。用户程序通常在最低特权级（U模式）运行，无法直接访问关键系统资源，而当用户程序试图执行非法操作（如访问受保护内存、执行特权指令）时，会触发一个异常或中断。而此时，异常作为进入高特权级的入口，CPU会自动从当前特权级陷入（Trap）到一个预定义的更高特权级（通常是S模式或M模式）。\n其次，在更高特权级下，操作系统拥有足够的权限来分析异常原因、采取相应措施（如终止非法程序、调度其他任务等）。处理完毕后，操作系统通过特殊的返回指令（如 sret 或 mret）将控制权交还给用户程序，并返回到原来的特权级和程序断点继续执行。\nNEMU中CSR的实现 CSR本质仍为寄存器，因此在实现时与通用寄存器（GPR）类似，首先，我们可在CPU_state结构体中补充定义CSR：\n1 2 3 4 5 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; word_t csr[4]; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); 由于我们目前仅使用了mstatus，mepc，mcause与mtvec这4个CSR，因此仅例化4个CSR实例即可。\n同时，我们仿照GPR的实现，定义针对CSR的访问函数与宏：\n1 2 3 4 5 6 7 8 9 10 11 /* CSRs name mapping */ enum { MSTATUS = 0, MEPC, MCAUSE, MTVEC, }; static inline int check_csr_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; 4)); return idx; } #define csr(idx) (cpu.csr[check_csr_idx(idx)]) 同时，由于在RISC-V架构中，对各个CSR有唯一的编址，因此我们还需实现CSR编址与数组索引的映射：\n1 2 3 4 5 6 7 8 9 10 11 static inline int csr_addr_map(int addr) { switch (addr) { case 0x300: return MSTATUS; // Machine Status Registers case 0x305: return MTVEC; // Machine Trap-Vector Base-Address Register case 0x341: return MEPC; // Machine Exception Program Counter case 0x342: return MCAUSE; // Machine Cause Register default: printf(\u0026#34;Illegal CSR\u0026#39;s index: %03x!\\n\u0026#34;, addr); return -1; } } #define csr_map(addr) (csr(csr_addr_map(addr))) 此时，我们可以使用：\n1 csr_map(addr) 访问编址为addr的CSR，也可以使用：\n1 csr(NAME) 直接访问名称为NAME的CSR，如csr(MSTATUS)访问的即为mstatus。\n利用上述实现，我们可以很容易地在NEMU中实现与异常响应以及CSR相关的指令，包括ecall，mret，csrrw，csrrs。同时，在实现指令的过程中，可能涉及对CSR的位操作，因此，我们补充定义了如下2个宏：\n1 2 #define BITRST(x, bit) (x \u0026amp; ~(1u \u0026lt;\u0026lt; bit)) #define BITTO(x, src, tgt) (BITRST(x, tgt) | (((x \u0026gt;\u0026gt; src) \u0026amp; 1u) \u0026lt;\u0026lt; tgt)) 其中，BITRST(x, y)可以将x二进制表示中的第y位置零，BITTO(x, s, t)可以将x二进制表示中的第s位赋值给第t位。\nyield test的执行流程 首先，我们给出yield test的完整代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;amtest.h\u0026gt; Context *simple_trap(Event ev, Context *ctx) { switch(ev.event) { case EVENT_IRQ_TIMER: putch(\u0026#39;t\u0026#39;); break; case EVENT_IRQ_IODEV: putch(\u0026#39;d\u0026#39;); break; case EVENT_YIELD: putch(\u0026#39;y\u0026#39;); break; default: panic(\u0026#34;Unhandled event\u0026#34;); break; } return ctx; } void hello_intr() { printf(\u0026#34;Hello, AM World @ \u0026#34; __ISA__ \u0026#34;\\n\u0026#34;); printf(\u0026#34; t = timer, d = device, y = yield\\n\u0026#34;); io_read(AM_INPUT_CONFIG); iset(1); while (1) { for (volatile int i = 0; i \u0026lt; 1000000; i++) ; yield(); } } 当主函数调用hello_intr()函数并运行至yield()函数时，触发自陷操作，将发生如下行为：\n首先，yield()函数被执行，其行为如下：\n1 2 3 4 5 6 7 void yield() { #ifdef __riscv_e asm volatile(\u0026#34;li a5, -1; ecall\u0026#34;); #else asm volatile(\u0026#34;li a7, -1; ecall\u0026#34;); #endif } 可知，该函数会执行ecall指令。而ecall指令会配置mstatus，依据当前系统所处的模式将异常号保存在mcause中，保存当前的PC至mepc中（此处默认系统在M模式中，异常号为11），并跳转至mtvec中存储的地址，开始异常响应流程，这里ecall指令的逻辑是在NEMU中实现的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 word_t isa_raise_intr(word_t NO, vaddr_t epc) { /* TODO: Trigger an interrupt/exception with \u0026#39;NO\u0026#39;. * Then return the address of the interrupt/exception vector. */ /* TODO: correctly set mstatus register */ csr(MSTATUS) = BITTO(csr(MSTATUS), 3, 7); // MPIE = MIE csr(MSTATUS) = BITRST(csr(MSTATUS), 3); // MIE = 0 csr(MEPC) = epc; csr(MCAUSE) = NO; return csr(MTVEC); } 1 INSTPAT(\u0026#34;0000000 00000 00000 000 00000 11100 11\u0026#34;, ecall , N, NEMUERROR(s-\u0026gt;pc, s-\u0026gt;dnpc, 11)); 1 2 3 #define NEMUERROR(thispc, nextpc, code) do { \\ nextpc = isa_raise_intr(code, thispc); \\ } while (0) 为什么yield()函数中会有li a5, -1这一条指令：因为对于RISC-V架构而言，ecall指令本身不带参数，但是不同类型的异常都需要通过同样的ecall实现，为了方便操作系统区分异常类型，我们就需要通过额外的寄存器对其进行标识。\n更具体的内容可以参考：https://www.cnblogs.com/cilinmengye/p/18986213\n那么，程序是如何保证mtvec中存储的地址一定是指向异常响应的程序段的呢？这是通过cte_init()函数实现的：\n1 2 3 4 5 6 7 8 9 bool cte_init(Context*(*handler)(Event, Context*)) { // initialize exception entry asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; : : \u0026#34;r\u0026#34;(__am_asm_trap)); // register event handler user_handler = handler; return true; } 读该函数可知，程序随后会跳转至__am_asm_trap这一程序段所在位置，而该程序段由trap.S中的汇编程序给出，首先，其会对程序的上下文（所有GPR，CSR）进行压栈：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 .align 3 .globl __am_asm_trap __am_asm_trap: addi sp, sp, -CONTEXT_SIZE MAP(REGS, PUSH) csrr t0, mcause csrr t1, mstatus csrr t2, mepc STORE t0, OFFSET_CAUSE(sp) STORE t1, OFFSET_STATUS(sp) STORE t2, OFFSET_EPC(sp) # set mstatus.MPRV to pass difftest li a0, (1 \u0026lt;\u0026lt; 17) or t1, t1, a0 csrw mstatus, t1 随后，该程序段会调用__am_irq_handle()函数，该函数需要接收一个Context *类型的参数，因此我们使用mv指令，将栈指针sp作为参数传递给该函数，因为此时sp指向的正是先前通过压栈组织起的上下文结构体。\n1 2 mv a0, sp call __am_irq_handle 而__am_irq_handle()函数会执行如下操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Context* __am_irq_handle(Context *c) { if (user_handler) { Event ev = {0}; switch (c-\u0026gt;mcause) { case 11: #ifdef __riscv_e if (c-\u0026gt;gpr[15] == -1) { // $a5 #else if (c-\u0026gt;gpr[17] == -1) { // $a7 #endif ev.event = EVENT_YIELD; // software: jump to next instruction c-\u0026gt;mepc += 4; break; } else { ev.event = EVENT_SYSCALL; break; } default: ev.event = EVENT_ERROR; break; } c = user_handler(ev, c); assert(c != NULL); } return c; } 此时，该函数会调用user_handler()函数，处理不同类型的异常，异常的类型是通过上下文结构体中保存的mcause以及GPR中保存的标识共同解析的，而此时的user_handler()函数被赋值为simple_trap()函数（在am-tests的主函数中首先将simple_trap()函数传参给cte_init()函数，随后在该函数中赋值user_handler()函数）。\n同时，对于自陷操作，ecall指令在mepc中保存的是自陷操作本身所在的PC, 因此软件需要对保存的PC加上4, 使得将来返回到自陷操作的下一条指令。\nsimple_trap()函数完成执行后，会一直返回至__am_asm_trap程序段调用__am_irq_handle()函数的位置，并开始恢复上下文，将上下文中的GPR与CSR逐个弹栈：\n1 2 3 4 5 6 7 8 9 LOAD t1, OFFSET_STATUS(sp) LOAD t2, OFFSET_EPC(sp) csrw mstatus, t1 csrw mepc, t2 MAP(REGS, POP) addi sp, sp, CONTEXT_SIZE mret 完成上下文恢复后，最后调用mret指令跳转回mepc所存储的地址，也就是最初执行ecall时的PC+4，而经过while (1)的死循环，又会重新运行到yield()函数，进而无限重复先前所述的流程，在程序运行结果中表现为不断调用simple_trap()函数并输出y。\n","date":"2025-10-14T00:00:00Z","image":"https://posvirus.github.io/p/yield/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/yield/","title":"NEMU异常响应机制的实现"},{"content":"NEMU对RV32E架构的适配 在原始的NEMU中，如果尝试使用RV32E架构的NEMU运行NEMU，会直接报错，为修复这一问题，我们需要对NEMU做如下修改：\n首先，在am-kernels/kernels/nemu文件夹中的Makefile中，我们通过build_am目标构建可在AM上运行的NEMU：\n1 2 3 4 build_am: $(MAKE) -C $(NEMU_HOME) $(ISA)-am_defconfig $(MAKE) -C $(NEMU_HOME) ARCH=$(ARCH) mainargs=$(mainargs) || \\ ($(MAKE) restore_config; false) 而这一依赖项会查找NEMU项目中的$(ISA)-am_defconfig文件，而目前NEMU项目的configs目录下缺少riscv32e-am_defconfig文件，需要予以补充：\n1 2 3 4 CONFIG_TARGET_AM=y # CONFIG_TRACE is not set CONFIG_MSIZE=0x2000000 CONFIG_DEVICE=y 随后，对于NEMU而言，其构建的可执行文件的名称，是通过NEMU项目根目录下Makefile的如下代码：\n1 2 3 GUEST_ISA ?= $(call remove_quote,$(CONFIG_ISA)) ENGINE ?= $(call remove_quote,$(CONFIG_ENGINE)) NAME = $(GUEST_ISA)-nemu-$(ENGINE) 以及AM项目根目录下Makefile的如下代码联合指定的：\n1 2 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) 这里的CONFIG_ISA在Kconfig中只会被配置为riscv32，而使用该架构的E扩展是通过CONFIG_RVE来配置的，这就导致，在NEMU项目的build目录下，生成的可执行文件为riscv32-nemu-interpreter-riscv32e-nemu.bin，随后我们会通过：\n1 2 3 4 5 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin 在NEMU上运行NEMU，但这里存在一个问题，这里指定的可执行文件中，ISA是在ARCH中提取的，因此如果我们输入ARCH=riscv32e-nemu的话，实际提取的ISA=riscv32e，这就导致riscv32e-nemu-interpreter-riscv32e-nemu.bin并不存在，因此，我们可以对该Makefile稍作修改，使其可以正常执行功能：\n1 2 3 4 5 6 7 8 9 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config @if [ \u0026#34;$(ISA)\u0026#34; = \u0026#34;riscv32e\u0026#34; ]; then \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/riscv32-nemu-interpreter-$(ARCH).bin; \\ else \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin; \\ fi AM程序的运行逻辑 如果我们在am-kernels/kernels/nemu/目录下，执行\n1 make ARCH=$ISA-nemu mainargs=$executable_file_path 这会让我们在NEMU上运行一个载入可执行程序镜像的NEMU，假设我们利用此方法运行am-kernels/kernels目录下的打字游戏，那么打字游戏是如何实现配置外层NEMU的设备进行读取按键/刷新屏幕的呢？此处将简单进行说明：\n首先，此时整个系统的层次如下：\n1 [OUTER NEMU]--\u0026gt;[INNER NEMU]--\u0026gt;[TYPING-GAME] 打字游戏的可执行文件镜像将被加载至内层NEMU中，而内存NEMU的可执行文件镜像又被加载至外层NEMU中。\n因此，当打字游戏首先调用IOE API实现设备配置时，由于其运行在内层NEMU上，因此其会调用内层NEMU设备的回调函数：\n1 [OUTER NEMU DEVICE] ??? [INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] 但是，内层NEMU设备是如何将配置传递给外层NEMU的呢？这就涉及到当定义CONFIG_TARGET_AM时，内存NEMU设备的回调函数行为会重新被定义，比如，对于VGA而言，其更新屏幕的逻辑如下：\n1 2 3 4 5 static void init_screen() {} static inline void update_screen() { io_write(AM_GPU_FBDRAW, 0, 0, vmem, screen_width(), screen_height(), true); } 可知，内层NEMU此时也调用了IOE API，而由于其运行在外层NEMU上，此处的IOE API便会调用外层设备的回调函数，而此时API的作用也是将自身设备的配置传递给外层NEMU的设备，比如这里的update_screen()函数，其行为即是将整个页面按照vmem的取值更新。\n1 [OUTER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] ","date":"2025-10-11T00:00:00Z","image":"https://posvirus.github.io/p/nemu-run-nemu/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-run-nemu/","title":"使用RV32E架构的NEMU运行NEMU"},{"content":"设备实时时钟的实现 在PA2中，我们只被要求实现AM_TIMER_UPTIME，即系统启动后的微秒数，而此处为了更好的展示效果，我们将实现AM_TIMER_RTC，实现对当前真实时间的读取。\n在AM的timer.c中我们可以看到，rtc共有second、minute、hour、day、month与year共6个字段，为此，我们需要在NEMU的中为这些字段分配相应的空间，但是，如果我们为每个字段都分配一个32位的空间，时钟设备的地址空间会与其它设备产生交叠，但我们又不希望修改整个地址空间映射，应该如何解决这个问题呢？\n我们注意到，second、minute、hour、day、month这些字段，它们的取值其实非常有限，以至于我们分配8位/16位的空间给它们就足够了，所以，我们通过下面这种方式，将这6个字段压缩至2个32位空间中：\n1 2 // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] 于是我们仅需再为时钟申请8个字节的地址空间即可：\n1 2 3 4 5 6 7 8 9 void init_timer() { rtc_port_base = (uint32_t *)new_space(16); #ifdef CONFIG_HAS_PORT_IO add_pio_map (\u0026#34;rtc\u0026#34;, CONFIG_RTC_PORT, rtc_port_base, 16, rtc_io_handler); #else add_mmio_map(\u0026#34;rtc\u0026#34;, CONFIG_RTC_MMIO, rtc_port_base, 16, rtc_io_handler); #endif IFNDEF(CONFIG_TARGET_AM, add_alarm_handle(timer_intr)); } 而对于这些字段的赋值，我们调用time.h中的time()函数获取当前时间，并调用localtime()函数将其格式化即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void rtc_io_handler(uint32_t offset, int len, bool is_write) { assert(offset == 0 || offset == 4 || offset == 8 || offset == 12); if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { uint64_t us = get_time(); rtc_port_base[0] = (uint32_t)us; rtc_port_base[1] = us \u0026gt;\u0026gt; 32; time_t timep; struct tm *p; time(\u0026amp;timep); p = localtime(\u0026amp;timep); // rtc register allocation // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] rtc_port_base[2] = (((uint32_t)p-\u0026gt;tm_year) \u0026lt;\u0026lt; 16) | ((uint32_t)p-\u0026gt;tm_sec); rtc_port_base[3] = (((uint32_t)p-\u0026gt;tm_mon) \u0026lt;\u0026lt; 24) | (((uint32_t)p-\u0026gt;tm_mday) \u0026lt;\u0026lt; 16) | (((uint32_t)p-\u0026gt;tm_hour) \u0026lt;\u0026lt; 8) | ((uint32_t)p-\u0026gt;tm_min); } } 最后，我们即可在AM中的timer.c中实现字段的解码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void __am_timer_rtc(AM_TIMER_RTC_T *rtc) { // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] uint32_t time_cmb0 = inl(RTC_ADDR + 8); uint32_t time_cmb1 = inl(RTC_ADDR + 12); rtc-\u0026gt;second = (int)(time_cmb0 \u0026amp; ((uint32_t)0xffffu)); rtc-\u0026gt;minute = (int)(time_cmb1 \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;hour = (int)((time_cmb1 \u0026gt;\u0026gt; 8) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;day = (int)((time_cmb1 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;month = 1 + (int)((time_cmb1 \u0026gt;\u0026gt; 24) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;year = 1900 + (int)((time_cmb0 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffffu)); } 此处，我们需要注意，localtime()函数解码后的tm_year字段是相对1900年经过的年份，tm_mon字段则将12个月编码为0-11。\n另外，我们需要解释一下为什么rtc_io_handler()中会存在如下语句：\n1 if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { } 这是因为对AM而言，读取AM_TIME_UPTIME时：\n1 2 3 4 5 6 7 8 9 void __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) { // read RTC register uint32_t time_msb = inl(RTC_ADDR + 4); uint32_t time_lsb = inl(RTC_ADDR); ; // convert to uptime uptime-\u0026gt;us = (((uint64_t)time_msb) \u0026lt;\u0026lt; 32) + (uint64_t)time_lsb; } 我们会分别对该时间的高32位与低32位进行读取，而我们只希望rtc_io_handler()函数中的us在读取高32位（即offset为4）时进行更新，因为如果us在两次读取中均进行更新，假设读取高32位时us对应取值为{32'h0, 32'hffffffff}，而读取低32位时us对应取值为{32'h1, 32'h00001234}，那么我们最终读取的结果就是{32'h0, 32'h00001234}，这显然与真实值存在较大的误差。因此，我们让us只在第一次读取时（此处为读取高32位）进行更新，以保证读取结果的正确性。\n对于AM_TIME_RTC而言，我们也做了类似的处理，只不过因为AM_TIME_RTC的最小时间单位为秒，所以发生上述错误的几率小了许多。\n功能更强大的sprintf()函数 在运行设备测试时，我们需要在klib中实现功能更强大的I/O输出函数，为此，我们需要对先前实现的sprintf()函数进行优化，优化主要集中在两方面：\n首先，需要完整实现stdio.c中的函数，这涉及到对当前已实现函数的重构与复用。 其次，需要增加打印函数的功能，其需要识别前导0与固定位宽的标识符，如%02d，因为在设备测试中会使用到该功能。 stdio.c中库函数的完整实现 在原来的stdio.c实现中，我们直接对sprintf()函数进行实现，而没有实现剩余的函数，但是通过探究发现，将函数的功能主体集中于sprintf()函数中实现并不是最优选项，为追求函数实现的可复用性，一个较好的实现策略如下：\n首先，实现vsprintf()函数，该函数会接收一个va_list变量来对输入中的标识符进行例化。\n其次，基于vsprintf()函数，实现sprintf()函数与printf()函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int printf(const char *fmt, ...) { char buf[STR_MAX]; // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(buf, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); // put string to terminal putstr(buf); return strlen(buf); } 1 2 3 4 5 6 7 8 9 10 11 12 int sprintf(char *out, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(out, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); return strlen(out); } 此时，我们只需要将sprintf()函数的可变输入创建为一个va_list变量，随后调用vsprintf()函数即可。printf()函数也同理，我们只需利用vsprintf()函数将输出暂存于一个字符数组中，随后使用putstr()宏将其输出即可。\n最后，基于vsprintf()函数，实现vsnprintf()函数，并基于vsnprintf()函数实现snprintf()函数即可，复用方法类似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int vsnprintf(char *out, size_t n, const char *fmt, va_list ap) { char buf[STR_MAX]; if (vsprintf(buf, fmt, ap) \u0026lt; 0) return -1; if (n == 0) return strlen(buf); strncpy(out, buf, n-1); out[n-1] = \u0026#39;\\0\u0026#39;; // ensure there is an EOL return strlen(buf); } int snprintf(char *out, size_t n, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); int ret = vsnprintf(out, n, fmt, args); // end of args extraction va_end(args); return ret; } 打印函数的功能扩展 为了增加对前导0与固定位宽的识别功能，我们需要扩展stdio.c中存储标识符的结构体SP_Token：\n1 2 3 4 5 6 typedef struct sp_token { int type; char str[256]; int len; // limited string length (unlimited len = -1) bool pad; // 1: \u0026#39;0\u0026#39;; 0: \u0026#39; \u0026#39;; (only used in number) } SP_Token; 这里为其增加了2个字段，len代表该标识符对应实际字符串的长度（不限制长度则取-1），pad则代表使用空格还是0进行前导填充。\n随后，在sp_make_token()函数中，我们需要在识别到%字符后，补充对前导0与固定位宽的识别逻辑，随后再进行后续识别：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // set initial state sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; // %0, zero filled number if (fmt[position] == \u0026#39;0\u0026#39;) { sp_tokens[nr_sp_token].pad = true; position = position + 1; } // limited length data if ((fmt[position] \u0026gt; \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { int str_len = (int)(fmt[position] - \u0026#39;0\u0026#39;); // MSB position = position + 1; while ((fmt[position] \u0026gt;= \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { str_len = 10 * str_len + (int)(fmt[position] - \u0026#39;0\u0026#39;); position = position + 1; } sp_tokens[nr_sp_token].len = str_len; } /* ... */ return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } 最后，在将标识符对应输入参数映射为字符串后，我们需要额外依据标识符结构体中的len与pad字段为其添加前导填充：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static char *cutstr(char *re, int len, bool pad) { int str_len = strlen(re); if ((len == -1) || (len \u0026lt;= str_len)) return re; char buf[256]; memset(buf, (pad) ? (\u0026#39;0\u0026#39;) : (\u0026#39; \u0026#39;), len - str_len); buf[len - str_len] = \u0026#39;\\0\u0026#39;; if ((re[0] == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; (pad)) { // negative number with \u0026#39;0\u0026#39; filling strcat(buf, re + 1); strcpy(re + 1, buf); } else { strcat(buf, re); strcpy(re, buf); } return re; } 这里需要注意，对于负数，其前导填充如果是空格，则填充在负号前；如果是0，则填充在负号与数字之间。\n","date":"2025-10-05T00:00:00Z","image":"https://posvirus.github.io/p/rtc-and-sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rtc-and-sprintf/","title":"设备实时时钟与更强大的sprintf()函数"},{"content":"NEMU中设备初始化的流程 NEMU中各设备的初始化遵循一个统一的流程，以下将作简要说明：\n首先，设备会调用new_space()函数，这会从I/O地址空间中分配指定大小的空间给该设备，该函数在map.c中实现：\n1 2 3 4 5 6 7 8 9 10 11 static uint8_t *io_space = NULL; static uint8_t *p_space = NULL; uint8_t* new_space(int size) { uint8_t *p = p_space; // page aligned; size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; p_space += size; assert(p_space - io_space \u0026lt; IO_SPACE_MAX); return p; } 为解释该函数的作用，我们首先需要明确map.c中另一个函数init_map()的作用，该函数在device.c中的init_device()函数中被调用，用于初始化I/O地址空间，在完成初始化后才会调用各设备的初始化函数，将地址空间分配给各个设备。\n1 2 3 4 5 void init_map() { io_space = malloc(IO_SPACE_MAX); assert(io_space); p_space = io_space; } 这里init_map()函数通过malloc()函数创建了一个大小为IO_SPACE_MAX的空间，并将p_space与io_space均指向该空间起始位置。这里p_space实际用于指示当前未分配空间的起始位置，io_space则始终执行I/O地址空间的起始位置。\n注意，I/O地址空间在NEMU整个生命周期中都需要存在，且当NEMU退出时，操作系统会自动回收所有分配的内存，所以我们无需手动释放动态分配的空间。\n随后在设备初始化中调用new_space()函数，它会首先将p_space赋值给指针p，即将p指向当前未分配空间的起始位置，也是即将分配给该设备空间的初始位置。随后，我们对size进行向上取整的操作，使size变为PAGE_SIZE的整数倍：\n1 size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; 我们可以结合实际简要理解这段代码，假设PAGE_SIZE取1ul \u0026lt;\u0026lt; 12（即4096），这里size + (PAGE_SIZE - 1)的操作确保了：\n当size为PAGE_SIZE整数倍时，size + (PAGE_SIZE - 1)仍在当前页的范围内。 当size不为PAGE_SIZE整数倍时，size + (PAGE_SIZE - 1)会进入下一页的范围内。 随后，利用PAGE_MASK，我们可以将size + (PAGE_SIZE - 1)二进制表示中的低若干位清零，从而实现取整的操作，比如PAGE_SIZE取1ul \u0026lt;\u0026lt; 12时，PAGE_MASK可取(1ul \u0026lt;\u0026lt; 12) - 1，该数二进制表示的低12位均为0，从而与该数按位与后一定是PAGE_SIZE的倍数，且size + (PAGE_SIZE - 1)的操作保证最终分配的空间大小一定不小于原始请求的大小。\n完成对齐后，我们可以移动p_space指针，将size大小的空间标记为已分配，同时检查是否有足够的空间可以分配，如有，则返回指针p，代表空间分配完成。\n随后，设备会调用add_mmio_map()函数（这里我们只考虑MMIO），这一函数在mmio.c中实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static IOMap maps[NR_MAP] = {}; static int nr_map = 0; static void report_mmio_overlap(const char *name1, paddr_t l1, paddr_t r1, const char *name2, paddr_t l2, paddr_t r2) { panic(\u0026#34;MMIO region %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;] is overlapped \u0026#34; \u0026#34;with %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, name1, l1, r1, name2, l2, r2); } /* device interface */ void add_mmio_map(const char *name, paddr_t addr, void *space, uint32_t len, io_callback_t callback) { assert(nr_map \u0026lt; NR_MAP); paddr_t left = addr, right = addr + len - 1; if (in_pmem(left) || in_pmem(right)) { report_mmio_overlap(name, left, right, \u0026#34;pmem\u0026#34;, PMEM_LEFT, PMEM_RIGHT); } for (int i = 0; i \u0026lt; nr_map; i++) { if (left \u0026lt;= maps[i].high \u0026amp;\u0026amp; right \u0026gt;= maps[i].low) { report_mmio_overlap(name, left, right, maps[i].name, maps[i].low, maps[i].high); } } maps[nr_map] = (IOMap){ .name = name, .low = addr, .high = addr + len - 1, .space = space, .callback = callback }; Log(\u0026#34;Add mmio map \u0026#39;%s\u0026#39; at [\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, maps[nr_map].name, maps[nr_map].low, maps[nr_map].high); nr_map ++; } 这一函数主要创建一个IOMap结构体，该结构体存储了内存地址空间与I/O地址空间的映射关系，它的定义在map.h中：\n1 2 3 4 5 6 7 8 typedef struct { const char *name; // we treat ioaddr_t as paddr_t here paddr_t low; paddr_t high; void *space; io_callback_t callback; } IOMap; 主要包括以下字段：\nname：设备名称。 low/high：用于映射的内存地址空间的上/下边界。 space：指向设备I/O地址空间起始位置的指针。 callback：设备回调函数指针，指向各设备的回调函数。 了解IOMap的定义后，add_mmio_map()函数本身的实现是简单的，首先需要判断映射的内存地址空间与物理内存地址空间、已注册的设备内存地址空间是否重叠，如果不重叠，创建结构体即可。\n有了IOMap结构体后，我们便可在NEMU中使用map_read()函数与map_write()函数来访问设备并调用各设备的回调函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 word_t map_read(paddr_t addr, int len, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; invoke_callback(map-\u0026gt;callback, offset, len, false); // prepare data to read word_t ret = host_read(map-\u0026gt;space + offset, len); return ret; } void map_write(paddr_t addr, int len, word_t data, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; host_write(map-\u0026gt;space + offset, len, data); invoke_callback(map-\u0026gt;callback, offset, len, true); } mainargs的传递 当我们在测试程序目录下输入mainargs参数时，测试程序目录下的Makefile会先包含AM_HOME目录下（abstract-machine）的主Makefile，而这一主Makefile又会使用以下语句包含特定架构的Makefile：\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk 特定架构的Makefile又会包含其所运行平台（nemu/npc/native）的Makefile，以riscv32-nemu.mk为例，其包含：\n1 include $(AM_HOME)/scripts/platform/nemu.mk 最终，当我们使用make run时，mainargs会被传递到运行平台（nemu/npc/native）的Makefile中，以NEMU为例：\n1 2 3 4 5 insert-arg: image @python $(AM_HOME)/tools/insert-arg.py $(IMAGE).bin $(MAINARGS_MAX_LEN) \u0026#34;$(MAINARGS_PLACEHOLDER)\u0026#34; \u0026#34;$(mainargs)\u0026#34; run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin 此时，run目标会依赖insert-arg目标，而insert-arg目标会调用Python程序insert-arg.py，mainargs便作为该Python程序的输入参数，那么，这段Python程序主要在做什么呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python3 from sys import argv bin = argv[1] max_len = int(argv[2]) placeholder = argv[3] mainargs = argv[4] if len(mainargs) \u0026gt;= max_len: print(\u0026#34;Error: mainargs should not be longer than {0} bytes\\n\u0026#34;.format( max_len)) exit(1) print(\u0026#34;mainargs={0}\u0026#34;.format(mainargs)) fp = open(bin, \u0026#39;r+b\u0026#39;) data = fp.read() idx = data.find(str.encode(placeholder)) if idx == -1: print(\u0026#34;Error: placeholder not found!\\n\u0026#34;) exit(1) fp.seek(idx) mainargs_pad = str.encode(mainargs)+ ((max_len - len(mainargs)) * str.encode(\u0026#34;\\0\u0026#34;)) if len(mainargs_pad) != max_len: print(\u0026#34;Error: len(mainargs_pad) != max_len\\n\u0026#34;) exit(1) fp.write(mainargs_pad) fp.close() 首先，它会将mainargs打印出来（但这个打印并对应hello程序中输出mainargs的打印行为，后者所hello程序本身内置的），同时向编译后的可执行文件注入mainargs参数。随后，在trm.c中，我们便可将mainargs参数通过_trm_init()函数注入到main函数中：\n1 2 3 4 5 6 static const char mainargs[MAINARGS_MAX_LEN] = MAINARGS_PLACEHOLDER; // defined in CFLAGS void _trm_init() { int ret = main(mainargs); halt(ret); } ","date":"2025-10-04T00:00:00Z","image":"https://posvirus.github.io/p/device-note/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/device-note/","title":"NEMU的设备实现注意事项"},{"content":"此处，我们主要关注向NPC中集成DiffTest时的一些注意事项：\nCPU状态的存储 在运行DiffTest时，我们需要比较REF与DUT的CPU的状态是否一致，而NPC先前未定义存储CPU状态的结构体（因为CPU的状态实际存储在RTL代码中），为方便DiffTest的传参，我们补充定义存储CPU状态的结构体CPU_state，以及它对应的初始化函数与状态同步函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct { word_t grf[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } CPU_state; CPU_state cpu; // defining struct facilitates parameter passing void load_cpu(Vtop* top) { cpu.pc = top-\u0026gt;inst_addr; long long temp_grf; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { gpr((long long)i, \u0026amp;temp_grf); cpu.grf[i] = (word_t)temp_grf; } } // the NPC RegisterFile has no reset signal, // so the initial value of gpr need to be given manually void init_cpu() { cpu.pc = RESET_VECTOR; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { cpu.grf[i] = 0; } } 这里，我们首先定义了load_cpu()函数，它会将当前CPU模块中的PC寄存器与寄存器堆的值传递至cpu中。其次，我们还补充定义了init_cpu()函数，这是因为，目前我们在init_monitor()函数中进行DiffTest的初始化，而该函数在主函数中会先于系统仿真复位函数执行，为保证cpu可以正确获取CPU模块复位的状态，我们需要手动为cpu中的字段赋值。\nRV32E指令集的适配 NEMU的Kconfig中有一个RVE的选项，用于将NEMU的指令集架构指定为RV32E，选中该选项后，会在生成CONFIG_RVE的宏定义，为使NEMU适配RV32E指令集，我们需要对NEMU代码进行相应更改，修改主要集中于对NEMU的寄存器堆访问，需要根据CONFIG_RVE判断寄存器的总数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void isa_reg_display() { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { printf(\u0026#34;%s\\t0x%08x\\t%d\\n\u0026#34;, regs[reg_cnt], gpr(reg_cnt), gpr(reg_cnt)); } // extra print PC register printf(\u0026#34;pc\\t0x%08x\\t%d\\n\u0026#34;, cpu.pc, cpu.pc); } word_t isa_reg_str2val(const char *s, bool *success) { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { if (strcmp(s, regs[reg_cnt]) == 0) { *success = true; return gpr(reg_cnt); } } // extra find pc register if (strcmp(s, \u0026#34;pc\u0026#34;) == 0) { *success = true; return cpu.pc; } *success = false; printf(\u0026#34;register %s not found!\\n\u0026#34;, s); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) { int reg_num = MUXDEF(CONFIG_RVE, 16, 32); extern const char* regs[]; for (int i = 0; i \u0026lt; reg_num; i++) { if (!difftest_check_reg(regs[i], pc, ref_r-\u0026gt;gpr[i], cpu.gpr[i])) return false; } if (!difftest_check_reg(\u0026#34;pc\u0026#34;, pc, ref_r-\u0026gt;pc, cpu.pc)) return false; return true; } NEMU作为REF的自动化编译 在集成DiffTest时，我们需要将NEMU编译成动态库文件，并在NPC中动态链接该动态库文件，从而实现NEMU作为REF的DiffTest。但是，我们实际上不希望在每次运行NPC的DiffTest时，还要进入NEMU的目录下手动修改NEMU的配置并编译动态库文件，我们希望的一个理想的操作流是：\n在NPC的Kconfig中使能DiffTest后，构建NPC时会自动配置NEMU并编译NEMU的动态库文件。 NEMU的配置在NPC运行DiffTest后不应发生任何更改。 为此，我们实现如下的Makefile：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 define remove_quote $(strip $(subst \u0026#34;,,$(1))) endef ifdef CONFIG_DIFFTEST DIFF_REF_PATH = $(NEMU_HOME) DIFF_REF_SO = $(NEMU_HOME)/build/$(call remove_quote,$(CONFIG_ISA))-$(call remove_quote,$(CONFIG_DIFFTEST_REF_NAME))-$(call remove_quote,$(CONFIG_ENGINE))-so MKFLAGS = GUEST_ISA=$(call remove_quote,$(CONFIG_ISA)) SHARE=1 ENGINE=$(call remove_quote,$(CONFIG_ENGINE)) ARGS_DIFF = --diff=$(DIFF_REF_SO) # Backup and restore NEMU config files NEMU_AUTO_CONF = $(NEMU_HOME)/include/config/auto.conf NEMU_AUTOCONF_H = $(NEMU_HOME)/include/generated/autoconf.h NEMU_AUTO_CONF_BK = $(NEMU_HOME)/include/config/auto.conf.bk NEMU_AUTOCONF_H_BK = $(NEMU_HOME)/include/generated/autoconf.h.bk backup-nemu: @echo \u0026#34;Backing up NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF) ]; then \\ cp $(NEMU_AUTO_CONF) $(NEMU_AUTO_CONF_BK); \\ sed -i \u0026#39;/^CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_TRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ISA/d\u0026#39; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA=\\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA_riscv=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^CONFIG_RVE=\u0026#39; $(NEMU_AUTO_CONF); then \\ echo \u0026#34;CONFIG_RVE=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ fi; \\ fi; \\ fi @if [ -f $(NEMU_AUTOCONF_H) ]; then \\ cp $(NEMU_AUTOCONF_H) $(NEMU_AUTOCONF_H_BK); \\ sed -i \u0026#39;/^#define CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_TRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ISA/d\u0026#39; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA \\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA_riscv 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^#define CONFIG_RVE\u0026#39; $(NEMU_AUTOCONF_H); then \\ echo \u0026#34;#define CONFIG_RVE 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ fi; \\ fi; \\ fi restore-nemu: @echo \u0026#34;Restoring NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF_BK) ]; then \\ mv $(NEMU_AUTO_CONF_BK) $(NEMU_AUTO_CONF); \\ fi @if [ -f $(NEMU_AUTOCONF_H_BK) ]; then \\ mv $(NEMU_AUTOCONF_H_BK) $(NEMU_AUTOCONF_H); \\ fi ifdef CONFIG_DIFFTEST_REF_NEMU $(DIFF_REF_SO): @$(MAKE) backup-nemu @$(MAKE) -s -C $(DIFF_REF_PATH) $(MKFLAGS) @$(MAKE) restore-nemu endif .PHONY: $(DIFF_REF_SO) backup-nemu restore-nemu endif 该Makefile的基本结构参考了nemu/tools/difftest.mk，其中DIFF_REF_SO即为REF的动态库文件，当将该Makefile包含在主Makefile中，即可通过：\n1 2 3 4 5 run: $(VERILOG_INPUT) $(VRC_INPUT) ifdef CONFIG_DIFFTEST @echo \u0026#34;-------- REF COMPILE ---------\u0026#34; @$(MAKE) $(DIFF_REF_SO) endif 调用并构建NEMU的动态库文件。以下，我们将解释该Makefile是如何实现对NEMU的配置及恢复的，这主要包括两方面：\n首先，在DIFF_REF_SO的MKFLAGS中，我们将通过Makfile传递NEMU的GUEST_ISA、SHARE与ENGINE参数。此处设置SHARE=1，NEMU便会自动编译成动态库文件。\n其次，当NEMU作为REF时，我们需要除能NEMU配置中一些非必要的功能，比如itrace、ftrace、mtrace等，因为这些功能本身具有输出功能，如果编译动态库文件中包含这些功能，在NPC中运行DiffTest时将会混杂NEMU的输出，造成功能异常。\n为此，我们定义了backup-nemu与restore-nemu两个目标，前者用于将NEMU通过Kconfig生成的配置文件（autoconf.h与auto.conf）保存为副本，并修改配置文件的配置项；后者则用于将副本重新加载为NEMU配置文件。在backup-nemu中，我们修改的配置主要包括：\n除能CONFIG_TARGET_NATIVE_ELF，保证NEMU编译成动态库文件，此处之所以没有补充定义CONFIG_TARGET_SHARE，是因为定义该配置的效果完全等同于在构建时传递SHARE=1。 除能NEMU的指令集架构，将其统一设置为RISCV32，这使得即使我们没有使用RISCV32架构的NEMU，仍然可以在NPC中成功编译RISCV32架构的NEMU动态库文件。 除能NEMU的itrace，mtrace，ftrace功能。 除能NEMU的sdb表达式求值测试功能。 当NPC指令集架构为RV32E，在NEMU中补充定义CONFIG_RVE，将其指令集架构修改为RV32E。 DiffTest的时序问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 static void trace_and_difftest(Vtop *top) { #ifdef CONFIG_ITRACE log_write(\u0026#34;%s\\n\u0026#34;, logbuf); #endif if (g_print_step) { IFDEF(CONFIG_ITRACE, puts(logbuf)); } #ifdef CONFIG_DIFFTEST pc_get(\u0026amp;pc_d, \u0026amp;dnpc_d); load_cpu(top); difftest_step((vaddr_t)pc_d, (vaddr_t)dnpc_d); // current-cycle difftest #endif } static void exec_once(Vtop *top, VerilatedContext *contextp, VerilatedFstC *tfp, bool rst) { if (rst) { EDGE_TRG_EVENT(top, top-\u0026gt;rst = 0; top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); } #ifdef CONFIG_ITRACE IRingBuffer_write(top); #endif half_cycle(top, contextp, tfp); EDGE_TRG(top); half_cycle(top, contextp, tfp); #ifdef CONFIG_FTRACE int type_ft; long long int pc_ft, dnpc_ft; ftrace_type(\u0026amp;type_ft); pc_get(\u0026amp;pc_ft, \u0026amp;dnpc_ft); switch (type_ft) { case 1: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, false); break; case 2: print_return((vaddr_t)pc_ft); break; case 3: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, true); break; default: break; } #endif #ifdef CONFIG_ITRACE char *p = logbuf; p += snprintf(p, MAX_LOGBUF_LEN, FMT_WORD \u0026#34;:\u0026#34;, top-\u0026gt;inst_addr); int i; uint8_t *inst = (uint8_t *)\u0026amp;top-\u0026gt;inst; for (i = 4 - 1; i \u0026gt;= 0; i --) { p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } memset(p, \u0026#39; \u0026#39;, 1); p += 1; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, logbuf + MAX_LOGBUF_LEN - p, top-\u0026gt;inst_addr, (uint8_t *)\u0026amp;top-\u0026gt;inst, 4); #endif EDGE_TRG_EVENT(top, top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); // next instruction fetch } 由于我们采用自定义的宏EDGE_TRG_EVENT()来实现对Verilator生成文件的激励，这会在实现DiffTest时带来一些时序问题，具体而言：NPC中定义的exec_once()函数实际上仿真的是从当前时钟周期时钟上升沿开始，到下一时钟周期上升沿前的时间，这使得当该函数执行完成，当前指令还没有对寄存器堆进行写回操作（这需要等到下一时钟上升沿后），寄存器堆内部的取值还没有更新，因此，如果像NEMU中，在exec_once()执行完成后直接进行DiffTest，便会引发错误。\n为此，我们调整了exec_once()函数的执行顺序，将其仿真的时间修改为从当前时钟周期时钟上升沿后开始，到下一时钟上升沿后结束，即在exec_once()函数中会预取下一周期的指令。同时，我们需要额外保证在系统复位后，exec_once()函数中也会预取第一周期的指令。\n","date":"2025-09-30T00:00:00Z","image":"https://posvirus.github.io/p/npc-note2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note2/","title":"NPC实现时的注意事项（2）"},{"content":"NPC指令的反汇编 当直接在NPC中使用capstone项目提供的反汇编功能，并将NEMU中的disasm.c复制到NPC中，会出现报错。具体而言，我们需要对disasm.c中的几个函数指针进行显示强制类型转换：\n1 2 3 4 5 6 7 8 9 cs_err (*cs_open_dl)(cs_arch arch, cs_mode mode, csh *handle) = NULL; cs_open_dl = reinterpret_cast\u0026lt;cs_err (*)(cs_arch, cs_mode, csh*)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_open\u0026#34;)); assert(cs_open_dl); cs_disasm_dl = reinterpret_cast\u0026lt;size_t (*)(csh, const uint8_t*, size_t, uint64_t, size_t, cs_insn**)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_disasm\u0026#34;)); assert(cs_disasm_dl); cs_free_dl = reinterpret_cast\u0026lt;void (*)(cs_insn*, size_t)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_free\u0026#34;)); assert(cs_free_dl); NPC中sdb命令行的实现 sdb命令行需要调用readline.h库实现，在C++中，由于readline是一个动态库，编译的时候需要加上-lreadline，不然会找不到相关的函数。在Verilator中，我们可以直接使用-LDFLAG加载这一动态库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 # load readline library (used for sdb) LDFLAGS_VR += -lreadline run: $(VERILOG_INPUT) $(VRC_INPUT) @rm -rf input.vc @echo \u0026#34;$(INPUT_FLAG)\u0026#34; | cat \u0026gt; input.vc @echo @echo \u0026#34;---------- VERILATE ----------\u0026#34; @rm -rf $(OBJ_PATH)/* @@$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ $(addprefix -LDFLAGS , $(LDFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $^ sdb扫描NPC寄存器的实现 我们考虑通过DPI-C实现，请注意DPI-C实际上是双向的，即：我可以在RTL代码中调用C++中实现的函数（import），也可以在C++代码中调用RTL代码中定义的任务（export）。在sdb中实现扫描NPC寄存器显然属于后者，即我们需要在RTL代码中定义一个读取寄存器的任务，再在C++代码中调用该任务：\n1 2 3 4 5 6 7 8 9 10 11 12 export \u0026#34;DPI-C\u0026#34; task gpr; task gpr; input longint addr; // 64-bit space output longint data; // 64-bit space if (addr == -1) begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, cur_pc}; end else begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, u_ysyx_25070184_IDU.u_ysyx_25070184_RegisterFile.rf[addr[`ysyx_25070184_REG_ADDR_WIDTH-1:0]]}; end endtask 在实现该任务时，有以下几点需要注意：\n这里我们将任务名定义成gpr，这样我们就可以在C++代码中通过gpr(N)读取第N个寄存器的值，保持其与NEMU代码中的一致性。 我们将任务定义在顶层模块中，这样可以同时读取PC寄存器与通用寄存器。 为防止RTL代码与C++代码中复杂的类型转换，我们统一将addr与data类型定义为longint，这样可以直接映射至C++中的long long类型，且对32/64位的CPU均不会产生溢出。 Verilator的优化输出 Verilator编译的原始输出相对比较冗杂，难以在其中提取有效信息，我希望可以通过修改Makefile将其输出优化为NEMU的规整编译输出。但是NEMU是基于多个Makefile的嵌套，实现对项目的逐文件编译，在NPC中较难实现这一点（一般我们是将需要编译的文件一次性在Makefile中嵌入Verilator编译指令中）。\n于是，我这里采用了一种取巧的方法，直接将Verilator的原始编译输出重定向并依据其输出格式进行信息提取，从而实现规整输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $(VERILATOR_INPUT) $^ 2\u0026gt;\u0026amp;1 | \\ while IFS= read -r line; do \\ if [[ \u0026#34;$$line\u0026#34; == *\u0026#34;g++\u0026#34;* ]]; then \\ last_word=$$(echo \u0026#34;$$line\u0026#34; | awk \u0026#39;{print $$NF}\u0026#39;); \\ if [[ \u0026#34;$$last_word\u0026#34; == *\u0026#34;.cpp\u0026#34; ]]; then \\ echo \u0026#34;[CXX] $$last_word\u0026#34;; \\ else \\ echo \u0026#34;[BUILD] $$last_word\u0026#34;; \\ fi; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;python3\u0026#34;* ]] \u0026amp;\u0026amp; [[ \u0026#34;$$line\u0026#34; == *\u0026#34;.cpp\u0026#34;* ]]; then \\ echo \u0026#34;$$line\u0026#34; | grep -o \u0026#39;[^ ]*\\.cpp\u0026#39; | while read -r cpp_file; do \\ echo \u0026#34;[PYTHON] verilator include: $$cpp_file\u0026#34;; \\ done; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;echo\u0026#34;* ]] || [[ \u0026#34;$$line\u0026#34; == *\u0026#34;rm\u0026#34;* ]]; then \\ continue; \\ else \\ echo \u0026#34;$$line\u0026#34;; \\ fi; \\ done sdb退出指令的优化 在实现NPC时，发现NEMU sdb中的退出指令（q）有一个bug，原始的cmd_q()函数通常实现如下：\n1 2 3 4 static int cmd_q(char *args) { nemu_state.state = NEMU_QUIT; return -1; } 这会导致在运行am-kernels中的测试程序时，如果没有使用批处理模式，且程序最终HIT BAD TRAP，此时直接使用退出指令退出，NEMU的状态会被重置为NEMU_QUIT，导致最后is_exit_status_bad()函数的返回值仍为0，这使得程序虽然测试失败，但最终仍会返回PASS的结果。\n为此，我们需要额外对运行退出指令时NEMU的状态进行判断，如果程序非正常退出，则保持程序当前的状态：\n1 2 3 4 5 6 7 8 9 10 static int cmd_q(char *args) { // if nemu hits bad trap, hold state if ((nemu_state.state == NEMU_ABORT) || ((nemu_state.state == NEMU_END) \u0026amp;\u0026amp; (nemu_state.halt_ret != 0))) { // do nothing } else { nemu_state.state = NEMU_QUIT; } return -1; } 这里其实还有另外一个问题，就是如果在程序运行过程中退出，是否需要保留当前NEMU的状态？此处我们暂时认为无需保留，即NEMU的状态会被重置为NEMU_QUIT，程序测试会返回PASS的结果。\nNPC默认程序的日志输出 在NPC中直接运行默认程序，会发现每条日志输出都会在命令行中重复输出两次，这主要是因为在init_log()函数中：\n1 2 3 4 5 6 7 8 9 void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } log_fp被初始化为stdout，这使得log_write()在调用fprintf()函数时，也会直接将日志输出至命令行中。\n为解决这一点，我们只需在Makfile中加入：\n1 override ARGS ?= --log=$(BUILD_PATH)/npc-log.txt 使得运行NPC默认程序时的日志会输出至构建目录的npc-log.txt中即可。\n","date":"2025-09-25T00:00:00Z","image":"https://posvirus.github.io/p/npc-note1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note1/","title":"NPC实现时的注意事项（1）"},{"content":"在讲义中提到，当使用difftest_regcpy()传递DUT与REF的寄存器状态时，需要DUT的寄存器顺序与REF保持一致。此处我将说明如何检查这一点：\n首先，对于NEMU，RISCV32架构的寄存器顺序在reg.c中定义：\n1 2 3 4 5 6 const char *regs[] = { \u0026#34;$0\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; 以下我们只需要查看RISCV32的REF（即Spike）中，寄存器的顺序是否与之一致即可，首先，在tool目录下的difftest.cc中可见：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sim_t::diff_get_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { ctx-\u0026gt;gpr[i] = state-\u0026gt;XPR[i]; } ctx-\u0026gt;pc = state-\u0026gt;pc; } void sim_t::diff_set_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { state-\u0026gt;XPR.write(i, (sword_t)ctx-\u0026gt;gpr[i]); } state-\u0026gt;pc = ctx-\u0026gt;pc; } 其中gpr[]是NEMU中的通用寄存器成员，而XPR[]则应该是Spike中对应的通用寄存器成员，于是，我们可以进一步在Spike的项目目录下搜索该成员定义，最后发现在regnames.cc中定义了Spike对应的寄存器顺序：\n1 2 3 4 5 6 const char* xpr_name[] = { \u0026#34;zero\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; 经验证，即可发现DUT与REF的寄存器顺序是一致的，无需额外调整。\n","date":"2025-08-24T00:00:00Z","image":"https://posvirus.github.io/p/difftest-gpr/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/difftest-gpr/","title":"DiffTest中的寄存器一致性"},{"content":"native可执行文件的生成 在AM Makefile中，我们会通过：\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk 包含架构相关的Makefile，当我们指定ARCH=native时，包含的Makefile内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 AM_SRCS := native/trm.c \\ native/ioe.c \\ native/cte.c \\ native/trap.S \\ native/vme.c \\ native/mpe.c \\ native/platform.c \\ native/ioe/input.c \\ native/ioe/timer.c \\ native/ioe/gpu.c \\ native/ioe/uart.c \\ native/ioe/audio.c \\ native/ioe/disk.c \\ CFLAGS += -fpie $(shell sdl2-config --cflags) ASFLAGS += -fpie -pie comma = , LDFLAGS_CXX = $(addprefix -Wl$(comma), $(LDFLAGS)) -pie -ldl $(shell sdl2-config --libs) run: image $(IMAGE).elf gdb: image gdb -ex \u0026#34;handle SIGUSR1 SIGUSR2 SIGSEGV noprint nostop\u0026#34; $(IMAGE).elf 首先，该Makefile会定义AM_SRCS，包含GNU/Linux默认的运行时环境native用于实现AM API的所有源文件，该变量会在am路径下的Makefile中被使用，作为SRC进行编译：\n1 2 3 4 5 NAME := am SRCS = $(addprefix src/, $(AM_SRCS)) INC_PATH += $(AM_HOME)/am/src include $(AM_HOME)/Makefile 随后，该Makefile会补充native架构下对应的编译选项，这部分我们暂且不作说明。\n最后，该Makefile定义了run与gdb两个目标，分别用于直接执行$(IMAGE).elf与调试执行$(IMAGE).elf。\nMakefile的错误码 使用如下指令在native架构下执行测试：\n1 make ARCH=native ALL=$PROGRAM run 如若执行失败，则会返回：\n1 make[1]: *** [run] Error 1 此处我们将分析这里错误码1的来源：首先，我们知道测试程序的正确与错误是通过程序中的check()函数实现的，于是我们可查看该函数的实现，在trap.h中：\n1 2 3 void check(bool cond) { if (!cond) halt(1); } 据此可观察到，当条件cond为false时，函数会调用halt(1)，该函数应该是控制错误码的核心函数，于是我们寻找该函数的定义，在AM的trm.c中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void halt(int code) { const char *fmt = \u0026#34;Exit code = 40h\\n\u0026#34;; for (const char *p = fmt; *p; p++) { char ch = *p; if (ch == \u0026#39;0\u0026#39; || ch == \u0026#39;4\u0026#39;) { ch = \u0026#34;0123456789abcdef\u0026#34;[(code \u0026gt;\u0026gt; (ch - \u0026#39;0\u0026#39;)) \u0026amp; 0xf]; } putch(ch); } __am_exit_platform(code); putstr(\u0026#34;Should not reach here!\\n\u0026#34;); while (1); } 不难发现，halt()函数的code参数即用于控制错误码。为验证这一点，我们不妨将check()函数中的halt(1)改为halt(3)，再次运行某个程序，并打印对应的错误输出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Building add-run [native] # Building am-archive [native] + CC src/native/cte.c + CC src/native/vme.c + CC src/native/mpe.c + CC src/native/platform.c + CC src/native/ioe/audio.c + AR -\u0026gt; build/am-native.a # Building klib-archive [native] + CC src/stdio.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-native.a + CC tests/add.c # Creating image [native] + LD -\u0026gt; build/add-native.elf Exit code = 03h make[1]: *** [/home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk:21: run] Error 3 test list [1 item(s)]: add [ add] ***FAIL*** 此时可观察到，程序的错误码输出已变成3。\nklib的链接 框架代码编译到native的时候默认链接到glibc, 我们需要把这些库函数的调用链接到我们编写的klib来进行测试. 我们可以通过在klib.h 中通过定义宏__NATIVE_USE_KLIB__来把库函数链接到klib。该功能的实现原理如下：\n编译阶段： 在klib的库函数实现中包含如下字段： 1 2 3 #if !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__) ... #endif 该字段表明，如果程序在非native架构下编译，或在native架构下编译且定义了__NATIVE_USE_KLIB__，则译该文件中的函数实现。 链接阶段： 链接器会按顺序处理目标文件和库。自定义实现的符号会优先被链接，而不是系统标准库中的相同符号（因为链接器默认先处理显式指定的目标文件，后处理库）。 ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-2/","title":"AM Makefile解读（2）"},{"content":"此处说明ftrace实现的一些相关注意事项：\nELF文件的解析 参考讲义，我们可以使用man 5 elf查看ELF文件的结构（可视化结构如上图所示）。这里主要说明如何对其进行解析：\n首先，需要指出，ELF文件本质上还是一个文件，所以我们可以使用fread(), fopen()等对文件相关的标准库函数对其进行读取。其次，基于ELF文件的结构，我们需要查找并存储所有函数符号的地址（Value）及对应大小（Size），需要经过如下步骤：\n阅读ELF文件的Header，使用fread()函数将其写入一个ElfN_Ehdr结构体中，并从中提取： Section Header Table（节头表）的地址偏移量（e_shoff）。 节头表的表项个数（亦即表的行数，e_shnum）。 Section Header String Table（节头名字表）对应的节头表表项索引值（e_shstrndx）。这里需要指出，对于节头表的每一个表项，均索引ELF文件中的一个实体区域，节头表的各表项仅用于记录这个实体的各种参数（如名字、地址偏移量、大小与表项个数等等），而存在一个称为节头名字表的实体，专门用于储存节头表各表项的名字，且节头表同样会存在一个表项索引它。所以如果我们向获取节头表中的某个表项的名字，我们就需要先读取节头名字表，再根据表项提供的参数在节头名字表内定位到该表项对应的名字。 根据提取的参数，查找节头表中节头名字表对应的表项，使用fread()函数将其写入一个ElfN_Shdr结构体中，并从中提取： 节头名字表对应的地址偏移量（sh_offset）。 依据节头名字表的地址偏移量，我们即可定位到节头名字表，随后开始扫描节头表的各表项，使用fread()函数循环将各表项写入一个ElfN_Shdr结构体中，并根据表项的sh_name字段在节头名字表中读取定位该表项的名字，我们需要查找两个表项： 名字为.symtab的表项：符号表，用于存储程序中的符号，我们需要获取其对应的地址偏移量（sh_offset）与表项个数（这里可以使用符号表总大小sh_size与符号表单个表项的大小sh_entsize相除得到）。 名字为.strtab的表项：符号名字表，用于存储符号表中各表项的名字，它与符号表的关系类似节头名字表与节头表的关系。我们需要获取其对应的地址偏移量（sh_offset）与大小（sh_size）。 完成表项的查找后，依据符号表的地址偏移量，我们可定位到符号表，随后便可开始查找函数符号对应的表项，具体原理是使用fread()函数循环将各表项写入一个ElfN_Sym结构体中，并提取其中的st_info字段，使用ELFN_ST_TYPE()宏即可从该字段中解析得到该符号表项的类型，如果是STT_FUNC（函数符号对应的类型），则存储该表项的地址（st_value）与大小（st_size）。 同时，对于函数符号对应的表项，我们同样可以依据该表项的st_name字段，在符号名字表中定位并存储相应的函数名。 基于上述流程，即可完成对ELF文件的解析。\n函数调用与返回的判断 函数调用与返回的判断需要参考RISCV的ABI（Application Binary Interface，应用程序二进制接口，它定义了应用程序之间或应用程序和操作系统之间进行二进制级交互时必须遵循的规则和约定）。具体而言，RISCV的函数调用与返回主要涉及使用jal与jalr指令对ra寄存器进行写入与读取，包括：\n函数调用： 将当前发生函数调用的pc存储在ra中，主要分为两种情况： 使用jal，则指令应当形如jal ra func，将当前pc存储于ra后，直接跳转至func。 使用jalr，则指令应当形如jalr ra imm(rs1)，将当前pc存储于ra后，跳转至imm(rs1)指向的func。 函数返回： 读取ra存储的pc并跳转，RISCV有专用的伪指令ret用于函数返回，该指令展开后为：jalr zero 0(ra)。 因此，我们仅需在NEMU ISA的jal，jalr指令实现中增加对函数调用与函数返回的判断即可：\n1 2 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); INSTPAT(\u0026#34;??????? ????? ????? ??? ????? 11011 11\u0026#34;, jal , J, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = s-\u0026gt;pc + imm; if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); 对应地，我们需要在ELF文件中的函数符号解析完成后，增加对应的函数调用与返回的打印函数。\n尾调用的处理 单纯基于上述逻辑实现的ftrace无法处理函数的尾调用，因为函数发生尾调用时，不会将当前发生调用的pc存储在ra中，只会使用jalr zero 0(rs1)直接跳转至func。为实现对尾调用的追踪，我们需要增加以下三点功能：\n在NEMU ISA的jalr指令实现中增加对函数尾调用的判断： 1 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false); else if ((rd == 0) \u0026amp;\u0026amp; (imm == 0)) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, true)); 修改函数调用的打印函数print_call()，增加对尾调用的识别功能，当发生尾调用时，该函数会存储尾调用函数对应的调用深度、PC值至一个全局静态结构体数组中： 1 2 3 4 5 6 7 8 9 10 11 12 13 void print_call(vaddr_t pc, vaddr_t dnpc, bool tail) { int idx = check_func(dnpc); if (idx \u0026lt; 0) return; func_depth++; flog_write(FMT_PADDR \u0026#34;: %*scall [%s@\u0026#34; FMT_PADDR \u0026#34;]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name, dnpc); if (tail) { tail_hdr[tail_nr].pc = pc; tail_hdr[tail_nr++].depth = func_depth - 1; } } 修改函数返回的打印函数print_return()，增加对尾调用的处理，当调用该函数时，该函数会在存储尾调用函数的结构体数组中查找当前是否存在尾调用函数，若存在，则一并输出函数返回信息。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void print_return(vaddr_t pc) { int idx = check_func(pc); if (idx \u0026lt; 0) return; flog_write(FMT_PADDR \u0026#34;: %*sret [%s]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name); func_depth--; // tail call handler (recursion) if (tail_nr \u0026gt; 0) { if (tail_hdr[tail_nr-1].depth == func_depth) { tail_nr--; print_return(tail_hdr[tail_nr].pc); } } } 注意print_return()函数中对尾调用函数的查找是递归的，因为可能存在连续嵌套的尾调用。 ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/ftrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/ftrace/","title":"ftrace实现的注意事项"},{"content":"mtrace本身实现非常简单，此处仅列举在实现过程中遇到的若干细节：\nmtrace写入NEMU Log文件 对于mtrace这种大规模输出，我们不能仅通过printf()函数将其打印在终端上，而要将其写入NEMU的Log文件中，NEMU提供了一个log_write()函数用于实现这一点，它可将指定字符串写入NEMU的Log文件nemu-log.txt。\n这时我产生了一个疑问，在log_write()函数中并没有指定写入文件的参数，NEMU是如何通过该函数写入指定的Log文件呢？于是，我自然需要去查看log_write()的定义，在utils.h中：\n1 2 3 4 5 6 7 8 9 10 #define log_write(...) IFDEF(CONFIG_TARGET_NATIVE_ELF, \\ do { \\ extern FILE* log_fp; \\ extern bool log_enable(); \\ if (log_enable() \u0026amp;\u0026amp; log_fp != NULL) { \\ fprintf(log_fp, __VA_ARGS__); \\ fflush(log_fp); \\ } \\ } while (0) \\ ) 据此可见，log_write()函数只是一段宏定义，这里的文件通过log_fp指定，而log_fp受到extern关键字修饰，这说明它的定义来自其他的文件，我们继续搜索log_fp的定义，在log.c中：\n1 2 3 4 5 6 7 8 9 10 11 FILE *log_fp = NULL; void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } 据此可知，log_fp是通过init_log()函数赋值的，当通过init_log()指定NEMU的Log文件log_file，log_fp便会被赋值为指向该文件的指针，而init_log()函数在monitor.c中被调用，NEMU的Log文件是通过命令行参数-l指定的。\nmtrace的配置项 我们仿照itrace的配置项，给出了mtrace的基本配置项：\n1 2 3 4 5 6 7 8 9 config MTRACE depends on TRACE \u0026amp;\u0026amp; TARGET_NATIVE_ELF \u0026amp;\u0026amp; ENGINE_INTERPRETER bool \u0026#34;Enable memory tracer\u0026#34; default y config MTRACE_COND depends on MTRACE string \u0026#34;Only trace memory when the condition is true\u0026#34; default \u0026#34;true\u0026#34; 有关Kconfig的相关语法，可参考：Kconfig 语法分析详解。\n配置完成后，在启动mtrace记录访存行为时，我发现一个奇怪的现象，似乎依据Log文件的输出，每条指令都在访存：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 [MTRACE-R]: [0x80000da4] --\u0026gt; 0x032 0x80000da4: 40 f7 07 b3 sub\ta5, a4, a5 [MTRACE-R]: [0x80000da8] --\u0026gt; 0x032 0x80000da8: 01 87 97 93 slli\ta5, a5, 0x18 [MTRACE-R]: [0x80000dac] --\u0026gt; 0x032 0x80000dac: 41 87 d7 93 srai\ta5, a5, 0x18 [MTRACE-R]: [0x80000db0] --\u0026gt; 0x032 0x80000db0: fe 07 80 e3 beqz\ta5, -0x20 [MTRACE-R]: [0x80000d90] --\u0026gt; 0x032 0x80000d90: 00 15 05 13 addi\ta0, a0, 1 [MTRACE-R]: [0x80000d94] --\u0026gt; 0x032 0x80000d94: 02 07 04 63 beqz\ta4, 0x28 [MTRACE-R]: [0x80000d98] --\u0026gt; 0x032 [MTRACE-R]: [0x800010a1] --\u0026gt; 0x008 0x80000d98: 00 05 c7 83 lbu\ta5, 0(a1) [MTRACE-R]: [0x80000d9c] --\u0026gt; 0x032 [MTRACE-R]: [0x80009fc1] --\u0026gt; 0x008 0x80000d9c: 00 05 47 03 lbu\ta4, 0(a0) [MTRACE-R]: [0x80000da0] --\u0026gt; 0x032 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 一开始我以为是mtrace功能上有bug，后来才恍然大悟，因为每条指令的取指都天然存在一次访存行为！但是，如讲义中所说，有时我可能只会关心某一段内存区间的访问，从而希望mtrace减少输出。因此，我又在Kconfig中增加了如下配置项：\n1 2 3 4 5 6 7 8 9 config MTRACE_MIN depends on MTRACE hex \u0026#34;Lower bound for memory tracing (unit: number of bytes)\u0026#34; default 0x00000000 config MTRACE_MAX depends on MTRACE hex \u0026#34;Upper bound for memory tracing (unit: number of bytes)\u0026#34; default 0xffffffff 这两个配置项限制了mtrace的追踪内存区间，其取值采用hex类型，因为我们通常习惯通过十六进制表示内存地址。\n","date":"2025-08-07T00:00:00Z","image":"https://posvirus.github.io/p/mtrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/mtrace/","title":"mtrace实现的注意事项"},{"content":"指令环形缓冲器（Instruction Ring Buffer, 下文简称IRB）的实现基于一个简化的环形缓冲器结构，具体而言，其可基于一个仅具有循环（覆盖）写入的队列实现，且队列单次写入的数据量均为1（即单个指令对应的反汇编输出）。基于上述分析，我们可定义如下的IRB：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define NR_RB 16 // instruction register typedef struct ireg { char logbuf[128]; int valid; } IReg; // instruction ring buffer typedef struct iringbuffer { IReg i_buf[NR_RB]; int end; } IRingBuffer; 上述代码中，一个固定容量为16的IRB由iringbuffer结构体定义，其中包含存储指令反汇编输出的结构体数组i_buf，以及用于存储当前写入的数组元素索引end，对于存储指令反汇编输出的结构体ireg，其包含定长字符数组logbuf与标记存储内容有效的指示位valid。\n以下，我们可以使用实现监视点的类似方法，直接例化一个全局静态的IRB，使NEMU可通过我们提供的接口对IRB进行操作：\n1 static IRingBuffer iring_buf; 对IRB的操作可分为三种：对IRB的初始化、对IRB的单次写入与IRB的内容输出。为此，我们定义了如下三种方法：\n1 2 3 4 5 6 7 8 // initialize instruction ring buffer void IRingBuffer_init(); // write one log into instruction ring buffer int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst); // print contents of instruction ring buffer void IRingBuffer_print(); IRingBuffer_init()函数实现如下：\n1 2 3 4 5 6 7 void IRingBuffer_init() { for (int i = 0; i \u0026lt; NR_RB; i++) { iring_buf.i_buf[i].valid = 0; } iring_buf.end = 0; Log(\u0026#34;Instruction ring buffer initialization success. Buffer storage: %d insts.\u0026#34;, NR_RB); }; IRB的初始化较为简单，我们仅需将i_buf所有元素的指示位置零，并将索引end指向数组首个元素即可。同时，IRB的初始化可在NEMU monitor的初始化函数init_monitor()中实现：\n1 2 /* Initialize the instruction ring buffer. */ IFDEF(CONFIG_ITRACE, IRingBuffer_init()); IRingBuffer_write()函数的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst) { // check illegal inst input if (inst == NULL) return -1; char *p = iring_buf.i_buf[iring_buf.end].logbuf; p += snprintf(p, sizeof(iring_buf.i_buf[iring_buf.end].logbuf), FMT_WORD \u0026#34;:\u0026#34;, pc); int i; int ilen = snpc - pc; #ifdef CONFIG_ISA_x86 for (i = 0; i \u0026lt; ilen; i++) { #else for (i = ilen - 1; i \u0026gt;= 0; i--) { #endif p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } int ilen_max = MUXDEF(CONFIG_ISA_x86, 8, 4); int space_len = ilen_max - ilen; if (space_len \u0026lt; 0) space_len = 0; space_len = space_len * 3 + 1; memset(p, \u0026#39; \u0026#39;, space_len); p += space_len; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, iring_buf.i_buf[iring_buf.end].logbuf + sizeof(iring_buf.i_buf[iring_buf.end].logbuf) - p, MUXDEF(CONFIG_ISA_x86, snpc, pc), inst, ilen); iring_buf.i_buf[iring_buf.end].valid = 1; // end pointer increment iring_buf.end = (iring_buf.end + 1) % NR_RB; return 0; }; 该函数接收当前取值的PC值pc、下一静态PC值snpc与当前取出的指令inst，并通过exec_once()函数中相同的解码方式将其转换为反汇编输出存储至i_buf中，并将对应指示位置位。随后，将数组索引递增，此处通过模运算使数组索引不发生越界，并实现覆盖写入的功能。\n我们可在isa_exec_once()函数中调用该函数，该函数应当在指令取指后立刻被调用，因为如果当前指令执行出错，我们也需要在NEMU异常退出前存储当前指令的反汇编输出：\n1 2 3 4 5 6 7 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); #ifdef CONFIG_ITRACE IRingBuffer_write(s-\u0026gt;pc, s-\u0026gt;snpc, (uint8_t *)\u0026amp;s-\u0026gt;isa.inst); #endif return decode_exec(s); } IRingBuffer_print()函数的实现如下：\n1 2 3 4 5 6 7 8 9 10 11 void IRingBuffer_print() { for (int i = 0; i \u0026lt; NR_RB; i++) { if (iring_buf.i_buf[i].valid == 1) { if (((i + 1) % NR_RB) == iring_buf.end) { printf(\u0026#34; --\u0026gt; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } else { printf(\u0026#34; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } } } }; 此处，我们分两种情况打印i_buf中的反汇编输出，当((i + 1) % NR_RB) == iring_buf.end为真时，代表当前指令为程序发生异常时执行的指令（因为在写入反汇编输出后会对索引递增，故此处使用i+1），使用--\u0026gt;标识该指令，其余指令均正常打印即可。\n该函数可插入NEMU异常终止的所有程序段中，目前仅插入assert_fail_msg()函数中，后续可通过更多测试继续完善。\n","date":"2025-08-04T00:00:00Z","image":"https://posvirus.github.io/p/iringbuf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/iringbuf/","title":"指令环形缓冲器实现"},{"content":"在PA2中，笔者被要求实现一个简单的sprintf()函数，其目前仅需实现对%s与%d标识符的支持即可。此处，笔者对其进行了进一步增强，使其可支持更多种标识符，并具有扩展实现更多标识符的能力，其目前可支持的标识符列举如下：\n标识符 含义 %d 位宽不限的十进制有符号数 %u 位宽不限的十进制无符号数 %o 位宽不限的八进制无符号数 %x 位宽不限的十六进制无符号数（字母小写） %X 位宽不限的十六进制无符号数（字母小写） %lu 位宽不限的无符号整型 %llu 位宽不限的无符号长整型 %s 字符串 %c 单个字符 %p 指针地址 %% 字符% 此处，为保证sprintf()函数具有识别更多标识符的扩展性，在编写sprint()函数时采用了模块化设计，其设计原理类似于NEMU表达式求值中对表达式中token的提取，以下是具体实现：\nsprintf()函数分三个阶段，第一阶段是对含标识符字符串的解析，第二阶段是对标识符对应参数的转换，第三阶段则是目标字符串的生成。\n1 2 3 4 5 6 7 8 9 10 11 12 /* sprintf arguments */ enum { SP_CHAR, SP_UDEC, SP_UUSG, SP_UOCT, SP_Uhex, SP_UHEX, SP_ULOU, SP_ULLU, SP_USTR, SP_USCH, SP_UPTR, }; /* sprintf tokens */ typedef struct sp_token { int type; char str[256]; } SP_Token; 在第一阶段，我们首先定义了若干枚举变量，用于代表各种标识符类型（以及普通单字符），其次，我们定义结构体SP_Token，该结构体用于存储对含标识符字符串的解析结果，每个结构体代表从含标识符字符串解析出的一个token，包含该token的类型type（属于枚举变量中的一者）与token对应转换后的字符串str。\n1 2 static SP_Token sp_tokens[SP_NR_MAX] __attribute__((used)) = {}; static int nr_sp_token __attribute__((used)) = 0; 同时，我们在stdio.c中定义全局静态SP_Token数组sp_tokens，用于存储每次对含标识符字符串的解析结果，同时定义nr_sp_token指示当前解析结果的token数量。\n以下，我们定义静态函数sp_make_token()完成对含标识符字符串的解析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // %d, unlimited length decimal if (fmt[position] == \u0026#39;d\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UDEC; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %u, unlimited length unsign if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UUSG; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %o, unlimited length octal if (fmt[position] == \u0026#39;o\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UOCT; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %x, unlimited length hexadecimal (lower) if (fmt[position] == \u0026#39;x\u0026#39;) { sp_tokens[nr_sp_token].type = SP_Uhex; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %X, unlimited length hexadecimal (upper) if (fmt[position] == \u0026#39;X\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UHEX; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if(fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %lu, unlimited length uint32_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULOU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if (fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %llu, unlimited length uint64_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULLU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } return false; } // %s, unlimited length string if (fmt[position] == \u0026#39;s\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %c, single char if (fmt[position] == \u0026#39;c\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USCH; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %p, value of a pointer if (fmt[position] == \u0026#39;p\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UPTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %%, char \u0026#39;%\u0026#39; if (fmt[position] == \u0026#39;%\u0026#39;) { sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } 此处的解析逻辑与表达式求值中的token解析逻辑类似，只是此处我们实现的是基本的库函数，因此无法使用正则表达式进行快速匹配，需要逐字符进行判断。在该函数中，我们会将含标识符字符串顺序转换为token数组，同时指明各token类型type。对普通字符，我们在该函数中还会指明其token在标识符转换后的字符串str（因其无需转换，但是需要在普通字符后追加'\\0'）。\n完成token解析逻辑后，我们可在sprintf()函数中调用该函数，并进行第二、三阶段的实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 int sprintf(char *out, const char *fmt, ...) { // detect invalid behavior if (!sp_make_token(fmt)) { return -1; } // va-args initialization va_list args; va_start(args, fmt); // args-to-string convert for (int i = 0; i \u0026lt; nr_sp_token; i++) { switch (sp_tokens[i].type) { case SP_CHAR: // directly skip break; case SP_UDEC: // str-to-dec convert str2sig(va_arg(args, int), sp_tokens[i].str, 10, false); break; case SP_UUSG: // str-to-unsign convert str2u(va_arg(args, unsigned int), sp_tokens[i].str); break; case SP_UOCT: // str-to-oct convert str2sig(va_arg(args, int), sp_tokens[i].str, 8, false); break; case SP_Uhex: // str-to-hex convert (lower) str2sig(va_arg(args, int), sp_tokens[i].str, 16, false); break; case SP_UHEX: // str-to-hex convert (upper) str2sig(va_arg(args, int), sp_tokens[i].str, 16, true); break; case SP_ULOU: // str-to-long-unsign convert str2lu(va_arg(args, size_t), sp_tokens[i].str); break; case SP_ULLU: // str-to-long-long-unsign convert str2llu(va_arg(args, unsigned long long), sp_tokens[i].str); break; case SP_USTR: // str copy strcpy(sp_tokens[i].str, va_arg(args, char *)); break; case SP_USCH: // char copy sp_tokens[i].str[0] = (char) va_arg(args, int); sp_tokens[i].str[1] = \u0026#39;\\0\u0026#39;; break; case SP_UPTR: // pointer value str2ptr(va_arg(args, void *), sp_tokens[i].str); break; default: // do nothing break; } } // end of args extraction va_end(args); // str-cat to result str strcpy(out, sp_tokens[0].str); for (int i = 1; i \u0026lt; nr_sp_token; i++) { strcat(out, sp_tokens[i].str); } return strlen(out); } 首先，我们会进行含标识符字符串的解析，并判断解析结果是否成功，若不成功，则返回一个负值（sprintf()函数的逻辑是，当函数执行成功，会返回打印字符串的长度，反之会返回一个负值）。\n其次，我们使用stdarg.h库中的相关函数，逐个解析标识符对应的参数并转换成字符串，赋值给对应token的str变量。此处需要实现多个数据类型向字符串转换的函数，由于笔者并不希望实现标准库中功能较复杂的转换函数，因此此处的函数均自由命名，并被声明为静态函数防止外部调用。\n我们可以简单以指针向字符串的转换函数为例进行说明：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 static char *str2ptr(void *num, char *re) { // avoid illegal input assert(re != NULL); char *pre = re; char num_buf[32] = {0}; // number buffer (fixed width) int ptr = 0; size_t unum = (size_t) num; size_t udiv; // NULL pointer if (num == NULL) { *pre = \u0026#39;(\u0026#39;; pre++; *pre = \u0026#39;n\u0026#39;; pre++; *pre = \u0026#39;i\u0026#39;; pre++; *pre = \u0026#39;l\u0026#39;; pre++; *pre = \u0026#39;)\u0026#39;; return re; } if (unum == 0) { re[0] = \u0026#39;0\u0026#39;; re[1] = \u0026#39;x\u0026#39;; re[2] = \u0026#39;0\u0026#39;; re[3] = \u0026#39;\\0\u0026#39;; return re; } *pre = \u0026#39;0\u0026#39;; pre++; *pre = \u0026#39;x\u0026#39;; pre++; // loop for conversion while (unum \u0026gt; 0) { udiv = unum % 16; if (udiv \u0026lt; 10) { num_buf[ptr++] = udiv + \u0026#39;0\u0026#39;; } else { num_buf[ptr++] = udiv - 10 + \u0026#39;a\u0026#39;; } unum = unum / 16; } // number order inversion for (int i = 0; i \u0026lt; ptr; i++) { *pre = num_buf[ptr-i-1]; pre++; } // add EOL *pre = \u0026#39;\\0\u0026#39;; return re; } 该函数接收指针num，并将字符串转换结果赋值给re，为此，首先我们需要判断指针num是否为NULL，如是，则按标准形式直接返回字符串(nil)；其次，我们将指针num强制类型转换为uint32_t类型变量unum（因为目前实现的处理器是32位地址）；最后，我们仅需将unum转换为字符串即可，这在实现上是简单的。同时需注意，指针地址为0x...的形式，以十六进制（小写）打印，在实现时需要额外增加逻辑。\n在第三阶段，我们仅需通过循环，使用strcat()函数将所有的token对应的字符串进行拼接即可（当然，对第一个token，我们需要使用strcpy()）。\n另外，我们额外编写了用于测试sprintf()函数的客户程序，其在native与NEMU下均可通过测试：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026#34;trap.h\u0026#34; char buf[128]; int main() { // basic string sprintf(buf, \u0026#34;%s\u0026#34;, \u0026#34;Hello world!\u0026#34;); check(strcmp(buf, \u0026#34;Hello world!\u0026#34;) == 0); // decimal format sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, 12806, 12923); check(strcmp(buf, \u0026#34;117 + 12806 = 12923\u0026#34;) == 0); sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, -12806, -12689); check(strcmp(buf, \u0026#34;117 + -12806 = -12689\u0026#34;) == 0); sprintf(buf, \u0026#34;0x%x in hex is %d\u0026#34;, 255, 255); check(strcmp(buf, \u0026#34;0xff in hex is 255\u0026#34;) == 0); // unsigned sprintf(buf, \u0026#34;%u\u0026#34;, 4294967295U); check(strcmp(buf, \u0026#34;4294967295\u0026#34;) == 0); // octal sprintf(buf, \u0026#34;Octal: %o\u0026#34;, 63); check(strcmp(buf, \u0026#34;Octal: 77\u0026#34;) == 0); // hexadecimal (case specify) sprintf(buf, \u0026#34;Hex lower: %x\u0026#34;, 255); check(strcmp(buf, \u0026#34;Hex lower: ff\u0026#34;) == 0); sprintf(buf, \u0026#34;Hex upper: %X\u0026#34;, 0xBCDAABCD); check(strcmp(buf, \u0026#34;Hex upper: BCDAABCD\u0026#34;) == 0); // unsigned long sprintf(buf, \u0026#34;Long: %lu\u0026#34;, 123456789UL); check(strcmp(buf, \u0026#34;Long: 123456789\u0026#34;) == 0); // unsigned long long sprintf(buf, \u0026#34;Long long: %llu\u0026#34;, 1234567890123456ULL); check(strcmp(buf, \u0026#34;Long long: 1234567890123456\u0026#34;) == 0); // char sprintf(buf, \u0026#34;Char: %c\u0026#34;, \u0026#39;A\u0026#39;); check(strcmp(buf, \u0026#34;Char: A\u0026#34;) == 0); // pointer volatile int *x = (volatile int *)0x0061fe1c; sprintf(buf, \u0026#34;Pointer: %p\u0026#34;, x); check(strcmp(buf, \u0026#34;Pointer: 0x61fe1c\u0026#34;) == 0); // NULL pointer sprintf(buf, \u0026#34;Null ptr: %p\u0026#34;, NULL); check(strcmp(buf, \u0026#34;Null ptr: (nil)\u0026#34;) == 0); // mixed format sprintf(buf, \u0026#34;Mixed: %d %s %c 0x%x\u0026#34;, 42, \u0026#34;test\u0026#34;, \u0026#39;Z\u0026#39;, 255); check(strcmp(buf, \u0026#34;Mixed: 42 test Z 0xff\u0026#34;) == 0); // boundary value sprintf(buf, \u0026#34;Min int: %d, Max uint: %u\u0026#34;, -2147483647-1, 4294967295U); check(strcmp(buf, \u0026#34;Min int: -2147483648, Max uint: 4294967295\u0026#34;) == 0); // special string sprintf(buf, \u0026#34;Newline: %s\u0026#34;, \u0026#34;a\\nb\u0026#34;); check(strcmp(buf, \u0026#34;Newline: a\\nb\u0026#34;) == 0); // char \u0026#39;%\u0026#39; sprintf(buf, \u0026#34;100%% guaranteed\u0026#34;); check(strcmp(buf, \u0026#34;100% guaranteed\u0026#34;) == 0); return 0; } 在测试指针的程序段中，我们对指针进行直接赋值，并通过volatile关键字防止编译器优化。\n","date":"2025-07-27T00:00:00Z","image":"https://posvirus.github.io/p/sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/sprintf/","title":"功能更强大的sprintf()函数"},{"content":"首先，通过RTFSC，我们发现NEMU的批处理模式是通过sdb.c中的一个变量is_batch_mode控制的：\n1 2 3 4 5 6 7 void sdb_mainloop() { if (is_batch_mode) { cmd_c(NULL); return; } /* other logic */ } 在sdb的主循环中，当这个变量为true时，会直接通过调用cmd_c()执行用户程序并返回，不再启动sdb。但是这个变量在当前文件声明的默认值为false，如何将其变为true呢？我们很快又会发现sdb_set_batch_mode()这个函数：\n1 2 3 void sdb_set_batch_mode() { is_batch_mode = true; } 不难发现，通过调用这个函数就可以让NEMU进入批处理模式！此时我们只需要寻找NEMU在什么位置调用了这个函数，不难发现它的调用位置在monitor.c的parse_args()函数中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static int parse_args(int argc, char *argv[]) { const struct option table[] = { {\u0026#34;batch\u0026#34; , no_argument , NULL, \u0026#39;b\u0026#39;}, {\u0026#34;log\u0026#34; , required_argument, NULL, \u0026#39;l\u0026#39;}, {\u0026#34;diff\u0026#34; , required_argument, NULL, \u0026#39;d\u0026#39;}, {\u0026#34;port\u0026#34; , required_argument, NULL, \u0026#39;p\u0026#39;}, {\u0026#34;help\u0026#34; , no_argument , NULL, \u0026#39;h\u0026#39;}, {0 , 0 , NULL, 0 }, }; int o; while ( (o = getopt_long(argc, argv, \u0026#34;-bhl:d:p:\u0026#34;, table, NULL)) != -1) { switch (o) { case \u0026#39;b\u0026#39;: sdb_set_batch_mode(); break; case \u0026#39;p\u0026#39;: sscanf(optarg, \u0026#34;%d\u0026#34;, \u0026amp;difftest_port); break; case \u0026#39;l\u0026#39;: log_file = optarg; break; case \u0026#39;d\u0026#39;: diff_so_file = optarg; break; case 1: img_file = optarg; return 0; default: printf(\u0026#34;Usage: %s [OPTION...] IMAGE [args]\\n\\n\u0026#34;, argv[0]); printf(\u0026#34;\\t-b,--batch run with batch mode\\n\u0026#34;); printf(\u0026#34;\\t-l,--log=FILE output log to FILE\\n\u0026#34;); printf(\u0026#34;\\t-d,--diff=REF_SO run DiffTest with reference REF_SO\\n\u0026#34;); printf(\u0026#34;\\t-p,--port=PORT run DiffTest with port PORT\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); exit(0); } } return 0; } 这段代码是用于解析init_monitor()函数传入的argc与argv参数的，而init_monitor()的argc与argv参数又是通过main()函数传递的，不难发现，当参数中包括-b一项时，就会使得NEMU进入批处理模式。\n那么，我们可以回忆一下，我们是如何运行NEMU的？似乎是通过Makefile构建一个run的目标实现的，因此，我们需要进一步去寻找run对应的构建规则，它在nemu/scripts/native.mk下：\n1 2 3 4 5 6 7 8 IMG ?= NEMU_EXEC := $(BINARY) $(ARGS) $(IMG) run-env: $(BINARY) $(DIFF_REF_SO) run: run-env $(call git_commit, \u0026#34;run NEMU\u0026#34;) $(NEMU_EXEC) 不难发现，当构建run这个目标时，会使用NEMU_EXEC构建NEMU，而参数又是通过ARGS来传递的，那么，当我们运行AM时，是通过什么方式传递ARGS参数的呢？在AM的scripts/platform/nemu.mk中，我们不难发现：\n1 2 3 4 5 6 NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt /* other logic */ run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin 因此，当AM运行NEMU时，会通过命令行直接传递ARGS参数，而对应需要传递的参数由NEMUFLAGS指定，因此，我们最终只需添加：\n1 NEMUFLAGS += -b 即可实现默认以批处理模式运行NEMU。在cpu-tests路径下重新运行一遍全部测试：\n1 make ARCH=riscv32-nemu run 发现确实在运行NEMU时不会再启用sdb了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # Building recursion-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/recursion.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/recursion-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/recursion-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/recursion-riscv32-nemu.bin, size = 728 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000026c [src/cpu/cpu-exec.c:92 statistic] host time spent = 4,025 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 4,545 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 1,129,192 inst/s # Building div-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/div.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/div-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/div-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/div-riscv32-nemu.bin, size = 404 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000124 [src/cpu/cpu-exec.c:92 statistic] host time spent = 877 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 868 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 989,737 inst/s ","date":"2025-07-24T00:00:00Z","image":"https://posvirus.github.io/p/batch/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/batch/","title":"如何让NEMU以批处理模式运行？"},{"content":"提供可读性更强的Makefile版本 1 2 3 html: cat Makefile | sed \u0026#39;s/^\\([^#]\\)/ \\1/g\u0026#39; | markdown_py \u0026gt; Makefile.html .PHONY: html 首先，该Makefile给出了一个html目标，用于生成可读性更强的Makefile，其具体实现原理是，首先通过cat以输出Makefile的所有内容至标准输出，并通过管道将其传递至sed指令，sed会通过正则表达式匹配所有非注释行，并将所有非注释行的第一个非#字符前加入四个空格。这时，该Makefile的所有注释行在Markdown语法中会被识别为标题；所有非注释行则会被识别为代码块（因为插入了四个空格）1。\n最后，再调用markdown_py将其转换为HTML格式，并重定向至Makefile.html中。\n基本配置与运行检查 1 2 3 4 ifeq ($(MAKECMDGOALS),) MAKECMDGOALS = image .DEFAULT_GOAL = image endif 首先，我们会检查Makefile执行的目标，这里通过一个环境变量MAKECMDGOALS引用，当该值为空时，说明我们仅输入了make，此时将MAKECMDGOALS设置为image，代表默认创建一个裸机镜像。同时将另一个环境变量.DEFAULT_GOAL也设置为image，请注意，.DEFAULT_GOALS会真正地将Makefile的执行目标设定为image，而我们此处将MAKECMDGOALS设置为image的目的是为了后续的配置与运行检查。\n1 2 3 4 ifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),) ... ### Checks end here endif 其次，我们会使用findstring检查MAKECMDGOALS是否是clean、clean-all、html中的一者，如果是，则该判断为false，我们会跳过该段运行环境检查，这里需要注意的是，ifeq与对应的endif离得很远，需要明确中间的语句均只有在判断为真的时候才执行。\n1 $(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)]) 在命令行中输出对应的构建模板，其中MAKECMDGOALS是该Makefile对应的构建目标，NAME是AM其他子目录下的Makefile定义的变量，比如在src下的Makefile对应的NAME为am，而ARCH则为在输入make时指令的架构变量，回忆PA2的前一节，我们在运行cpu-tests时使用过如下形式的make指令进行构建：\n1 make ARCH=$ISA-nemu ALL=dummy run 此处我们即指定了ARCH变量对应的值。\n1 2 3 ifeq ($(wildcard $(AM_HOME)/am/include/am.h),) $(error $$AM_HOME must be an AbstractMachine repo) endif 接着，Makefile会检查环境变量AM_HOME是否设置正确，此处主要使用wildcard查找am.h文件是否存在，如果存在则说明正确。\n1 2 3 4 ARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk))) ifeq ($(filter $(ARCHS), $(ARCH)), ) $(error Expected $$ARCH in {$(ARCHS)}, Got \u0026#34;$(ARCH)\u0026#34;) endif 随后，我们会检查通过命令行传输的架构信息ARCH是否在项目中存在对应的Makefile，为此，我们使用ls指令列举scripts子目录下的所有.mk文件，直接运行该指令的输出为：\n1 2 3 4 5 6 /home/chenwy/ysyx-workbench/abstract-machine/scripts/loongarch32r-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/mips32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv64-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/spike.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86_64-qemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-npc.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32mini-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-qemu.mk 我们使用notdir函数过滤文件前的文件夹路径，需要指出，notdir是一个Makfile函数而非bash指令。\n接着，我们使用basename指令（这是一条指令）获取这些文件的文件名，并将其赋值给ARCHS，代表AM目前支持的架构集合。进而，我们即可使用filter函数（这同样是一个Makefile函数）判断ARCH对应的架构是否存在于ARCHS中，如不存在则报错。\n1 2 3 ARCH_SPLIT = $(subst -, ,$(ARCH)) ISA = $(word 1,$(ARCH_SPLIT)) PLATFORM = $(word 2,$(ARCH_SPLIT)) 以下，确定架构有效后，我们可以使用subst函数将ARCH连接平台与ISA的连字符-替换为空格，再使用word函数分别提取对应的ISA（如riscv32等）与平台（nemu、qemu与npc等）。\n1 2 3 ifeq ($(flavor SRCS), undefined) $(error Nothing to build) endif 最后，我们使用flavor函数检查SRC，即需要构建的源文件是否被定义，若未定义则同样报错。\n此处需要指出，SRCS与之前的NAME类似，都是通过其他Makefile定义，再包含该Makefile给出的，因此我们事实上无法通过这个Makefile构建某个目标（当然html除外），而应当是其它Makefile调用该Makefile进行构建。\n至此，基本配置与运行检查完毕。\n编译目标定义 1 2 3 WORK_DIR = $(shell pwd) DST_DIR = $(WORK_DIR)/build/$(ARCH) $(shell mkdir -p $(DST_DIR)) 首先，我们定义工作目录WORK_DIR为当前目录，同时定义编译输出目录DST_DIR为工作目录下build目录中对应的$(ARCH)子目录，并使用mkdir -p创建该目录。\n1 2 3 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) ARCHIVE = $(WORK_DIR)/build/$(NAME)-$(ARCH).a 其次，IMAGE_REL定义了最终的可执行文件$(NAME)-$(ARCH)的相对路径，同时使用IMAGE调用abspath函数定义其绝对路径，ARCHIVE则定义了归档文件$(NAME)-$(ARCH).a对应的绝对路径。\n1 2 3 4 5 6 OBJS = $(addprefix $(DST_DIR)/, $(addsuffix .o, $(basename $(SRCS)))) LIBS := $(sort $(LIBS) am klib) # lazy evaluation (\u0026#34;=\u0026#34;) causes infinite recursions LINKAGE = $(OBJS) \\ $(addsuffix -$(ARCH).a, $(join \\ $(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))), \\ $(LIBS) )) 接着，我们定义了编译的输出中间文件文件路径OBJS，该定义首先通过basename指令获取SRCS的文件名，并使用addsuffix函数将文件后缀置为.o，随后使用addprefix将中间文件路径统一指定为输出目录DST_DIR下。\n而我们继续可以定义库文件所在路径LIBS，通过立即赋值:=可以避免该定义被递归展开2，同时使用sort避免重复定义，这是因为LIBS可能在其它Makefile中也被定义，因此可能本身就包含am或klib，故此处需要去重处理。\n最后，我们收集所有需要被链接的文件，包括OBJS以及归档文件（如am-$(ARCH).a、klib-$(ARCH).a）。\n这里需要对LINKAGE与ARCHIVE进行一个对比，LINKAGE是我们在生成裸机镜像时需要使用的，所有需要链接的文件，它包含了编译输出的所有中间文件OBJS以及LIBS对应的所有归档文件。而ARCHIVE对应的是一个局部性的概念，是指某一个文件夹调用该Makefile时，生成的归档文件（在该Makefile后续逻辑中我们会知道，生成裸机镜像image与生成归档文件archive是两个相对独立的目标）。因此，在PA2前一节我们运行cpu-tests时，对应的make输出如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Building am-archive [riscv32-nemu] + CC src/platform/nemu/trm.c + CC src/platform/nemu/ioe/ioe.c + CC src/platform/nemu/ioe/timer.c + CC src/platform/nemu/ioe/input.c + CC src/platform/nemu/ioe/gpu.c + CC src/platform/nemu/ioe/audio.c + CC src/platform/nemu/ioe/disk.c + CC src/platform/nemu/mpe.c + AS src/riscv/nemu/start.S + CC src/riscv/nemu/cte.c + AS src/riscv/nemu/trap.S + CC src/riscv/nemu/vme.c + AR -\u0026gt; build/am-riscv32-nemu.a # Building klib-archive [riscv32-nemu] + CC src/stdio.c + CC src/int64.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-riscv32-nemu.a + CC tests/dummy.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/dummy-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/dummy-riscv32-nemu.bin 我们可以知道，这个make其实包含三个步骤：\n第一步： 将am目录下的源文件编译，并打包为归档文件am-riscv32-nemu.a（即为ARCHIVE）。 第二步： 将klib目录下的源文件编译，并打包为归档文件klib-riscv32-nemu.a（即为ARCHIVE）。 第三步： 编译客户程序dummy.c，并将其与之前生成的归档文件一起链接为可执行文件（即为LINKAGE）。 编译选项设置 1 2 3 4 5 6 7 8 AS = $(CROSS_COMPILE)gcc CC = $(CROSS_COMPILE)gcc CXX = $(CROSS_COMPILE)g++ LD = $(CROSS_COMPILE)ld AR = $(CROSS_COMPILE)ar OBJDUMP = $(CROSS_COMPILE)objdump OBJCOPY = $(CROSS_COMPILE)objcopy READELF = $(CROSS_COMPILE)readelf 首先定义交叉编译所需的工具名，这里的CROSS_COMPILE在$(AM_HOME)/scripts/isa中的Makefile被定义。\n1 2 INC_PATH += $(WORK_DIR)/include $(addsuffix /include/, $(addprefix $(AM_HOME)/, $(LIBS))) INCFLAGS += $(addprefix -I, $(INC_PATH)) 随后定义包含的路径，包括当前路径下的include与AM库文件LIBS下的include，并在其前加入-I作为INCFLAGS供编译器使用。\n1 2 3 4 5 6 7 8 9 10 11 ARCH_H := arch/$(ARCH).h CFLAGS += -O2 -MMD -Wall -Werror $(INCFLAGS) \\ -D__ISA__=\\\u0026#34;$(ISA)\\\u0026#34; -D__ISA_$(shell echo $(ISA) | tr a-z A-Z)__ \\ -D__ARCH__=$(ARCH) -D__ARCH_$(shell echo $(ARCH) | tr a-z A-Z | tr - _) \\ -D__PLATFORM__=$(PLATFORM) -D__PLATFORM_$(shell echo $(PLATFORM) | tr a-z A-Z | tr - _) \\ -DARCH_H=\\\u0026#34;$(ARCH_H)\\\u0026#34; \\ -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \\ -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden CXXFLAGS += $(CFLAGS) -ffreestanding -fno-rtti -fno-exceptions ASFLAGS += -MMD $(INCFLAGS) LDFLAGS += -z noexecstack $(addprefix -T, $(LDSCRIPTS)) 这里定义具体的编译/链接选项，此处不作说明。\n1 -include $(AM_HOME)/scripts/$(ARCH).mk 同时，我们包含ARCH架构的Makefile，对前面的选项进行进一步配置。\n目标构建规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ### Rule (compile): a single `.c` -\u0026gt; `.o` (gcc) $(DST_DIR)/%.o: %.c @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CC $\u0026lt; @$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cc` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cc @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cpp` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cpp @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.S` -\u0026gt; `.o` (gcc, which preprocesses and calls as) $(DST_DIR)/%.o: %.S @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + AS $\u0026lt; @$(AS) $(ASFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (recursive make): build a dependent library (am, klib, ...) $(LIBS): %: @$(MAKE) -s -C $(AM_HOME)/$* archive ### Rule (link): objects (`*.o`) and libraries (`*.a`) -\u0026gt; `IMAGE.elf`, the final ELF binary to be packed into image (ld) $(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS) @echo \\# Creating image [$(ARCH)] @echo + LD \u0026#34;-\u0026gt;\u0026#34; $(IMAGE_REL).elf ifneq ($(filter $(ARCH),native),) @$(CXX) -o $@ -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX) else @$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group endif ### Rule (archive): objects (`*.o`) -\u0026gt; `ARCHIVE.a` (ar) $(ARCHIVE): $(OBJS) @echo + AR \u0026#34;-\u0026gt;\u0026#34; $(shell realpath $@ --relative-to .) @$(AR) rcs $@ $^ ### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD` -include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS)))) 这部分是具体的目标构建规则，不作赘述。\n构建顺序定义 1 2 3 4 5 image: image-dep archive: $(ARCHIVE) image-dep: $(LIBS) $(IMAGE).elf .NOTPARALLEL: image-dep .PHONY: image image-dep archive run $(LIBS) 这部分定义了各个目标的依赖关系，当我们构建裸机镜像image时，需要首先构建$(LIBS)及$(IMAGE).elf，$(IMAGE).elf的构建依赖于LINKAGE，这包含了OBJS与LIBS对应的归档文件两部分，构建$(LIBS)时，我们便会使用make archive创建其对应的归档文件。而OBJS的构建则依赖于目标构建规则中的单文件编译。\n至此，我们大致梳理了AM的Makefile架构及实现原理。\n简书Markdown用法：4个空格标记代码块的说明\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMakefile中:=, =, ?=和+=的含义\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-07-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-1/","title":"AM Makefile解读（1）"},{"content":"首先，exec_once()会接收Decode结构体指针 s，以及当前的PC值pc，pc比较好理解，它通常是通过CPU_state结构体cpu中的pc成员传递的，RV32 ISA的CPU_state结构体定义在isa-def.h中：\n1 2 3 4 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); 包含一个寄存器堆与PC寄存器，可以这样说，CPU_state结构体定义了处理器核的状态。\nDecode结构体被定义在decode.h中：\n1 2 3 4 5 6 7 typedef struct Decode { vaddr_t pc; vaddr_t snpc; // static next pc vaddr_t dnpc; // dynamic next pc ISADecodeInfo isa; IFDEF(CONFIG_ITRACE, char logbuf[128]); } Decode; 其定义了当前PC值，以及该指令执行后的下一PC值（这里暂时不说明静态/动态有什么区别），其次，它还定义了一个ISADecodeInfo结构体成员isa，其定义在isa-def.h中：\n1 2 3 typedef struct { uint32_t inst; } MUXDEF(CONFIG_RV64, riscv64_ISADecodeInfo, riscv32_ISADecodeInfo); 不难看出，这其实就是当前的指令。\nexec_once()接收这两个参数后，会首先将CPU的当前PC值pc传递至s中，并将s中的当前PC值与下一静态PC值均设为CPU的当前PC值pc。\n随后，exec_once()会调用isa_exec_once()函数，并将s传递进入该函数，该函数执行完成后，代表当前指令执行完成，随后exec_once()会将s中的下一动态PC值dnpc置为CPU的当前PC值pc，代表执行完成。\n因此，完成指令执行的核心函数是isa_exec_once()，它被定义在inst.c中：\n1 2 3 4 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); return decode_exec(s); } 其使用inst_fetch()获取当前指令（IF），并使用decode_exec()进行指令译码（ID）与执行（EX）。\ninst_fetch()定义在ifetch.h中：\n1 2 3 4 5 static inline uint32_t inst_fetch(vaddr_t *pc, int len) { uint32_t inst = vaddr_ifetch(*pc, len); (*pc) += len; return inst; } 它实际上首先读取了当前PC值对应的指令（并返回），并将s的下一静态PC值加4。其中vaddr_ifetch()定义在vaddr.c中，它目前就是一条简单的读取内存的指令。\n这里，我们就可以理解下一静态PC值与下一动态PC值的区别，下一静态PC值是指在物理存储上，存储于当前指令后的下一条指令的地址，在以字节编址的32位CPU上，成立snpc = pc + 4，下一动态PC值则是在当前指令真正执行完成后，对应的下一PC值，由于跳转指令的存在，其与下一静态PC值并不一定一致。\ndecode_exec()中有较多的宏定义，此处我们修改NEMU的Makefile，使其可以通过：\n1 make raw 输出NEMU各文件对应的预处理文件，在inst.i中，即可获得对应宏展开的结果。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/exec-once/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/exec-once/","title":"exec_once()函数执行逻辑"},{"content":"div指令 1 2 3 4 5 6 7 8 9 10 11 12 XReg src1 = X[rs1]; XReg src2 = X[rs2]; XReg signed_min = (xlen() == 32) ? $signed({1\u0026#39;b1, {31{1\u0026#39;b0}}}) : {1\u0026#39;b1, {63{1\u0026#39;b0}}}; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else if ((src1 == signed_min) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG / -1) X[rd] = signed_min; } else { X[rd] = $signed(src1) / $signed(src2); } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 100 ????? 01100 11\u0026#34;, div , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (~(word_t)0) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (min_val) : ((sword_t)(src1) / (sword_t)(src2)))); divu指令 1 2 3 4 5 6 7 8 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else { X[rd] = src1 / src2; } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 101 ????? 01100 11\u0026#34;, divu , R, R(rd) = (src2 == 0) ? (~(word_t)0) : (src1 / src2)); rem指令 1 2 3 4 5 6 7 8 9 10 11 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = src1; } else if ((src1 == {1\u0026#39;b1, {MXLEN - 1{1\u0026#39;b0}}}) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG % -1) X[rd] = 0; } else { X[rd] = $signed(src1) % $signed(src2); } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 110 ????? 01100 11\u0026#34;, rem , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (src1) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (0) : ((sword_t)(src1) % (sword_t)(src2)))); remu指令 1 2 3 4 5 6 7 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { X[rd] = src1; } else { X[rd] = src1 % src2; } 对应的模式匹配：\n1 INSTPAT(\u0026#34;0000001 ????? ????? 111 ????? 01100 11\u0026#34;, remu , R, R(rd) = (src2 == 0) ? (src1) : (src1 % src2)); ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/riscv32m/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/riscv32m/","title":"RV32M扩展指令的执行逻辑"},{"content":"在使用-march=rv32im_zicsr对测试程序进行编译时，会发现测试对应的除法与取余操作（有符号/无符号）不能被正确编译至div等RV32M扩展指令，原以为是指令集架构选择错误，后续发现是因为当除数是常量时，（如a / 10），编译器可能用更高效的移位/乘法序列替代除法指令或取余指令，为防止该优化，可以在变量声明前加入volatile关键字，指示该变量随时可变，从而限制其优化。\n以下给出一个可以正确编译出RV32M扩展指令的测试程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;trap.h\u0026#34; #define N 10 int signed_arr[N] = {-128, -486, -312, -211, -154, 0, 11113, 26785, 3232, 488976}; unsigned unsigned_arr[N] = {0, 1112, 25678, 33425, 43455, 543421, 634567, 778789, 845653, 92442}; int main() { for (int i = 0; i \u0026lt; N; i++) { for (volatile int j = -N; j \u0026lt;= N; j++) { if (j == 0) { continue; } int quotient, remainder; quotient = signed_arr[i] / j; remainder = signed_arr[i] % j; check(signed_arr[i] == j * quotient + remainder); if (signed_arr[i] \u0026gt;= 0) { check(remainder \u0026gt;= 0 \u0026amp;\u0026amp; remainder \u0026lt; (j \u0026gt; 0 ? j : -j)); } else { check(remainder \u0026lt;= 0 \u0026amp;\u0026amp; remainder \u0026gt; (j \u0026gt; 0 ? -j : j)); } } } for (int i = 0; i \u0026lt; N; i++) { for (volatile unsigned j = 1; j \u0026lt;= N; j++) { unsigned quotient, remainder; quotient = unsigned_arr[i] / j; remainder = unsigned_arr[i] % j; check(unsigned_arr[i] == j * quotient + remainder); check(remainder \u0026lt; j); } } // overflow test volatile int dividend = 1 \u0026lt;\u0026lt; 31; volatile int divisor = -1; int quotient = dividend / divisor; int remainder = dividend % divisor; check(quotient == dividend); check(remainder == 0); return 0; } 对应编译结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 80000000 \u0026lt;_start\u0026gt;: 80000000:\t00000413 li\ts0,0 80000004:\t00009117 auipc\tsp,0x9 80000008:\tffc10113 addi\tsp,sp,-4 # 80009000 \u0026lt;_end\u0026gt; 8000000c:\t1e0000ef jal\tra,800001ec \u0026lt;_trm_init\u0026gt; 80000010 \u0026lt;check\u0026gt;: 80000010:\t00050463 beqz\ta0,80000018 \u0026lt;check+0x8\u0026gt; 80000014:\t00008067 ret 80000018:\tff010113 addi\tsp,sp,-16 8000001c:\t00100513 li\ta0,1 80000020:\t00112623 sw\tra,12(sp) 80000024:\t1bc000ef jal\tra,800001e0 \u0026lt;halt\u0026gt; 80000028 \u0026lt;main\u0026gt;: 80000028:\tfd010113 addi\tsp,sp,-48 8000002c:\t02912223 sw\ts1,36(sp) 80000030:\t03212023 sw\ts2,32(sp) 80000034:\t01312e23 sw\ts3,28(sp) 80000038:\t01412c23 sw\ts4,24(sp) 8000003c:\t02112623 sw\tra,44(sp) 80000040:\t02812423 sw\ts0,40(sp) 80000044:\t01512a23 sw\ts5,20(sp) 80000048:\t00000917 auipc\ts2,0x0 8000004c:\t20490913 addi\ts2,s2,516 # 8000024c \u0026lt;signed_arr\u0026gt; 80000050:\t00000a17 auipc\ts4,0x0 80000054:\t224a0a13 addi\ts4,s4,548 # 80000274 \u0026lt;unsigned_arr\u0026gt; 80000058:\tff600993 li\ts3,-10 8000005c:\t00a00493 li\ts1,10 80000060:\t01312023 sw\ts3,0(sp) 80000064:\t00012783 lw\ta5,0(sp) 80000068:\t06f4c663 blt\ts1,a5,800000d4 \u0026lt;main+0xac\u0026gt; 8000006c:\t00012783 lw\ta5,0(sp) 80000070:\t04078863 beqz\ta5,800000c0 \u0026lt;main+0x98\u0026gt; 80000074:\t00092a83 lw\ts5,0(s2) 80000078:\t00012503 lw\ta0,0(sp) 8000007c:\t00012403 lw\ts0,0(sp) 80000080:\t00012783 lw\ta5,0(sp) 80000084:\t02aac533 div\ta0,s5,a0 80000088:\t028ae433 rem\ts0,s5,s0 8000008c:\t02f50533 mul\ta0,a0,a5 80000090:\t00850533 add\ta0,a0,s0 80000094:\t41550533 sub\ta0,a0,s5 80000098:\t00153513 seqz\ta0,a0 8000009c:\tf75ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000a0:\t00000513 li\ta0,0 800000a4:\t120ac063 bltz\ts5,800001c4 \u0026lt;main+0x19c\u0026gt; 800000a8:\t00044a63 bltz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800000ac:\t00012783 lw\ta5,0(sp) 800000b0:\t00012503 lw\ta0,0(sp) 800000b4:\t10f05463 blez\ta5,800001bc \u0026lt;main+0x194\u0026gt; 800000b8:\t00a42533 slt\ta0,s0,a0 800000bc:\tf55ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000c0:\t00012783 lw\ta5,0(sp) 800000c4:\t00178793 addi\ta5,a5,1 800000c8:\t00f12023 sw\ta5,0(sp) 800000cc:\t00012783 lw\ta5,0(sp) 800000d0:\tf8f4dee3 bge\ts1,a5,8000006c \u0026lt;main+0x44\u0026gt; 800000d4:\t00490913 addi\ts2,s2,4 800000d8:\tf94914e3 bne\ts2,s4,80000060 \u0026lt;main+0x38\u0026gt; 800000dc:\t00000917 auipc\ts2,0x0 800000e0:\t19890913 addi\ts2,s2,408 # 80000274 \u0026lt;unsigned_arr\u0026gt; 800000e4:\t00000a17 auipc\ts4,0x0 800000e8:\t1b8a0a13 addi\ts4,s4,440 # 8000029c \u0026lt;_bss_start\u0026gt; 800000ec:\t00100993 li\ts3,1 800000f0:\t00a00493 li\ts1,10 800000f4:\t01312223 sw\ts3,4(sp) 800000f8:\t00412783 lw\ta5,4(sp) 800000fc:\t04f4e863 bltu\ts1,a5,8000014c \u0026lt;main+0x124\u0026gt; 80000100:\t00092a83 lw\ts5,0(s2) 80000104:\t00412503 lw\ta0,4(sp) 80000108:\t00412403 lw\ts0,4(sp) 8000010c:\t00412783 lw\ta5,4(sp) 80000110:\t02aad533 divu\ta0,s5,a0 80000114:\t028af433 remu\ts0,s5,s0 80000118:\t02f50533 mul\ta0,a0,a5 8000011c:\t00850533 add\ta0,a0,s0 80000120:\t41550533 sub\ta0,a0,s5 80000124:\t00153513 seqz\ta0,a0 80000128:\tee9ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000012c:\t00412503 lw\ta0,4(sp) 80000130:\t00a43533 sltu\ta0,s0,a0 80000134:\teddff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000138:\t00412783 lw\ta5,4(sp) 8000013c:\t00178793 addi\ta5,a5,1 80000140:\t00f12223 sw\ta5,4(sp) 80000144:\t00412783 lw\ta5,4(sp) 80000148:\tfaf4fee3 bgeu\ts1,a5,80000104 \u0026lt;main+0xdc\u0026gt; 8000014c:\t00490913 addi\ts2,s2,4 80000150:\tfb4912e3 bne\ts2,s4,800000f4 \u0026lt;main+0xcc\u0026gt; 80000154:\t800007b7 lui\ta5,0x80000 80000158:\t00f12423 sw\ta5,8(sp) 8000015c:\tfff00793 li\ta5,-1 80000160:\t00f12623 sw\ta5,12(sp) 80000164:\t00812503 lw\ta0,8(sp) 80000168:\t00c12783 lw\ta5,12(sp) 8000016c:\t00812403 lw\ts0,8(sp) 80000170:\t00c12703 lw\ta4,12(sp) 80000174:\t02f54533 div\ta0,a0,a5 80000178:\t00812783 lw\ta5,8(sp) 8000017c:\t02e46433 rem\ts0,s0,a4 80000180:\t40f50533 sub\ta0,a0,a5 80000184:\t00153513 seqz\ta0,a0 80000188:\te89ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000018c:\t00143513 seqz\ta0,s0 80000190:\te81ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000194:\t02c12083 lw\tra,44(sp) 80000198:\t02812403 lw\ts0,40(sp) 8000019c:\t02412483 lw\ts1,36(sp) 800001a0:\t02012903 lw\ts2,32(sp) 800001a4:\t01c12983 lw\ts3,28(sp) 800001a8:\t01812a03 lw\ts4,24(sp) 800001ac:\t01412a83 lw\ts5,20(sp) 800001b0:\t00000513 li\ta0,0 800001b4:\t03010113 addi\tsp,sp,48 800001b8:\t00008067 ret 800001bc:\t40a00533 neg\ta0,a0 800001c0:\tef9ff06f j\t800000b8 \u0026lt;main+0x90\u0026gt; 800001c4:\tee804ce3 bgtz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800001c8:\t00012783 lw\ta5,0(sp) 800001cc:\t00012503 lw\ta0,0(sp) 800001d0:\t00f05463 blez\ta5,800001d8 \u0026lt;main+0x1b0\u0026gt; 800001d4:\t40a00533 neg\ta0,a0 800001d8:\t00852533 slt\ta0,a0,s0 800001dc:\tee1ff06f j\t800000bc \u0026lt;main+0x94\u0026gt; 800001e0 \u0026lt;halt\u0026gt;: 800001e0:\t00050513 mv\ta0,a0 800001e4:\t00100073 ebreak 800001e8:\t0000006f j\t800001e8 \u0026lt;halt+0x8\u0026gt; 800001ec \u0026lt;_trm_init\u0026gt;: 800001ec:\tff010113 addi\tsp,sp,-16 800001f0:\t00000517 auipc\ta0,0x0 800001f4:\t01c50513 addi\ta0,a0,28 # 8000020c \u0026lt;_etext\u0026gt; 800001f8:\t00112623 sw\tra,12(sp) 800001fc:\te2dff0ef jal\tra,80000028 \u0026lt;main\u0026gt; 80000200:\t00050513 mv\ta0,a0 80000204:\t00100073 ebreak 80000208:\t0000006f j\t80000208 \u0026lt;_trm_init+0x1c\u0026gt; ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/div/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/div/","title":"关于div等RV32M指令无法编译的问题"},{"content":"在NPC中使用C++实现存储器时，对NEMU中的存储器写入/读出函数有了一些新的认识，现总结如下：\n此处我们为方便说明，仅考查与物理存储器直接交互的函数，即pmem，NEMU首先在paddr.c中定义了两个static函数，分别为pmem_read()与pmem_write()，用于对pmem进行直接读写。\n同时，因为这两个函数被声明为static，其无法通过其他文件访问/调用，因此paddr.c中还定义了外部访问的接口paddr_read()与paddr_write()，这两个函数会对输入的地址进行有效性检测，随后再通过调用pmem_read()与pmem_write()实现存储器访问。\n我们再看pmem_read()与pmem_write()的具体实现：\n对pmem_read()：\n1 2 3 4 static word_t pmem_read(paddr_t addr, int len) { word_t ret = host_read(guest_to_host(addr), len); return ret; } 该函数内部会嵌套调用两个函数，guest_to_host()与host_read()，其中guest_to_host()用于将输入的pmem的物理地址addr转换成实际PC存储器中的地址，实现如下：\n1 uint8_t* guest_to_host(paddr_t paddr) { return pmem + paddr - CONFIG_MBASE; } 具体实现原理即为通过pmem所在的基址，加上paddr - CONFIG_MBASE的偏移量，即获得了对应的PC存储器地址，其中CONFIG_BASE代表pmem的最低地址。\n同时注意，由于该函数输出的是字节编址的实际PC存储器地址，因此对应的返回类型是uint8_t*，为一个无符号字节类型的指针。\n再看host_read()的实现，在host.h中：\n1 2 3 4 5 6 7 8 9 static inline word_t host_read(void *addr, int len) { switch (len) { case 1: return *(uint8_t *)addr; case 2: return *(uint16_t *)addr; case 4: return *(uint32_t *)addr; IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr); default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0); } } 这里其实是依据读出字节数len的取值，对实际PC存储器地址进行强制类型转换，并通过解引用*获取对应的值，比如当len = 2时，代表需要读取2字节数据，因此我们将addr强制类型转换为uint16_t*类型，使其指向一个双字节存储空间，再通过解引用获得该存储空间对应的值。\npaddr_write()的实现原理类似，此处不作赘述。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/nemu-memory/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-memory/","title":"关于NEMU存储器访问的细节"},{"content":"在使用Verilator对RTL代码进行仿真时，其仿真原理与普通RTL代码编写的Testbench存在差异，具体而言，在Verilator中，仿真步长这一概念是需要通过wrapper文件自行控制的，我们需要明确仿真在哪些时间点需要采样并eval()，而在传统RTL代码编写的Testbench中，仿真步长通常是通过timescale声明的，EDA会识别并自动设置仿真步长。\n这种原理上的差异会造成Verilator与传统EDA在仿真时存在两方面的区别：\n性能上的差异： Verilator的仿真原理其实可概括为“当用户需要时，才对某个时间点采样与eval()”，而传统EDA的仿真原理则可简单理解为“定步长对每个时间点都进行采样与eval()“。因此，Verilator相对而言可以较敏捷地完成仿真，因为在仿真过程中，其实并没有对所有时间点均进行采样与eval()。 波形质量上的差异： 传统EDA的定步长仿真使得其仿真获得的波形具有相当高的可信度，基本可以与实测波形等同。但Verilator的波形质量高度依赖于wrapper文件的写法，一个低质量或写法错误的wrapper文件完全有可能生成与实际情况完全不同的波形，举一个简单的例子，假设我们一直仅对模块进行激励而不调用eval()，那么波形不会有任何有效信息，更具体一些，如果我们改变某个端口的激励值而未及时进行eval()，可能导致某个信号值在波形中被错误地延迟一个或多个时钟周期。 因此，有必要探究有效的wrapper文件写法，因为当我们需要通过波形对模块进行debug时，我们自然不希望最后发现是wrapper文件的写法导致生成不符合预期的波形。\n首先，我们需要明确，在wrapper文件中，其主要实现了两类操作，第一是实现激励信号的变化并重新对被测模块进行eval()，第二则是实现波形中时间的推移，为此，我们给出一个模式化的wrapper文件写法：\n1 2 3 #define Vtop Vysyx_25070184_top // nickname #define CLK_NAME clk // clock name #define CLK_HALF_PERIOD 5 // clock period / 2 在文件开头，我们实现了几个宏定义，将被测顶层模块名统一为top，将时钟名称统一为CLK_NAME，并定义仿真时的半时钟周期长度CLK_HALF_PERIOD。\n1 2 #define EDGE_TRG_EVENT(top, event) do { top-\u0026gt;CLK_NAME = !top-\u0026gt;CLK_NAME; top-\u0026gt;eval(); event; top-\u0026gt;eval(); } while (0) #define EDGE_TRG(top) EDGE_TRG_EVENT(top, ) 其次，我们实现了另外两个宏定义，用于实现激励信号的变化，EDGE_TRG_EVENT宏用于实现一个被时钟边沿驱动的事件event，其主要会进行如下两个操作：\n翻转当前时钟取值，进行eval()。 执行事件event，再次进行eval()。 这个宏定义其实相当于传统RTL实现的Testbench中的@(posedge/negedge clk) event;。\n另外一个宏定义EDGE_TRG则相当于仅对时钟进行翻转并eval()，而不存在其他事件的执行。\n最后，我们定义另外一个函数half_cycle()实现波形时间的推移：\n1 2 3 4 5 void half_cycle(Vtop* top, VerilatedContext* contextp, VerilatedFstC *tfp) { top-\u0026gt;eval(); contextp-\u0026gt;timeInc(CLK_HALF_PERIOD); tfp-\u0026gt;dump(contextp-\u0026gt;time()); } 该函数会在波形中产生半时钟周期的时间推移，因为在狭义的同步时序电路中，半时钟周期相当于一个最小的时间步长，在这一时间间隔内不应当有任何信号存在变化。\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/verilator/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/verilator/","title":"浅析Verilator的wrapper文件写法"}]
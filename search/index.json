[{"content":"æœ¬æ–‡ä¸»è¦è®¨è®ºDICä¸­çš„ åºåˆ—æ£€æµ‹å™¨ï¼ˆSequence Detectorï¼‰ ç”µè·¯è®¾è®¡ï¼Œè¿™æ˜¯ä¸€ç§éå¸¸ç»å…¸çš„åŠŸèƒ½æ€§ç”µè·¯ï¼Œå®ƒé€šå¸¸ç”¨äºæ£€æµ‹äºŒè¿›åˆ¶åºåˆ—è¾“å…¥ä¸­çš„æŸä¸ªç‰¹å®šæ¨¡å¼çš„å­åºåˆ—ï¼Œå…¶æ¨¡å—ç«¯å£å£°æ˜é€šå¸¸å¦‚ä¸‹æ‰€ç¤ºï¼š\n1 2 3 4 5 6 7 8 module seq_detector ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); /* internal logic */ endmodule åºåˆ—æ£€æµ‹é—®é¢˜çš„åˆ†ç±» ç›®å‰ç½‘ä¸Šçš„åšå®¢å·²å¯¹åºåˆ—æ£€æµ‹é—®é¢˜è¿›è¡Œäº†éå¸¸è¯¦ç»†çš„åˆ†ç±»1ï¼Œå…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬å¯ä»¥ä»æ£€æµ‹é—®é¢˜æœ¬èº«ä¸ç”µè·¯è®¾è®¡ä¸¤ä¸ªæ–¹é¢å¯¹å…¶è¿›è¡Œåˆ†ç±»ï¼š\nä»åºåˆ—æ£€æµ‹é—®é¢˜æœ¬èº«ï¼Œå…¶å¯åˆ†ä¸ºé‡å¤æ£€æµ‹ä¸éé‡å¤æ£€æµ‹ä¸¤ç±»ï¼š\né‡å¤æ£€æµ‹æŒ‡åœ¨è¾“å…¥æ•°æ®æµä¸­ï¼Œè‹¥å·²åŒ¹é…åºåˆ—çš„å°¾éƒ¨ä¸åç»­è¾“å…¥æ„æˆæ–°çš„æœ‰æ•ˆåºåˆ—ï¼ˆå³å­˜åœ¨é‡å éƒ¨åˆ†ï¼‰ï¼Œåˆ™å…è®¸è¿ç»­å¤šæ¬¡è§¦å‘åŒ¹é…ä¿¡å·ã€‚æ£€æµ‹å™¨åœ¨å®Œæˆä¸€æ¬¡åŒ¹é…åï¼Œä¸å¼ºåˆ¶å›åˆ°åˆå§‹çŠ¶æ€ã€‚å¸¸ç”¨äºéœ€è¦æ•è·æ‰€æœ‰å¯èƒ½å®ä¾‹çš„åœºæ™¯ï¼ˆå¦‚é€šä¿¡åè®®ä¸­çš„å¸§å¤´æ£€æµ‹ï¼‰ã€‚ éé‡å¤æ£€æµ‹æŒ‡ä¸€æ—¦åŒ¹é…åˆ°å®Œæ•´çš„ç›®æ ‡åºåˆ—ï¼Œæ£€æµ‹å™¨ç«‹å³å¤ä½åˆ°åˆå§‹çŠ¶æ€ï¼Œå¿½ç•¥è¯¥åºåˆ—å°¾éƒ¨å¯èƒ½å‚ä¸æ„æˆçš„æ–°çš„æœ‰æ•ˆåºåˆ—ã€‚ é‡å¤åŒ¹é…ä¸éé‡å¤åŒ¹é…çš„æœ¬è´¨åŒºåˆ«åœ¨äºåœ¨å®ŒæˆåŒ¹é…åçš„çŠ¶æ€è·³è½¬ã€‚\nä»ç”µè·¯è®¾è®¡è§’åº¦ï¼Œå…¶å¯åˆ†ä¸ºçŠ¶æ€æœºå‹ä¸ç§»ä½å¯„å­˜å™¨å‹ä¸¤ç±»ï¼š\nçŠ¶æ€æœºå‹ç”µè·¯å³æ˜¯å¯¹åºåˆ—æ£€æµ‹é—®é¢˜è¿›è¡Œè¡Œä¸ºçº§å»ºæ¨¡ï¼Œåœ¨å„äºŒè¿›åˆ¶æ¯”ç‰¹è¾“å…¥ä¹‹ååˆ¤æ–­æ˜¯å¦åŒ¹é…ï¼Œè‹¥åŒ¹é…åˆ™è¿›å…¥ä¸‹ä¸€çŠ¶æ€ï¼Œä¸åŒ¹é…åˆ™æ ¹æ®è¾“å…¥æ•°æ®ä¸åºåˆ—æ£€æµ‹çš„ç±»å‹å…·ä½“åˆ¤æ–­è¿›å…¥çš„ä¸‹ä¸€çŠ¶æ€ã€‚ ç§»ä½å¯„å­˜å™¨å‹ç”µè·¯çš„æ€è·¯åˆ™ç›¸å¯¹ç®€å•ï¼Œå…¶åŸºæœ¬åŸç†æ˜¯ç›®æ ‡åºåˆ—ä¸ç¼“å­˜æ•°æ®çš„å¯¹æ¯”ï¼šæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªä¸ç›®æ ‡åºåˆ—ç­‰ä½å®½çš„ç§»ä½å¯„å­˜å™¨ç¼“å­˜è¾“å…¥çš„åºåˆ—ï¼Œå½“è¯¥ç¼“å­˜åºåˆ—ä¸ç›®æ ‡åºåˆ—ä¸€è‡´æ—¶ï¼Œåˆ™ä»£è¡¨åŒ¹é…æˆåŠŸã€‚ è¿™ä¸¤ç±»ç”µè·¯çš„RTLæè¿°éƒ½è¾ƒä¸ºç®€å•ï¼Œæ­¤å¤„ä¸ä½œèµ˜è¿°ã€‚\nåºåˆ—æ£€æµ‹å™¨çš„ç”µè·¯è®¾è®¡ æœ¬èŠ‚ç®€è¦è®¨è®ºçŠ¶æ€æœºå‹ä¸ç§»ä½å¯„å­˜å™¨å‹ä¸¤ç±»åºåˆ—æ£€æµ‹å™¨çš„é—¨çº§ç”µè·¯å®ç°ã€‚å› ä¸ºåœ¨æŸäº›é¢è¯•ä¸­ï¼Œé™¤äº†æ‰‹æ’•ä»£ç å¤–ï¼Œå¯èƒ½è¿˜æ¶‰åŠå¯¹ç”µè·¯åŸç†å›¾çš„ç»˜åˆ¶ã€‚\nå¯¹äºçŠ¶æ€æœºå‹åºåˆ—æ£€æµ‹å™¨ï¼Œè¯¥ç”µè·¯æ˜¯éå¸¸å…¸å‹çš„Mealyå‹çŠ¶æ€æœº2ï¼Œå¯¹äºä½å®½ä¸º$N$çš„åºåˆ—ï¼Œå¯ä»¥å»ºæ¨¡ä¸€ä¸ªçŠ¶æ€ä½å®½ä¸º$M=\\lceil\\log_2(N)\\rceil$çš„çŠ¶æ€æœºå®ç°åºåˆ—æ£€æµ‹ï¼Œä¹‹åä¾¿åŒ–å½’ä¸ºæœ€åŸºæœ¬çš„åŸºäºçŠ¶æ€è½¬æ¢å›¾æ¨å¯¼çŠ¶æ€è½¬æ¢æ–¹ç¨‹çš„é—®é¢˜ï¼š $$ (Q_{n+1}^1,~Q_{n+1}^2, ~\\cdots,~Q_{n+1}^M) = \\vec{f}(Q_{n}^1,~Q_{n}^2, ~\\cdots,~Q_{n}^M,~\\text{Input}) $$ å¾—åˆ°çŠ¶æ€è½¬æ¢æ–¹ç¨‹åï¼Œæˆ‘ä»¬å¯ä»¥ç»˜åˆ¶å¯¹åº”çš„çŠ¶æ€æœºç”µè·¯ï¼Œè€Œå¯¹åºåˆ—åŒ¹é…è¾“å‡ºmatchï¼Œåªéœ€è¦å†åŠ ä¸€çº§æ¯”è¾ƒå½“å‰çŠ¶æ€ä¸åºåˆ—åŒ¹é…çŠ¶æ€æ˜¯å¦ç›¸ç­‰çš„ç»„åˆé€»è¾‘å³å¯ã€‚\nå¯¹äºç§»ä½å¯„å­˜å™¨å‹åºåˆ—æ£€æµ‹å™¨ï¼Œå¯¹äºä½å®½ä¸º$N$çš„åºåˆ—ï¼Œæˆ‘ä»¬åªéœ€è¦å°†$N$ä¸ªDè§¦å‘å™¨çº§è”æ„æˆç§»ä½å¯„å­˜å™¨ï¼Œå¹¶å°†å…¶å„ä½çš„è¾“å‡ºå¼•å‡ºå®ç°ä¸ç›®æ ‡åºåˆ—çš„æ¯”è¾ƒå³å¯ã€‚\nåºåˆ—æ£€æµ‹å™¨çš„å‚æ•°åŒ–è®¾è®¡ åœ¨è®¨è®ºå®Œåºåˆ—æ£€æµ‹å™¨çš„åˆ†ç±»ä¸ç”µè·¯å®ç°åï¼Œæˆ‘ä»¬éœ€è¦è€ƒæŸ¥çŠ¶æ€æœºå‹ä¸ç§»ä½å¯„å­˜å™¨å‹ä¸¤ç±»åºåˆ—æ£€æµ‹å™¨å¯¹é‡å¤æ£€æµ‹ä¸éé‡å¤æ£€æµ‹ä¸¤ç±»åºåˆ—æ£€æµ‹é—®é¢˜çš„é€‚é…æ€§ã€‚åœ¨ä¸€äº›åšå®¢ä¸­1ï¼Œä¼šç»™å‡ºâ€œçŠ¶æ€æœºå‹åºåˆ—æ£€æµ‹å™¨å¯ä»¥åŒæ—¶å¤„ç†é‡å¤æ£€æµ‹ä¸éé‡å¤æ£€æµ‹ä¸¤ç±»åºåˆ—æ£€æµ‹é—®é¢˜ï¼Œä½†ç§»ä½å¯„å­˜å™¨å‹åºåˆ—æ£€æµ‹å™¨åªèƒ½å¤„ç†é‡å¤æ£€æµ‹åºåˆ—æ£€æµ‹é—®é¢˜â€çš„ç»“è®ºï¼Œè¿™ä¸€ç»“è®ºå®é™…ä¸Šæ˜¯é”™è¯¯çš„ï¼Œæœ¬èŠ‚å°†è¿›è¡Œç®€è¦è®¨è®ºã€‚\né¦–å…ˆï¼ŒçŠ¶æ€æœºå‹åºåˆ—æ£€æµ‹å™¨å¯ä»¥åŒæ—¶å¤„ç†é‡å¤æ£€æµ‹ä¸éé‡å¤æ£€æµ‹ä¸¤ç±»åºåˆ—æ£€æµ‹é—®é¢˜ï¼Œè¿™ä¸€ç»“è®ºæ˜¯æ­£ç¡®çš„ï¼Œå› ä¸ºçŠ¶æ€è½¬æ¢é€»è¾‘å¯ä»¥æ ¹æ®é—®é¢˜ç±»å‹çµæ´»å˜åŒ–ã€‚\nä½†æ˜¯ï¼Œå¯¹äºç§»ä½å¯„å­˜å™¨å‹åºåˆ—æ£€æµ‹å™¨ï¼Œå…¶ä¸ä»…å¯ä»¥å¤„ç†åºåˆ—çš„é‡å¤æ£€æµ‹é—®é¢˜ï¼ˆè¿™æ˜¯æ˜¾ç„¶çš„ï¼‰ï¼Œä¹Ÿå¯ä»¥å¤„ç†åºåˆ—çš„éé‡å¤æ£€æµ‹é—®é¢˜ã€‚å¯¹äºéé‡å¤æ£€æµ‹ï¼Œæˆ‘ä»¬éœ€è¦æ„è¯†åˆ°ç§»ä½å¯„å­˜å™¨ä¸­å­˜å‚¨çš„åºåˆ—æœ¬èº«å°±æ˜¯ç”µè·¯çš„ â€œçŠ¶æ€â€ ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬åªéœ€å°†åºåˆ—åŒ¹é…è¾“å‡ºä¿¡å·matchåé¦ˆè‡³ç§»ä½å¯„å­˜å™¨ï¼Œä½¿ç§»ä½å¯„å­˜å™¨åœ¨åºåˆ—åŒ¹é…æ—¶å¤ä½å³å¯ã€‚\nç§»ä½å¯„å­˜å™¨çš„å¤ä½ï¼šæˆ‘ä»¬éœ€è¦æ€è€ƒä¸€ä¸ªé—®é¢˜ï¼Œç§»ä½å¯„å­˜å™¨çš„å¤ä½å…·ä½“æŒ‡ä»€ä¹ˆï¼Ÿæˆ‘ä»¬å¯ä»¥å°†æ¸…é›¶ä¸å¤ä½å®Œå…¨ç­‰ä»·å—ï¼Ÿç­”æ¡ˆæ˜¯å¦å®šçš„ï¼Œå‡è®¾æˆ‘ä»¬éœ€è¦æ£€æµ‹çš„åºåˆ—æ˜¯4'b0011ï¼Œé«˜ä½å…ˆè¾“å…¥ï¼Œè€Œæˆ‘ä»¬å°†ç§»ä½å¯„å­˜å™¨æ¸…é›¶åï¼Œç§»ä½å¯„å­˜å™¨çš„æœ€ä½ä½ä¾¿æ˜¯1'b0ï¼Œæ­¤æ—¶æˆ‘ä»¬å¦‚æœè¾“å…¥3'b011ï¼Œæœ€ä½ä½çš„å¤ä½å€¼ç§»ä½è‡³æœ€é«˜ä½ï¼Œç§»ä½å¯„å­˜å™¨çš„å€¼å˜ä¸º4'b0011ï¼Œç§»ä½å¯„å­˜å™¨ä¹Ÿä¼šé”™è¯¯åœ°å°†è¯¥åºåˆ—è§†ä¸ºåŒ¹é…åºåˆ—ã€‚\næ‰€ä»¥ï¼Œä¸ºé¿å…è¿™ä¸€ç‚¹ï¼Œç§»ä½å¯„å­˜å™¨çš„å¤ä½å€¼éœ€è¦ä¾æ®åŒ¹é…çš„åºåˆ—è¿›è¡ŒæŒ‡å®šã€‚å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬å¿…é¡»ä¿è¯ç§»ä½å¯„å­˜å™¨å„ä½çš„å¤ä½å€¼ä¸ç›®æ ‡åºåˆ—æœ€é«˜ä½ç›¸åï¼ˆé»˜è®¤é«˜ä½å…ˆè¾“å…¥ï¼‰ï¼Œè¿™æ ·å¯ä»¥ä¿è¯åœ¨ç§»ä½å¯„å­˜å™¨å¤ä½åˆ°ç§»ä½å¯„å­˜å™¨å¤ä½å€¼å®Œå…¨è¢«è¾“å…¥åºåˆ—è¦†ç›–è¿™ä¸€æ®µæ—¶é—´å†…ï¼Œä¸ä¼šå‘ç”Ÿé”™è¯¯çš„åºåˆ—åŒ¹é…ã€‚\næ‰€ä»¥ï¼ŒåŸºäºä¸Šè¿°è¯´æ˜ï¼Œå¹¶ä¸å­˜åœ¨â€œçŠ¶æ€æœºå‹åºåˆ—æ£€æµ‹å™¨æ¯”ç§»ä½å¯„å­˜å™¨å‹åºåˆ—æ£€æµ‹å™¨æ›´çµæ´»â€çš„è¯´æ³•ï¼Œç›¸åï¼Œç§»ä½å¯„å­˜å™¨ç®€æ´çš„ç»“æ„ä¸åŸç†ï¼Œä½¿å…¶å¯ä»¥å®ç°åºåˆ—åŒ¹é…ç”µè·¯çš„å‚æ•°åŒ–è®¾è®¡ï¼Œè€Œè¿™æ˜¯çŠ¶æ€æœºå‹ç”µè·¯éš¾ä»¥å®ç°çš„ï¼š\nå¯¹äºéé‡å¤æ£€æµ‹ï¼Œå¯¹åº”çš„åºåˆ—æ£€æµ‹ç”µè·¯å¯å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module seq_detector #( parameter SEQ = 8\u0026#39;h5A, parameter SEQ_LEN = 8 ) ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); // shift register reg [SEQ_LEN-1:0] shift_reg; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else begin shift_reg \u0026lt;= {shift_reg[SEQ_LEN-2:0], data_in}; // bit shift end end // compare output always @(posedge clk or negedge rst_n) begin if (~rst_n) begin match \u0026lt;= 1\u0026#39;b0; end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin match \u0026lt;= 1\u0026#39;b1; end else begin match \u0026lt;= 1\u0026#39;b0; end end endmodule å¯¹äºé‡å¤æ£€æµ‹ï¼Œæˆ‘ä»¬åªéœ€æ¶ˆé™¤åºåˆ—åŒ¹é…è¾“å‡ºä¿¡å·çš„åé¦ˆè·¯å¾„å³å¯ï¼Œå¯¹åº”çš„åºåˆ—æ£€æµ‹ç”µè·¯å¯å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 module seq_detector #( parameter SEQ = 8\u0026#39;h5A, parameter SEQ_LEN = 8 ) ( input wire clk, // system clock input wire rst_n, // reset input wire data_in, // serial data input output reg match // detected signal ); // shift register reg [SEQ_LEN-1:0] shift_reg; always @(posedge clk or negedge rst_n) begin if (~rst_n) begin shift_reg \u0026lt;= {(SEQ_LEN){~SEQ[SEQ_LEN-1]}}; // diff MSB end else begin shift_reg \u0026lt;= {shift_reg[SEQ_LEN-2:0], data_in}; // bit shift end end // compare output always @(posedge clk or negedge rst_n) begin if (~rst_n) begin match \u0026lt;= 1\u0026#39;b0; end else if (shift_reg == SEQ[SEQ_LEN-1:0]) begin match \u0026lt;= 1\u0026#39;b1; end else begin match \u0026lt;= 1\u0026#39;b0; end end endmodule åŒæ—¶æˆ‘ä»¬æä¾›ä¸€ä¸ªç®€å•çš„Testbenchï¼Œå…¶æ£€æµ‹åºåˆ—æ¨¡å¼ä¸º4'b1001ï¼Œå¯¹åº”è¾“å…¥åºåˆ—ä¸º13'b1001001001001ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 module test (); // clock generate reg clk; always #1 clk = ~clk; // module instantiate reg rst_n, data_in; wire match; seq_detector #( .SEQ (4\u0026#39;b1001 ), .SEQ_LEN (4 ) ) u_seq_detector ( .clk (clk ), .rst_n (rst_n ), .data_in (data_in ), .match (match ) ); // stimulus reg [12:0] serial_in; initial begin clk = 1\u0026#39;b0; rst_n = 1\u0026#39;b0; data_in = 1\u0026#39;b0; serial_in = 13\u0026#39;b1001001001001; #10; @(posedge clk); rst_n = 1\u0026#39;b1; data_in = serial_in[12]; for (integer i = 11; i \u0026gt;= 0; i = i - 1) begin @(posedge clk); data_in = serial_in[i]; end @(posedge clk); $stop; end // waveform initial begin $dumpfile(\u0026#34;wave.vcd\u0026#34;); $dumpvars(0, test); end endmodule å¦å¤–ï¼Œåœ¨ç”µè·¯é¢ç§¯ä¸Šï¼Œå‡è®¾éœ€æ£€æµ‹çš„åºåˆ—ä½å®½ä¸º$N$ï¼Œåˆ™çŠ¶æ€æœºå‹ç”µè·¯çš„é¢ç§¯$\\propto \\log N$ï¼ˆå‡è®¾ç”µè·¯é¢ç§¯ä¸»è¦ç”±Dè§¦å‘å™¨çš„ä¸ªæ•°å†³å®šï¼‰ï¼Œè€Œç§»ä½å¯„å­˜å™¨å‹ç”µè·¯çš„é¢ç§¯$\\propto N$ã€‚åŒæ—¶ï¼Œç§»ä½å¯„å­˜å™¨å‹ç”µè·¯å…·æœ‰ç›¸å¯¹çŸ­çš„å…³é”®è·¯å¾„ï¼Œå› æ­¤å¯ä»¥è¾¾åˆ°ç›¸å½“é«˜çš„å·¥ä½œé¢‘ç‡ã€‚\nåºåˆ—æ£€æµ‹å™¨ï¼ˆä¸¤ç§è®¾è®¡æ–¹æ³•å’Œå››ç§æ£€æµ‹æ¨¡å¼|verilogä»£ç |Testbench|ä»¿çœŸç»“æœï¼‰\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nè¾“å‡ºä¿¡å·ä¸ä»…å–å†³äºå½“å‰çŠ¶æ€ï¼Œè¿˜å–å†³äºè¾“å…¥ä¿¡å·çš„å€¼ã€‚å¯¹åº”åœ°ï¼ŒMooreå‹çŠ¶æ€æœºçš„è¾“å‡ºä¿¡å·åªå–å†³äºå½“å‰çŠ¶æ€ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-06T12:00:00Z","image":"https://posvirus.github.io/p/dic-003/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-003/","title":"åºåˆ—æ£€æµ‹"},{"content":"taskä¸functionçš„åŒºåˆ« ä»»åŠ¡ï¼ˆtaskï¼‰ä¸å‡½æ•°ï¼ˆfunctionï¼‰ä¸¤ç±»è¯­å¥åœ¨æ ‡å‡†ä¸­çš„ ç¬¬10ç« ï¼ˆTasks and functionsï¼‰ åšäº†è¯¦ç»†è®¨è®ºï¼Œä»¥ä¸‹æˆ‘ä»¬ä»¥åŸæ–‡ä¸ºåŸºç¡€è¿›è¡Œè®¨è®ºè¯´æ˜ï¼š\n[10.1] The following rules distinguish tasks from functions:\nA function shall execute in one simulation time unit; a task can contain time-controlling statements. A function cannot enable a task; a task can enable other tasks and functions. A function shall have at least one input type argument and shall not have an output or inout type argument; a task can have zero or more arguments of any type. A function shall return a single value; a task shall not return a value. ä¸Šæ–‡ä¸»è¦ç»™å‡ºäº†taskä¸functionçš„å››ç‚¹ä¸åŒï¼š\né¦–å…ˆï¼Œå‡½æ•°å¿…é¡»åœ¨ä¸€ä¸ªä»¿çœŸæ—¶é—´å•ä½å†…æ‰§è¡Œå®Œæ¯•ï¼›è€Œä»»åŠ¡å¯ä»¥åŒ…å«æ§åˆ¶ä»¿çœŸæ—¶é—´çš„è¯­å¥ã€‚è¿™å¥è¯çš„æ„æ€æ˜¯å‡½æ•°ä¸èƒ½æ¶ˆè€—ä»¿çœŸæ—¶é—´ã€‚æ¢è¨€ä¹‹ï¼Œå‡½æ•°çš„æ‰§è¡Œè¢«è®¤ä¸ºæ˜¯ç¬æ—¶å®Œæˆçš„ï¼Œåœ¨è°ƒç”¨å®ƒçš„é‚£ä¸ªä»¿çœŸæ—¶é—´ç‚¹ä¸Šç«‹å³è¿”å›ç»“æœã€‚å› æ­¤ï¼Œå‡½æ•°å†…éƒ¨ä¸å…è®¸å‡ºç°ä»»ä½•ä¼šå»¶è¿Ÿä»¿çœŸæ—¶é—´çš„è¯­å¥ã€‚è€Œä»»åŠ¡å¯ä»¥åŒ…å«ä»»ä½•æ—¶åºæ§åˆ¶è¯­å¥ï¼Œå› æ­¤å®ƒå¯ä»¥è·¨è¶Šå¤šä¸ªä»¿çœŸæ—¶é—´å•ä½æ‰§è¡Œ1ã€‚ å‡½æ•°ä¸èƒ½ ä½¿èƒ½ï¼ˆenableï¼‰ä»»åŠ¡ï¼Œè€Œä»»åŠ¡å¯ä»¥ä½¿èƒ½å…¶å®ƒä»»åŠ¡ä¸å‡½æ•°ã€‚æ³¨æ„ï¼Œè¿™é‡Œçš„ä½¿èƒ½å¯ä»¥ç†è§£ä¸ºè°ƒç”¨å¹¶æ‰§è¡Œï¼Œå³æŸä¸ªä»»åŠ¡å¯ä»¥åœ¨å…¶å†…éƒ¨è°ƒç”¨å…¶å®ƒå‡½æ•°æˆ–ä»»åŠ¡ï¼Œå¹¶ä½¿å…¶åœ¨ä»¿çœŸè¿è¡Œæ—¶è¢«è§¦å‘æ‰§è¡Œã€‚è‡³äºä¸ºä»€ä¹ˆè§„å®šå‡½æ•°ä¸èƒ½ä½¿èƒ½ä»»åŠ¡ï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆç¬¬ä¸€æ¡å·®å¼‚ç†è§£ï¼Œå› ä¸ºå‡½æ•°æ˜¯ç¬æ—¶æ‰§è¡Œå®Œæˆçš„ï¼Œå¦‚æœåœ¨å…¶ä¸­å¼•å…¥å¯è·¨è¶Šå¤šä¸ªä»¿çœŸæ—¶é—´å•ä½æ‰§è¡Œçš„ä»»åŠ¡ï¼Œåˆ™ä¼šå¯¼è‡´æœªå®šä¹‰çš„è¡Œä¸ºã€‚ å‡½æ•°è‡³å°‘éœ€è¦æœ‰ä¸€ä¸ªinputç±»å‹çš„å‚æ•°ï¼Œä¸”ä¸èƒ½æœ‰outputæˆ–inoutç±»å‹çš„å‚æ•°ã€‚è€Œä»»åŠ¡å¯ä»¥æœ‰ä»»æ„ä¸ªä»»æ„ç±»å‹çš„å‚æ•°ã€‚ å‡½æ•°éœ€è¦ä¸€ä¸ªè¿”å›å€¼ï¼Œè€Œä»»åŠ¡ä¸åº”å­˜åœ¨è¿”å›å€¼ã€‚ [10.1] The purpose of a function is to respond to an input value by returning a single value. A task can support multiple goals and can calculate multiple result values. However, only the output or inout type arguments pass result values back from the invocation of a task. A function is used as an operand in an expression; the value of that operand is the value returned by the function.\nä¸Šæ–‡å½’çº³äº†taskä¸functionè¯­å¥çš„ç›®çš„ï¼Œæ€»ä½“è€Œè¨€ï¼Œå‡½æ•°ä¸»è¦æ˜¯ä¸ºäº†å°±æŸä¸€è¾“å…¥å€¼è¿”å›å•ä¸€çš„è¾“å‡ºå€¼ï¼Œå…¶é€šå¸¸ä½œä¸ºè¡¨è¾¾å¼å†…çš„æ“ä½œæ•°ã€‚è€Œä»»åŠ¡åˆ™å¯ä»¥æ”¯æŒæ›´çµæ´»çš„åŠŸèƒ½ï¼Œè¾“å‡ºæ›´å¤šçš„è¿”å›å€¼ï¼Œä»»åŠ¡çš„è¿”å›å€¼é€šå¸¸é€šè¿‡outputä¸inoutç±»å‹çš„å‚æ•°è¿›è¡Œä¼ é€’ã€‚\næœ‰å…³taskä¸functionçš„å…¶å®ƒæ³¨æ„ç‚¹ æœ¬èŠ‚ä¸»è¦ç»“åˆæ ‡å‡†è¯´æ˜æœ‰å…³taskä¸functionçš„ä¸€äº›å…¶ä»–çŸ¥è¯†ç‚¹ï¼š\n[10.2.1] Tasks without the optional keyword automatic are static tasks, with all declared items being statically allocated. These items shall be shared across all uses of the task executing concurrently. Task with the optional keyword automatic are automatic tasks. All items declared inside automatic tasks are allocated dynamically for each invocation. Automatic task items cannot be accessed by hierarchical references. Automatic tasks can be invoked through use of their hierarchical name.\n[10.4.1] The keyword automatic declares an automatic function that is reentrant, with all the function declarations allocated dynamically for each concurrent function call. Automatic function items cannot be accessed by hierarchical references. Automatic functions can be invoked through the use of their hierarchical name\nç¬¬ä¸€æ˜¯å‡½æ•°ä¸ä»»åŠ¡çš„è°ƒç”¨ï¼Œåœ¨è¯¥æ–¹é¢æ ‡å‡†å¯¹å‡½æ•°ä¸ä»»åŠ¡çš„è§„å®šæ˜¯ç±»ä¼¼çš„ï¼Œå› æ­¤æˆ‘ä»¬ä»…ä»¥ä»»åŠ¡ä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼š\næ ‡å‡†è§„å®šï¼Œå¦‚æœå®šä¹‰çš„ä»»åŠ¡æ²¡æœ‰è¢«automaticå…³é”®å­—ä¿®é¥°ï¼Œåˆ™è¯¥ä»»åŠ¡ä¸º é™æ€ä»»åŠ¡ï¼ˆstatic taskï¼‰ ï¼Œè¿™ç±»ä»»åŠ¡å†…éƒ¨çš„æ‰€æœ‰å˜é‡éƒ½æ˜¯é™æ€åˆ†é…çš„ï¼Œè¿™æ„å‘³ç€è¿™äº›å˜é‡åœ¨ä»¿çœŸå¼€å§‹æ—¶å°±è¢«åˆ†é…å¥½å†…å­˜ï¼Œå¹¶ä¸”åœ¨æ•´ä¸ªä»¿çœŸè¿‡ç¨‹ä¸­åªæœ‰ä¸€ä»½å‰¯æœ¬ã€‚æ­¤æ—¶ï¼Œå¦‚æœæœå¤šä¸ªå—å†…åŒæ—¶è°ƒç”¨åŒä¸€ä¸ªé™æ€ taskï¼ˆä¾‹å¦‚åœ¨ä¸¤ä¸ªå¹¶è¡Œçš„ initial å—ä¸­ï¼‰ï¼Œé‚£ä¹ˆå®ƒä»¬å…±äº«åŒä¸€ç»„å†…éƒ¨å˜é‡ã€‚è¿™å¯èƒ½ä¼šå¯¼è‡´æ•°æ®ç«äº‰ï¼šå½“ä¸€ä¸ªè°ƒç”¨ä¿®æ”¹äº†å˜é‡ï¼Œå¦ä¸€ä¸ªè°ƒç”¨ä¼šçœ‹åˆ°è¿™ä¸ªä¿®æ”¹ï¼Œå¯èƒ½å¼•å‘ ä¸å¯é¢„æµ‹çš„è¡Œä¸ºï¼ˆUBï¼‰ ã€‚\nå› æ­¤ï¼Œæ ‡å‡†å¼•å…¥äº†automaticå…³é”®å­—ï¼Œå¦‚æœæˆ‘ä»¬ä½¿ç”¨è¯¥å…³é”®å­—ä¿®é¥°ä¸€ä¸ªä»»åŠ¡ï¼š\n1 2 3 task automatic my_auto_task; /* do something */ endtask è¯¥ä»»åŠ¡ä¼šè¢«å£°æ˜ä¸ºè‡ªåŠ¨ä»»åŠ¡ï¼ˆautomatic taskï¼‰ ï¼Œæ­¤æ—¶ï¼Œå¯¹è¯¥ä»»åŠ¡çš„æ¯æ¬¡è°ƒç”¨ï¼Œéƒ½ä¼šåŠ¨æ€åˆ†é…ä¸€ä»½æ–°çš„å†…å­˜ç©ºé—´ï¼Œå› æ­¤ï¼Œå¤šä¸ªå¹¶å‘è°ƒç”¨ä¹‹é—´äº’ä¸å¹²æ‰°ï¼Œå„è‡ªæ‹¥æœ‰ç‹¬ç«‹çš„å˜é‡å‰¯æœ¬ï¼Œé¿å…äº†æ•°æ®ç«äº‰ã€‚\nä½†æ˜¯ï¼Œå¯¹äºè‡ªåŠ¨ä»»åŠ¡è€Œè¨€ï¼š\nä½ ä¸èƒ½é€šè¿‡top.inst.my_auto_task.varä¹‹ç±»çš„å±‚æ¬¡åŒ–å¼•ç”¨è¯­å¥è®¿é—®ä»»åŠ¡å†…éƒ¨çš„å˜é‡ï¼Œå› ä¸ºè‡ªåŠ¨ä»»åŠ¡çš„å˜é‡æ˜¯åŠ¨æ€åˆ†é…çš„ï¼Œå¯èƒ½åŒæ—¶å­˜åœ¨å¤šä¸ªå®ä¾‹ï¼Œä»¿çœŸå™¨æ— æ³•ç¡®å®šä½ è¦è®¿é—®å“ªä¸€ä¸ªå‰¯æœ¬ã€‚ ä½ å¯ä»¥é€šè¿‡top.inst.my_auto_task(...)æŒ‡ä»¤çš„å±‚æ¬¡åŒ–è°ƒç”¨è¯­å¥æ¥è°ƒç”¨ä»»åŠ¡æœ¬èº«ï¼Œåªæ˜¯ä¸èƒ½è¯»å†™å®ƒçš„å†…éƒ¨å˜é‡ã€‚ ç¬¬äºŒï¼Œå‡½æ•°ä¸ä»»åŠ¡éƒ½æ˜¯å¯ç»¼åˆçš„ï¼Œä½†éœ€è¦æŒ‡å‡ºï¼Œå‡½æ•°å’Œä»»åŠ¡ç»¼åˆå‡ºçš„ç”µè·¯éƒ½æ˜¯ç»„åˆé€»è¾‘ï¼Œæ¢è¨€ä¹‹ï¼Œå¦‚æœéœ€è¦å¯¹å‡½æ•°ä¸ä»»åŠ¡è¿›è¡Œç»¼åˆï¼Œä½ ä¸åº”åœ¨å…¶ä¸­å¼•å…¥ä»»ä½•æ—¶åºæ§åˆ¶è¯­å¥ã€‚\næ³¨æ„ï¼Œæœ‰å…³å‡½æ•°ä¸ä»»åŠ¡æ˜¯å¦å¯ç»¼åˆï¼Œå…¶å®åœ¨æ ‡å‡†ä¸­å¹¶æ²¡æœ‰è¿›è¡Œè¯´æ˜ã€‚è¿™æ˜¯å› ä¸º å¯ç»¼åˆæ€§ï¼ˆSynthesizabilityï¼‰ æ˜¯ä¸€ä¸ªç”±ç»¼åˆå·¥å…·å‚å•†å®šä¹‰å’Œå®ç°çš„æ¦‚å¿µï¼Œè€Œä¸æ˜¯è¯­è¨€æ ‡å‡†æœ¬èº«å¼ºåˆ¶è§„å®šçš„ã€‚ä¸€ä¸ª Verilogè¯­å¥æ˜¯å¦å¯ç»¼åˆï¼Œå–å†³äºç»¼åˆå·¥å…·èƒ½å¦å°†å…¶è½¬æ¢ä¸ºå®é™…çš„ç¡¬ä»¶ç”µè·¯ã€‚\nå¯¹äºç¬¬ä¸€æ¡å·®å¼‚ï¼Œå¤šç¯‡åšå®¢å°†å…¶ç¿»è¯‘ä¸ºâ€œå‡½æ•°åªèƒ½ä¸ä¸»æ¨¡å—å…±ç”¨åŒä¸€ä¸ªä»¿çœŸæ—¶é—´å•ä½ï¼Œè€Œä»»åŠ¡å¯ä»¥å®šä¹‰è‡ªå·±çš„ä»¿çœŸæ—¶é—´å•ä½â€ï¼Œè¿™æ˜¯ä¸å‡†ç¡®çš„ã€‚\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-11-06T00:00:00Z","image":"https://posvirus.github.io/p/dic-002/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-002/","title":"taskä¸functionçš„åŒºåˆ«"},{"content":"å†™åœ¨å‰é¢ è¿™ä¸€ç³»åˆ—åšå®¢ä¸»è¦ç”¨äºè®°å½•æˆ‘åœ¨ æ•°å­—é›†æˆç”µè·¯ï¼ˆDigital Integrated Circuit, DICï¼‰ ä¸­é‡åˆ°æˆ–å¶ç„¶æƒ³åˆ°çš„ä¸€äº›é—®é¢˜ï¼Œä»¥åŠæ—¥å¸¸åœ¨å„ä¸ªå¹³å°çœ‹åˆ°çš„é¢è¯•å…«è‚¡ï¼Œä»¥æœŸä¸ºæ˜å¹´çš„ç§‹æ‹›åšä¸€äº›å‡†å¤‡ã€‚é›†æˆç”µè·¯çš„çŸ¥è¯†è¾ƒä¸ºç¹æ‚ï¼Œæƒ³è¦æ„å»ºæ¸…æ™°çš„åˆ†ç±»ä½“ç³»ä¼šæ¶ˆè€—å¤ªå¤šä¸å¿…è¦çš„ç²¾åŠ›ï¼Œæ‰€ä»¥è¿™é‡Œç»Ÿä¸€ä»¥[DIC-XXX]ä¸ºåšå®¢ç¼–å·ã€‚\nChen Wenyao\nupdated at November 3rd, 2025\nVerilogä¸­çš„æœ‰ç¬¦å·æ•° å‰å‡ å¤©ï¼Œæˆ‘åœ¨ç¼–å†™ä¸€ä¸ªALUæ¨¡å—ï¼Œå®ƒéœ€è¦åŒæ—¶æ”¯æŒæœ‰ç¬¦å·æ•°ä¸æ— ç¬¦å·æ•°å¤§å°æ¯”è¾ƒçš„åŠŸèƒ½ï¼Œä½†æˆ‘å¯¹è¿™éƒ¨åˆ†å†…å®¹çš„äº†è§£æ°å·§æ¯”è¾ƒæ¨¡ç³Šï¼Œæ‰€ä»¥æƒ³å€Ÿæœ¬ç¯‡åšå®¢ç³»ç»Ÿåœ°æ¢è®¨ä¸€ä¸‹Verilogè¯­æ³•ä¸­ä¸æœ‰ç¬¦å·æ•°æœ‰å…³çš„è¯é¢˜ã€‚\nåœ¨å†™è¿™ç¯‡åšå®¢ä¹‹å‰ï¼Œæˆ‘è¯•å›¾åœ¨ç½‘ä¸Šæœç´¢ç›¸å…³çš„å†…å®¹ï¼Œä½†åªæ‰¾åˆ°äº†ä¸¤ç±»ç»“æœï¼Œä¸€ç±»æ˜¯AIç”Ÿæˆçš„ğŸ’©ï¼Œå¦ä¸€ç±»å€’æ˜¯ç»™å‡ºäº†ä¸€äº›ç®€å•ç»“è®ºï¼Œä½†æ˜¯è¿™äº›ç»“è®ºåŸºæœ¬æ˜¯ä½œè€…åœ¨è¯¸å¦‚Vivadoä¹‹ç±»çš„EDAä¸Šç”¨å‡ ä¸ªç®€å•çš„æµ‹è¯•å½’çº³æ€»ç»“å¾—åˆ°çš„ï¼Œæ‰€ä»¥æ¯ä¸ªä½œè€…å¾—åˆ°çš„ç»“è®ºä¸å°½ç›¸åŒï¼Œå¼„å¾—æˆ‘æœ‰äº›è«åå…¶å¦™ï¼Œä¸çŸ¥é“è¯¥ä¿¡è°ã€‚\nè¿™é‡Œæˆ‘æƒ³æä¸€å¥ï¼Œæˆ‘è§‰å¾—ä¸Šæ–‡æåˆ°çš„ä½¿ç”¨ä»¿çœŸå™¨æµ‹è¯•å½’çº³Verilogè¯­æ³•ç‰¹æ€§æ˜¯ä¸€ç§å…¸å‹çš„é”™è¯¯è¡Œä¸ºï¼ˆå¯ä»¥ç§°ä¹‹ä¸ºDICä¸­çš„Spice Monkeyï¼‰ï¼Œå› ä¸ºä»¿çœŸå™¨æ‰€ååº”çš„Verilogè¯­æ³•ç‰¹æ€§æœ¬èº«æ˜¯éµå¾ªVerilogæ ‡å‡†çš„ï¼Œè€Œè¿™ç§è¡Œä¸ºå…¶å®æ˜¯è¯•å›¾é€šè¿‡ä»¿çœŸå™¨ä¸­çš„ç®€å•æµ‹è¯•å» â€œé€†å‘â€ Verilogæ ‡å‡†ä¸­æ‰€æè¿°çš„ç‰¹æ€§ï¼Œè¿™æ ·æœ€ç»ˆå¾—åˆ°çš„ç»“è®ºæ— è®ºæ˜¯åœ¨å…¨é¢æ€§è¿˜æ˜¯å‡†ç¡®æ€§ä¸Šè‚¯å®šéƒ½å­˜åœ¨ä¸€å®šæ¬ ç¼ºã€‚\nå½“ç„¶ï¼Œè¿™é‡Œå¯èƒ½æœ‰äººä¼šé—®ï¼Œå¦‚æœEDAæœ¬èº«å¯¹Verilogè¯­æ³•ç‰¹æ€§çš„æ”¯æŒä¸Verilogæ ‡å‡†ä¸ä¸€è‡´æ€ä¹ˆåŠå‘¢ï¼Œè¿™å°±æ˜¯EDAå‚å•†éœ€è¦è€ƒè™‘çš„äº‹æƒ…äº†ã€‚ä½œä¸ºICè®¾è®¡äººå‘˜ï¼Œæˆ‘è§‰å¾—åº”è¯¥è¾¾æˆçš„ä¸€ä¸ªå…±è¯†æ˜¯ï¼šæˆ‘ä»¬åº”å½“é¢å‘æ ‡å‡†è®¾è®¡ï¼Œè€Œä¸æ˜¯é¢å‘EDAè®¾è®¡ã€‚\næ‰€ä»¥ï¼Œæœ€å¥½çš„æ–¹æ³•æ˜¯ç›´æ¥é˜…è¯»Verilogæ ‡å‡†ï¼Œä»æ ‡å‡†ä¸­å¯»æ‰¾ç­”æ¡ˆã€‚è¿™é‡Œï¼Œæˆ‘é€‰æ‹©Verilog-2005æ ‡å‡†ï¼ˆIEEE 1364-2005ï¼‰ï¼Œå®ƒå¯ä»¥åœ¨è¿™é‡Œæ‰¾åˆ°ã€‚\nç”±äºæˆ‘ä¸»è¦å…³æ³¨çš„æ˜¯åœ¨ç®—æ•°é€»è¾‘è¡¨è¾¾å¼ä¸­æœ‰ç¬¦å·æ•°ä¸æ— ç¬¦å·æ•°çš„ç‰¹æ€§ï¼Œå› æ­¤ä»¥ä¸‹æˆ‘å°†ä¸»è¦é€‰å– æ ‡å‡†ç¬¬5ç« ï¼ˆExpressionsï¼‰ çš„ç›¸å…³å†…å®¹ï¼Œè¿›è¡Œç¿»è¯‘ä»¥åŠå½’çº³ï¼š\nè¡¨è¾¾å¼ä¸­çš„æ•´å‹æ•° [5.1.3] A negative value for an integer with no base specifier shall be interpreted differently from an integer with a base specifier. An integer with no base specifier shall be interpreted as a signed value in twos-complement form. An integer with an unsigned base specifier shall be interpreted as an unsigned value.\nå½“æ•´å‹æ•°ï¼ˆintegerï¼‰å‡ºç°åœ¨è¡¨è¾¾å¼ä¸­ï¼š\nå¦‚æœå…¶æ²¡æœ‰åŸºæ•°æ ‡è¯†ç¬¦ï¼ˆbase specifier, å¦‚'dï¼‰ï¼Œåˆ™è¢«è§†ä¸ºæœ‰ç¬¦å·æ•°å¤„ç†ï¼› å¦‚æœå…¶æœ‰åŸºæ•°æ ‡è¯†ç¬¦ï¼Œä½†æ²¡æœ‰æŒ‡å®šä¸ºæœ‰ç¬¦å·æ•°ï¼ˆå¦‚'sdä»£è¡¨æŒ‡å®šè¯¥æ•°ä¸ºæœ‰ç¬¦å·æ•°ï¼‰ï¼Œåˆ™è¢«è§†ä¸ºæ— ç¬¦å·æ•°å¤„ç†ï¼› å¦‚æœå…¶æœ‰åŸºæ•°æ ‡è¯†ç¬¦ï¼Œä¹Ÿè¢«æŒ‡å®šä¸ºæœ‰ç¬¦å·æ•°ï¼Œåˆ™è¢«è§†ä¸ºæœ‰ç¬¦å·æ•°å¤„ç†ã€‚ æ ‡å‡†ä¸­ç»™å‡ºäº†ä¸€äº›ä¾‹å­ï¼Œç”¨äºè¾…åŠ©è¯´æ˜ï¼š\n1 2 3 4 5 6 7 integer IntA; IntA = -12 / 3; // The result is -4. IntA = -\u0026#39;d 12 / 3; // The result is 1431655761. IntA = -\u0026#39;sd 12 / 3; // The result is -4. IntA = -4\u0026#39;sd 12 / 3; // -4\u0026#39;sd12 is the negative of the 4-bit // quantity 1100, which is -4. -(-4) = 4. // The result is 1. æ³¨æ„åŒºåˆ†æ•´å‹æ•°ä¸æ•´å‹æ•°å˜é‡ï¼Œå‰è€…æ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œåè€…æ˜¯ä½¿ç”¨integerä½œä¸ºç±»å‹å£°æ˜çš„å˜é‡ï¼Œè¿™ä¸€èŠ‚è¯´æ˜çš„å…¶å®æ˜¯è¡¨è¾¾å¼ä¸­çš„æ•´å‹æ•°ï¼ˆéå˜é‡ï¼‰çš„ç¬¦å·å¤„ç†è§„åˆ™ï¼Œæ¯”å¦‚-'d 12ä¸ºæ— ç¬¦å·æ•°ï¼Œ-'sd 12ä¸ºæœ‰ç¬¦å·æ•°ç­‰ã€‚\nç®—æ•°è¡¨è¾¾å¼ä¸­çš„å˜é‡ [5.1.6] A value assigned to a reg variable or a net shall be treated as an unsigned value unless the reg variable or net has been explicitly declared to be signed. A value assigned to an integer, real or realtime variable shall be treated as signed. A value assigned to a time variable shall be treated as unsigned. Signed values, except for those assigned to real and realtime variables, shall use a twos-complement representation. Values assigned to real and realtime variables shall use a floating-point representation. Conversions between signed and unsigned values shall keep the same bit representation; only the interpretation changes.\nè¿™é‡Œä¸»è¦ç»™å‡ºäº†ç®—æ•°è¡¨è¾¾å¼ï¼ˆè¿›è¡Œç®—æ•°è¿ç®—çš„è¡¨è¾¾å¼ï¼‰ä¸­ä¸€äº›å˜é‡ç±»å‹ï¼ˆå¦‚wire, regç­‰ï¼‰çš„é»˜è®¤ç¬¦å·ç±»å‹ï¼Œå…¶å¯ä»¥å½’çº³ä¸ºä¸‹è¡¨ï¼š\nData Type Interpretation [net] Unsigned signed [net] Signed, 2\u0026rsquo;s complement reg Unsigned signed reg Signed, 2\u0026rsquo;s complement integer Signed, 2\u0026rsquo;s complement time Unsigned real, realtime Signed, floating point æˆ‘ä»¬åŒæ ·å¯ä»¥ç»“åˆä¾‹å­è¿›è¡Œè¾…åŠ©è¯´æ˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 integer intA; reg [15:0] regA; reg signed [15:0] regS; intA = -4\u0026#39;d12; regA = intA / 3; // expression result is -4, // intA is an integer data type, regA is 65532 regA = -4\u0026#39;d12; intA = regA / 3; // regA is 65524 // expression result is 21841, // regA is a reg data type intA = -4\u0026#39;d12 / 3; // expression result is 1431655761. // -4\u0026#39;d12 is effectively a 32-bit reg data type regA = -12 / 3; // expression result is -4, -12 is effectively // an integer data type. regA is 65532 regS = -12 / 3; // expression result is -4. regS is a signed reg regS = -4\u0026#39;sd12 / 3; // expression result is 1. -4\u0026#39;sd12 is actually 4. // The rules for integer division yield 4/3==1. è¿™é‡Œéœ€è¦è¿›è¡Œä¸€äº›è¡¥å……è¯´æ˜ï¼Œä»¥ç¬¬ä¸€ä¸ªä¾‹å­ä¸ºä¾‹ï¼Œé¦–å…ˆåœ¨intA = -4'd12;ä¸­ï¼Œ-4'd12ä¸ºä¸€ä¸ªæ•´å‹æ•°ï¼Œä¸æ¶‰åŠè¡¨è¾¾å¼è¿ç®—ï¼Œå› æ­¤å°†å…¶ç›´æ¥èµ‹å€¼ç»™intAåï¼ŒintAå°†å…¶æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°-12ã€‚è€Œåœ¨regA = intA / 3;ä¸­ï¼ŒintAä¸ºæœ‰ç¬¦å·æ•°-12ï¼Œå› æ­¤å…¶é™¤ä»¥3çš„ç»“æœæ˜¯-4ï¼ˆè¿™é‡Œ3ä¹Ÿæ˜¯ä¸€ä¸ªæ•´å‹æ•°ï¼Œåœ¨è¡¨è¾¾å¼ä¸­å‚ä¸è¿ç®—ï¼Œæ²¡æœ‰åŸºæ•°æ ‡è¯†ç¬¦ï¼Œè¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°ï¼‰ï¼Œè€Œèµ‹å€¼ç»™regAåï¼Œç”±äºregAæ²¡æœ‰è¢«å£°æ˜ä¸ºsigned regï¼Œå› æ­¤-4è¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ï¼Œäº¦å³16'hfffb=65532ã€‚\nå†çœ‹æœ€åä¸€ä¸ªä¾‹å­ï¼Œ-4'sd12ä¹Ÿæ˜¯ä¸€ä¸ªæ•´å‹æ•°ï¼Œä¸”å‚ä¸è¡¨è¾¾å¼è¿ç®—ï¼Œç”±äºå…¶å­˜åœ¨åŸºæ•°æ ‡è¯†ç¬¦ï¼Œä¸”è¢«æŒ‡å®šä¸ºæœ‰ç¬¦å·æ•°ï¼Œå› æ­¤åœ¨å‚ä¸è¡¨è¾¾å¼è¿ç®—æ—¶è¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°4ï¼ˆæœ‰ç¬¦å·æ•°-12æˆªä½å¾—åˆ°ï¼‰ï¼Œè¿›è€Œè¡¨è¾¾å¼çš„å€¼ä¸º1ï¼Œè€Œç”±äºregSè¢«å£°æ˜ä¸ºsigned regï¼Œå› æ­¤1è¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°ï¼ŒäºŒè¿›åˆ¶è¡¨ç¤ºä¸º16'h0001ã€‚\næ¯”è¾ƒè¿ç®—ç¬¦ [5.1.7] When one or both operands of a relational expression are unsigned, the expression shall be interpreted as a comparison between unsigned values. If the operands are of unequal bit lengths, the smaller operand shall be zero-extended to the size of the larger operand.\nWhen both operands are signed, the expression shall be interpreted as a comparison between signed values. If the operands are of unequal bit lengths, the smaller operand shall be sign-extended to the size of the larger operand.\nIf either operand is a real operand, then the other operand shall be converted to an equivalent real value and the expression shall be interpreted as a comparison between real values.\nè¿™é‡Œç»™å‡ºåœ¨è¿›è¡Œæ¯”è¾ƒè¿ç®—ï¼ˆåŒ…æ‹¬å¤§äº/å°äº/ç­‰äº/ä¸ç­‰äºç­‰è¿ç®—ï¼‰æ—¶ï¼Œè¿ç®—ç¬¦ä¸¤ä¾§çš„è¿ç®—æ•°çš„æ¨æ–­è§„åˆ™ï¼š\nåªè¦æ¯”è¾ƒè¿ç®—ç¬¦ä¸¤ä¾§çš„æ“ä½œæ•°æœ‰ä¸€ä¸ªä¸ºæ— ç¬¦å·æ•°ï¼Œåˆ™æ¯”è¾ƒè¿ç®—è¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°é—´çš„æ¯”è¾ƒï¼Œå¦‚æœæ“ä½œæ•°ä½å®½ä¸åŒ¹é…ï¼Œåˆ™ä½å®½è¾ƒå°è€…éœ€è¦é€šè¿‡0ä½æ‰©å±•ä½¿å…¶ä¸ä½å®½è¾ƒå¤§è€…åŒ¹é…ã€‚ åªæœ‰æ¯”è¾ƒè¿ç®—ç¬¦ä¸¤ä¾§çš„æ“ä½œæ•°å‡ä¸ºæœ‰ç¬¦å·æ•°ï¼Œæ¯”è¾ƒè¿ç®—æ‰è¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°é—´çš„æ¯”è¾ƒï¼Œå¦‚æœæ“ä½œæ•°ä½å®½ä¸åŒ¹é…ï¼Œåˆ™ä½å®½è¾ƒå°è€…éœ€è¦é€šè¿‡ç¬¦å·ä½æ‰©å±•ä½¿å…¶ä¸ä½å®½è¾ƒå¤§è€…åŒ¹é…ã€‚ åªè¦æ¯”è¾ƒè¿ç®—ç¬¦ä¸¤ä¾§çš„æ“ä½œæ•°æœ‰ä¸€ä¸ªä¸ºå®æ•°å‹ï¼ˆrealï¼‰ï¼Œåˆ™æ¯”è¾ƒè¿ç®—è¢«æ¨æ–­ä¸ºå®æ•°é—´çš„æ¯”è¾ƒï¼Œå…¶ä½™éå®æ•°æ“ä½œæ•°è¢«è½¬æ¢ä¸ºç­‰ä»·çš„å®æ•°ã€‚ ç§»ä½è¿ç®—ç¬¦ [5.1.12] The logical right shift shall fill the vacated bit positions with zeroes. The arithmetic right shift shall fill the vacated bit positions with zeroes if the result type is unsigned. It shall fill the vacated bit positions with the value of the most significant (i.e., sign) bit of the left operand if the result type is signed. If the right operand has an x or z value, then the result shall be unknown. The right operand is always treated as an unsigned number and has no effect on the signedness of the result.\nè¿™é‡Œç»™å‡ºåœ¨è¿›è¡Œç§»ä½è¿ç®—æ—¶ï¼Œè¿ç®—ç»“æœçš„æ¨æ–­è§„åˆ™ï¼š\nè¿ç®—ç¬¦çš„å³æ“ä½œæ•°å§‹ç»ˆè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ï¼Œä¸”å¯¹è¿ç®—ç»“æœæ— å½±å“ã€‚ å½“ä½¿ç”¨é€»è¾‘å³ç§»ï¼ˆ\u0026gt;\u0026gt;ï¼‰æ—¶ï¼Œè¿ç®—ç»“æœçš„ç©ºä½éœ€è¦è¿›è¡Œ0ä½æ‰©å±•ã€‚ å½“ä½¿ç”¨ç®—æ•°å³ç§»ï¼ˆ\u0026gt;\u0026gt;\u0026gt;ï¼‰æ—¶ï¼Œå¦‚ç»“æœç±»å‹æ˜¯æœ‰ç¬¦å·æ•°ï¼Œåˆ™ç©ºä½éœ€è¦è¿›è¡Œç¬¦å·ä½æ‰©å±•ï¼›å¦‚ç»“æœç±»å‹æ˜¯æ— ç¬¦å·æ•°ï¼Œåˆ™ç©ºä½éœ€è¦è¿›è¡Œ0ä½æ‰©å±•ã€‚ è¡¨è¾¾å¼çš„ç¬¦å·æ¨æ–­è§„åˆ™ [5.5.1] The following are the rules for determining the resulting type of an expression:\nExpression type depends only on the operands. It does not depend on the left-hand side (if any). Decimal numbers are signed. Based_numbers are unsigned, except where the s notation is used in the base specifier (as in\u0026quot;4'sd12\u0026quot;). Bit-select results are unsigned, regardless of the operands. Part-select results are unsigned, regardless of the operands even if the part-select specifies the entire vector. Concatenate results are unsigned, regardless of the operands. Comparison results (1, 0) are unsigned, regardless of the operands. Reals converted to integers by type coercion are signed The sign and size of any self-determined operand are determined by the operand itself and independent of the remainder of the expression. For nonself-determined operands, the following rules apply: If any operand is real, the result is real. If any operand is unsigned, the result is unsigned, regardless of the operator. If all operands are signed, the result will be signed, regardless of operator, except when specified otherwise. åœ¨å‰å‡ èŠ‚ä¸­ï¼Œæˆ‘ä»¬åˆ†åˆ«è®¨è®ºäº†æ•´å‹æ•°å¸¸é‡ï¼Œå˜é‡ä¸ç‰¹å®šè¿ç®—ç¬¦è¿ç®—æ—¶çš„ç¬¦å·æ¨æ–­è§„åˆ™ã€‚ç»¼åˆæ¥çœ‹ï¼Œä¸Šè¿°è§„åˆ™æœ¬è´¨ä¸Šçº¦æŸçš„å¯¹è±¡æ˜¯æ“ä½œæ•°ï¼ˆæ¯”å¦‚æ¯”è¾ƒè¿ç®—ç¬¦ä¸­ï¼Œæˆ‘ä»¬å®é™…ä¸Šæ˜¯åœ¨æ ¹æ®æ¯”è¾ƒè¿ç®—ç¬¦ä¸¤ä¾§çš„æ“ä½œæ•°ç±»å‹æ¨æ–­åœ¨è¿›è¡Œæ¯”è¾ƒæ—¶ï¼Œæ“ä½œæ•°æœ¬èº«åº”è¯¥è§†ä¸ºæœ‰ç¬¦å·æ•°è¿˜æ˜¯æ— ç¬¦å·æ•°ï¼‰ï¼Œè€Œåœ¨æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦èšç„¦äºå¯¹äºä¸€ä¸ªä¸€èˆ¬çš„è¡¨è¾¾å¼è€Œè¨€ï¼Œå…¶è¿ç®—ç»“æœçš„ç¬¦å·ç±»å‹æ¨æ–­ã€‚æ ‡å‡†ä¸­ç»™å‡ºäº†å¦‚ä¸‹çš„è§„åˆ™ï¼š\nè¡¨è¾¾å¼çš„ç¬¦å·ç±»å‹åªä¸æ“ä½œæ•°æœ‰å…³ï¼Œä¸ è¡¨è¾¾å¼èµ‹å€¼çš„å¯¹è±¡ï¼ˆLHSï¼‰ æ— å…³ã€‚ åè¿›åˆ¶æ•°è¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°ã€‚ å«åŸºæ•°æ ‡è¯†ç¬¦çš„æ“ä½œæ•°è¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ï¼Œé™¤éä½¿ç”¨sæŒ‡å®šå…¶ä¸ºæœ‰ç¬¦å·æ•°ï¼ˆå¦‚4'sd12ï¼‰ã€‚ æ¯”ç‰¹é€‰æ‹©åçš„ç»“æœè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ï¼ˆå¦‚a[1]ï¼‰ã€‚ éƒ¨åˆ†é€‰æ‹©åçš„ç»“æœè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ï¼ˆå¦‚b[4:2]ï¼‰ã€‚ æ‹¼æ¥è¿ç®—åçš„ç»“æœè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ã€‚ æ¯”è¾ƒè¿ç®—çš„ç»“æœè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ã€‚ å®æ•°å¼ºåˆ¶è½¬æ¢ä¸ºæ•´å‹æ•°çš„ç»“æœè¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°ã€‚ å¯¹äºè‡ªå†³æ“ä½œæ•°ï¼ˆself-determined operandï¼‰ï¼Œå…¶ç¬¦å·ç±»å‹åªä¸æ“ä½œæ•°æœ¬èº«æœ‰å…³ï¼Œä¸è¡¨è¾¾å¼å…¶ä½™éƒ¨åˆ†ç‹¬ç«‹ã€‚ å¯¹äºéè‡ªå†³æ“ä½œæ•°ï¼Œå…¶ç¬¦å·æ¨æ–­éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š å¦‚æœæ“ä½œæ•°ä¸­æœ‰ä¸€è€…ä¸ºå®æ•°ï¼Œåˆ™è¿ç®—ç»“æœè¢«æ¨æ–­ä¸ºå®æ•°ã€‚ å¦‚æœæ“ä½œæ•°ä¸­æœ‰ä¸€è€…ä¸ºæ— ç¬¦å·æ•°ï¼Œåˆ™è¿ç®—ç»“æœè¢«æ¨æ–­ä¸ºæ— ç¬¦å·æ•°ã€‚ å¦‚æœæ‰€æœ‰æ“ä½œæ•°å‡ä¸ºæœ‰ç¬¦å·æ•°ï¼Œåˆ™è¿ç®—ç»“æœè¢«æ¨æ–­ä¸ºæœ‰ç¬¦å·æ•°ã€‚ å¯¹äºä¸Šè¿°è§„åˆ™ï¼Œæˆ‘ä»¬éœ€è¦è¯´æ˜ä»¥ä¸‹å‡ ç‚¹ï¼š\né¦–å…ˆï¼Œéœ€è¦æ³¨æ„æ“ä½œæ•°ä¸è¡¨è¾¾å¼æ˜¯ä¸€ä¸ªç›¸å¯¹çš„æ¦‚å¿µï¼Œä¸€ä¸ªè¡¨è¾¾å¼å¯ä»¥ä½œä¸ºä¸€ä¸ªæ›´ä¸ºå¤æ‚è¡¨è¾¾å¼ä¸­çš„æ“ä½œæ•°ï¼Œæ¯”å¦‚(1 + 2) * (3 % 4)ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°†(1 + 2)ä¸(3 % 4)è§†ä¸ºä¹˜æ³•è¿ç®—çš„ä¸¤ä¸ªæ“ä½œæ•°ã€‚\nå…¶æ¬¡ï¼Œç¬¬9æ¡è§„åˆ™å¼•å…¥äº†è‡ªå†³æ“ä½œæ•°çš„æ¦‚å¿µï¼Œå°†å…¶å®šä¹‰ä¸ºç¬¦å·ç±»å‹åªä¸æ“ä½œæ•°æœ¬èº«æœ‰å…³çš„æ“ä½œæ•°ï¼Œè¿™é‡Œå…¶å®åªæ˜¯å¯¹äºè¿™ç±»æ“ä½œæ•°è¿›è¡Œäº†å½¢å¼ä¸Šçš„å®šä¹‰ï¼Œå¹¶æ²¡æœ‰å¼•å…¥æ–°çš„æ¨æ–­è§„åˆ™ã€‚ä½†æ˜¯ç¬¬10æ¡è§„åˆ™å¼•å…¥äº†å¯¹éè‡ªå†³æ“ä½œæ•°çš„æ¨æ–­è§„åˆ™ï¼Œå› æ­¤æœ‰å¿…è¦æ˜ç¡®è‡ªå†³æ“ä½œæ•°ç©¶ç«ŸæŒ‡ä»€ä¹ˆï¼šæ ¹æ®å®šä¹‰ï¼Œè‡ªå†³æ“ä½œæ•°å…¶å®å°±æ˜¯æŒ‡æœ¬èº«å°±å¯ä»¥åˆ¤å®šç¬¦å·çš„æ“ä½œæ•°ï¼Œæ¯”å¦‚ä¹‹å‰çš„æ•´å‹æ•°-'sd12ï¼Œæˆ–æ˜¯ç¬¬2-8æ¡è§„åˆ™ä¸­è§„å®šçš„è¿ç®—ç»“æœï¼ˆæ¯”ç‰¹é€‰æ‹©ï¼Œæ‹¼æ¥è¿ç®—ï¼Œæ¯”è¾ƒè¿ç®—ç­‰ï¼‰ã€‚è¿™å…¶å®å°±æ„å‘³ç€Verilogä¸­çš„è¿™äº›æ“ä½œæ•°çš„ç¬¦å·ç±»å‹æ˜¯æ˜ç¡®çš„ï¼Œä¸ä¼šå› ä¸ºè¡¨è¾¾å¼ä¸Šä¸‹æ–‡è€Œæ”¹å˜ã€‚\nä½†æ˜¯ï¼Œè¯¸å¦‚reg regAï¼Œwire wireAè¿™ç±»å˜é‡ï¼Œå®ƒä»¬å…¶å®åªæœ‰é»˜è®¤çš„ç¬¦å·æ¨æ–­ï¼Œè€Œå®ƒä»¬åœ¨è¡¨è¾¾å¼ä¸­å®é™…çš„ç¬¦å·æ¨æ–­æ˜¯å¯å˜çš„ï¼Œéœ€è¦ç»“åˆè¡¨è¾¾å¼æœ¬èº«ç¡®å®šï¼Œè¿™ä¹Ÿå°±æ˜¯éè‡ªå†³æ“ä½œæ•°çš„æ¦‚å¿µï¼Œç¬¬10æ¡è§„åˆ™è§„å®šäº†å¯¹éè‡ªå†³æ“ä½œæ•°çš„ç¬¦å·æ¨æ–­ã€‚\nä½†æ˜¯ï¼Œæˆ‘ä»¬ä»”ç»†é˜…è¯»ç¬¬10æ¡è§„åˆ™ï¼Œä¼šå‘ç°ä¸€ä¸ªé—®é¢˜ï¼Œè¿™é‡Œå…¶å®è¯´æ˜çš„æ˜¯å¦‚ä½•æ¨æ–­è¿ç®—ç»“æœçš„ç¬¦å·ç±»å‹ï¼Œä½†æ˜¯å¯¹äºéè‡ªå†³æ“ä½œæ•°æœ¬èº«ï¼Œè¿™ä¸€æ¡è§„åˆ™å¹¶æ²¡æœ‰è¯´æ˜å…¶åœ¨å‚ä¸è¿ç®—æ—¶åº”å¦‚ä½•è¿›è¡Œç¬¦å·æ¨æ–­ï¼Œè¿™ä¸€ç‚¹å…¶å®åœ¨æ ‡å‡†çš„5.5.2èŠ‚ä¸­æ‰æåˆ°ï¼š\n[5.5.2] The following are the steps for evaluating an expression:\nDetermine the expression size based upon the standard rules of expression size determination. Determine the sign of the expression using the rules outlined in 5.5.1. Propagate the type and size of the expression (or self-determined subexpression) back down to the context-determined operands of the expression. In general, any context-determined operand of an operator shall be the same type and size as the result of the operator. However, there are two exceptions: If the result type of the operator is real and if it has a context-determined operand that is not real, that operand shall be treated as if it were self-determined and then converted to real just before the operator is applied. The relational and equality operators have operands that are neither fully self-determined nor fully context-determined. The operands shall affect each other as if they were context-determined operands with a result type and size (maximum of the two operand sizes) determined from them. However, the actual result type shall always be 1 bit unsigned. The type and size of the operand shall be independent of the rest of the expression and vice versa. When propagation reaches a simple operand as defined in 5.2 (a primary as defined in A.8.4), then that operand shall be converted to the propagated type and size. If the operand must be extended, then it shall be sign-extended only if the propagated type is signed. åœ¨è¿™ä¸€éƒ¨åˆ†å…¶å®è¯´æ˜äº†ï¼Œå¯¹äºéè‡ªå†³æ“ä½œæ•°ï¼Œä¹Ÿå°±æ˜¯æ ‡å‡†ä¸­æåŠçš„ä¸Šä¸‹æ–‡å†³å®šæ“ä½œæ•°ï¼ˆcontext-determined operandï¼‰å…¶ç¬¦å·æ˜¯é€šè¿‡è¡¨è¾¾å¼ç»“æœçš„ç¬¦å·ç±»å‹å‘ä¸‹ä¼ æ’­ç¡®å®šçš„ã€‚ä½†è¿™é‡ŒåŒæ ·æœ‰ä¸¤ä¸ªä¾‹å¤–ï¼š\nå¦‚æœè¡¨è¾¾å¼ç»“æœæ˜¯å®æ•°ï¼Œåˆ™å¯¹äºéå®æ•°çš„ä¸Šä¸‹æ–‡å†³å®šæ“ä½œæ•°ï¼Œéœ€è¦å…ˆå‡å®šå…¶ä¸ºè‡ªå†³æ“ä½œæ•°ï¼Œæ®æ­¤åˆ¤æ–­å…¶å–å€¼ï¼Œå†å°†è¯¥å€¼è½¬æ¢ä¸ºå®æ•°ã€‚ä¸¾ä¸€ä¸ªä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬å£°æ˜äº†ä¸€ä¸ªå˜é‡reg [3:0] a = 4'b1111ï¼›ï¼Œåˆ™å¯¹è¡¨è¾¾å¼a * 1.5è€Œè¨€ï¼Œç”±äºæœ‰å®æ•°1.5çš„å­˜åœ¨ï¼Œè¡¨è¾¾å¼ç»“æœè¢«æ¨æ–­ä¸ºå®æ•°ï¼Œä¸”aæ˜¯ä¸€ä¸ªéå®æ•°çš„éè‡ªå†³æ“ä½œæ•°ã€‚å› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦å…ˆå‡å®šaä¸ºè‡ªå†³æ“ä½œæ•°ï¼Œæ­¤æ—¶å°±ç›´æ¥ä½¿ç”¨açš„é»˜è®¤ç¬¦å·æ¨æ–­ï¼Œå³æ— ç¬¦å·æ•°ï¼Œè¿›è€Œaçš„å€¼å°±æ˜¯15ï¼Œå†å°†å…¶è½¬æ¢ä¸ºå®æ•°15.0å‚ä¸è¿ç®—ã€‚ å¯¹äºæ¯”è¾ƒè¿ç®—ç¬¦ï¼Œå®ƒçš„ä¸¤ä¸ªæ“ä½œæ•°ä¸æ˜¯ä¸¥æ ¼çš„è‡ªå†³æ“ä½œæ•°æˆ–éè‡ªå†³æ“ä½œæ•°ï¼Œå› ä¸ºä¸¤ä¸ªæ“ä½œæ•°çš„ç¬¦å·æ¨æ–­æ˜¯ç›¸äº’ç¡®å®šçš„ï¼Œå…·ä½“è§„åˆ™å·²åœ¨ä¸Šæ–‡æåŠï¼Œæ­¤å¤„ä¸å†èµ˜è¿°ã€‚ ç»¼ä¸Šï¼šè¡¨è¾¾å¼ç»“æœçš„ç¬¦å·æœ¬èº«æ˜¯ç”±æ‰€æœ‰æ“ä½œæ•°å…±åŒå†³å®šçš„è§„åˆ™æ¨å¯¼å‡ºæ¥çš„ï¼Œå®ƒæ˜¯ä¸€ä¸ªè‡ªåº•å‘ä¸Š + è‡ªé¡¶å‘ä¸‹ç»“åˆçš„è¿‡ç¨‹ï¼š\né¦–å…ˆï¼Œæ ¹æ®è‡ªå†³æ“ä½œæ•°ç¬¦å·ç±»å‹ï¼Œç¡®å®šè¡¨è¾¾å¼ç»“æœçš„ç¬¦å·ç±»å‹ã€‚ ç„¶åï¼Œå†å°†è¡¨è¾¾å¼ç»“æœçš„ç¬¦å·ç±»å‹åº”ç”¨åˆ°æ‰€æœ‰éè‡ªå†³æ“ä½œæ•°ä¸Šï¼Œå¹¶è¿›è¡Œè¿ç®—ã€‚ ","date":"2025-11-04T00:00:00Z","image":"https://posvirus.github.io/p/dic-001/cicc_hu_8db5a89516f532d4.png","permalink":"https://posvirus.github.io/p/dic-001/","title":"Verilogä¸­çš„æœ‰ç¬¦å·æ•°"},{"content":"å•å‘¨æœŸCPUæ¶æ„ç®€ä»‹ æœ¬èŠ‚ä¸­ï¼Œæˆ‘ä»¬ä¸»è¦ä»‹ç»åœ¨Cé˜¶æ®µå®ç°çš„æ”¯æŒRV32E ISAçš„å•å‘¨æœŸCPUï¼Œè¯¥CPUå¯¹åº”çš„æ¶æ„å›¾å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œæ•´ä½“ä¸Šåˆ†ä¸ºå–å€¼ï¼ˆInstruction Fetchï¼‰ã€ è¯‘ç ï¼ˆInstruction Decodeï¼‰ ä¸ æ‰§è¡Œï¼ˆInstruction Excecutionï¼‰ ä¸‰ä¸ªé˜¶æ®µã€‚\nè¯¥CPUçš„å·¥ä½œåŸç†ä¸ä¸€äº›ç»å…¸æ•™æä¸­çš„CPUå®Œå…¨ç±»ä¼¼ï¼Œæ­¤å¤„æˆ‘ä»¬ä¸»è¦ä»‹ç»å‡ ä¸ªè®¾è®¡ä¸­çš„æ³¨æ„ç‚¹ï¼š\nç¬¬ä¸€æ˜¯CPUçš„è®¿å­˜è¡Œä¸ºï¼Œè¯¥CPUé€šè¿‡DPI-Cæœºåˆ¶å®ç°è®¿å­˜ï¼Œåœ¨ä¸€æ¡æŒ‡ä»¤çš„å®Œæ•´æ‰§è¡Œæµç¨‹ä¸­ï¼Œæœ€å¤šå­˜åœ¨ä¸¤æ¬¡è®¿å­˜è¡Œä¸ºï¼Œç¬¬ä¸€æ¬¡æ˜¯å–æŒ‡ï¼Œç¬¬äºŒæ¬¡æ˜¯è®¿å­˜æŒ‡ä»¤çš„è®¿å­˜è¡Œä¸ºã€‚æ­¤å¤„æˆ‘ä»¬é€šè¿‡NPCä¸­æä¾›çš„ç»Ÿä¸€æ¥å£paddr_read()ä¸paddr_write()å®ç°ã€‚åŒæ—¶ï¼Œç”±äºRV32Eæ¶æ„é€šè¿‡å†…å­˜æ˜ å°„IOå®ç°CPUä¸å¤–è®¾çš„äº¤äº’ï¼Œå› æ­¤CPUå¯¹å¤–è®¾çš„è®¿é—®è¢«ç»Ÿä¸€æŠ½è±¡ä¸ºè®¿å­˜æŒ‡ä»¤ã€‚\nç¬¬äºŒæ˜¯CPUçš„å¼‚å¸¸å“åº”æœºåˆ¶å®ç°ï¼Œæ­¤å¤„ä¸»è¦éœ€è¦å®ç°çš„æ˜¯CPUçš„è‹¥å¹²ä¸ªCSRï¼Œä»¥åŠå¯¹åº”ç”¨äºå®ç°å¼‚å¸¸å“åº”æœºåˆ¶çš„è‹¥å¹²æŒ‡ä»¤ã€‚ç”±äºCSRçš„è¡Œä¸ºä¸å¼‚å¸¸å“åº”æœºåˆ¶æŒ‡ä»¤çš„ç›¸å…³æ€§å¾ˆå¼ºï¼Œæ•…æ­¤å¤„æˆ‘ä»¬ç»Ÿä¸€è¿›è¡Œè¯´æ˜ï¼Œæ€»ä½“ä¸Šï¼Œä¸å¼‚å¸¸å“åº”æœºåˆ¶ç›¸å…³çš„æŒ‡ä»¤ä¸»è¦å¯åˆ†ä¸ºä¸¤ç±»ï¼š\nä¸€ç±»æ˜¯mret, ecallè¿™ç±»ç›´æ¥å®ç°å¼‚å¸¸å“åº”çš„æŒ‡ä»¤ï¼Œè¿™ç±»æŒ‡ä»¤æ¶‰åŠå¯¹å¤šä¸ªCSRçš„é…ç½®ä»¥åŠPCçš„è·³è½¬ã€‚ ä¸€ç±»æ˜¯csrrw, csrrsè¿™ç±»å•çº¯å¯¹CSRè¿›è¡Œæ“ä½œçš„CSRæŒ‡ä»¤ï¼Œè¿™ç±»æŒ‡ä»¤æ¶‰åŠå¯¹æŸä¸ªCSRçš„åŸå­æ€§è¯»å†™ï¼ˆè¿™é‡Œçš„ â€œåŸå­æ€§â€ æŒ‡å¯¹CSRçš„è¯»-å†™ï¼ˆRead-Writeï¼‰æ“ä½œæ˜¯åŸå­çš„ï¼Œå³æ•´ä¸ªæ“ä½œåœ¨å•æ¡æŒ‡ä»¤å†…å®Œæˆï¼Œä¸ä¼šè¢«å…¶ä»–æ“ä½œæ‰“æ–­ï¼‰ï¼Œè¿™é€šå¸¸åŒ…æ‹¬å¯¹CSRçš„è¯»å–ï¼Œå¯¹CSRçš„å†™å›ä¸å¯¹é€šç”¨å¯„å­˜å™¨çš„å†™å›ä¸‰ä¸ªå­æ“ä½œã€‚ ç»¼åˆä¸Šè¿°è¯´æ˜ï¼Œæˆ‘ä»¬å…¶å®å¯ä»¥å‘ç°ï¼Œå¯¹CSRå®ç°æœ¬èº«è€Œè¨€ï¼Œæˆ‘ä»¬åªéœ€è¦å°†å…¶å®ç°ä¸ºå¯è¯»/å†™çš„å¯„å­˜å™¨å †å³å¯ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module ysyx_25070184_Csr( input wire clk, input wire rst, input wire [`ysyx_25070184_CSR_ADDR_WIDTH-1:0] addr, // atomically operates one CSR input wire [`ysyx_25070184_CSR_OPTYPE-1:0] inst_type, input wire [`ysyx_25070184_ADDR_WIDTH-1:0] cur_pc, input wire [`ysyx_25070184_DATA_WIDTH-1:0] ecode, input wire [`ysyx_25070184_DATA_WIDTH-1:0] wdata, output reg [`ysyx_25070184_DATA_WIDTH-1:0] rdata ); // instantiate CSRs one by one reg [`ysyx_25070184_DATA_WIDTH-1:0] mstatus; // machine status registers reg [`ysyx_25070184_DATA_WIDTH-1:0] mcause; // machine cause register reg [`ysyx_25070184_DATA_WIDTH-1:0] mtvec; // machine trap-vector base-address register reg [`ysyx_25070184_DATA_WIDTH-1:0] mepc; // machine exception program counter endmodule åœ¨è¯¥æ¨¡å—ä¸­ï¼ŒCSRçš„å†™å…¥ç”±æŒ‡ä»¤ç±»å‹inst_typeä¸CSRæŒ‡ä»¤ä¸­çš„åœ°å€å­—æ®µaddrå…±åŒç¡®å®šï¼ŒåŒæ—¶cur_pcï¼ˆå½“å‰çš„PCå€¼ï¼‰, ecodeï¼ˆå¼‚å¸¸å·ï¼‰, wdataï¼ˆCSRæŒ‡ä»¤çš„å†™å›å€¼ï¼‰ç”¨äºä¼ é€’å†™å…¥CSRçš„å€¼ï¼ˆå› ä¸ºåœ¨ecallæŒ‡ä»¤ä¸­ï¼Œéœ€è¦åŒæ—¶å†™å…¥å¤šä¸ªCSRï¼‰ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // CSRs write always @(posedge clk) begin if (rst) begin mstatus \u0026lt;= `ysyx_25070184_MSTATUS_RSTVAL; end else begin case (inst_type) `ysyx_25070184_CSR_ECALL: begin mstatus[`ysyx_25070184_MPIE_LOCATE] \u0026lt;= mstatus[`ysyx_25070184_MIE_LOCATE]; // MPIE = MIE mstatus[`ysyx_25070184_MIE_LOCATE] \u0026lt;= 1\u0026#39;b0; // reset MIE mepc \u0026lt;= cur_pc; // store current pc mcause \u0026lt;= ecode; // store exception code end `ysyx_25070184_CSR_CSRRS, `ysyx_25070184_CSR_CSRRW: begin case (addr) `ysyx_25070184_MSTATUS_ADDR: begin mstatus \u0026lt;= wdata; end `ysyx_25070184_MCAUSE_ADDR: begin mcause \u0026lt;= wdata; end `ysyx_25070184_MTVEC_ADDR: begin mtvec \u0026lt;= wdata; end `ysyx_25070184_MEPC_ADDR: begin mepc \u0026lt;= wdata; end default: begin // do nothing end endcase end `ysyx_25070184_CSR_MRET: begin mstatus[`ysyx_25070184_MIE_LOCATE] \u0026lt;= mstatus[`ysyx_25070184_MPIE_LOCATE]; // MIE = MPIE end default: begin // do nothing end endcase end end CSRçš„è¯»å–åŒæ ·ç”±æŒ‡ä»¤ç±»å‹inst_typeä¸CSRæŒ‡ä»¤ä¸­çš„åœ°å€å­—æ®µaddrå…±åŒç¡®å®šï¼Œå¯¹äºCSRæŒ‡ä»¤ï¼Œè¯»å‡ºçš„CSRåœ¨æ‰§è¡Œé˜¶æ®µè¢«ä½œä¸ºæ“ä½œæ•°ï¼›å¯¹äºmretä¸ecallæŒ‡ä»¤ï¼Œè¯»å‡ºçš„CSRåœ¨æ‰§è¡Œé˜¶æ®µè¢«ä½œä¸ºä¸‹ä¸€æ¡æŒ‡ä»¤çš„PCå€¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // CSRs read always @(*) begin if (inst_type == `ysyx_25070184_CSR_ECALL) begin rdata = mtvec; end else if (inst_type == `ysyx_25070184_CSR_MRET) begin rdata = mepc; end else begin case (addr) `ysyx_25070184_MSTATUS_ADDR: begin rdata = mstatus; end `ysyx_25070184_MCAUSE_ADDR: begin rdata = mcause; end `ysyx_25070184_MTVEC_ADDR: begin rdata = mtvec; end `ysyx_25070184_MEPC_ADDR: begin rdata = mepc; end default: begin rdata = {`ysyx_25070184_DATA_WIDTH{1\u0026#39;b0}}; end endcase end end ALUçš„æ€§èƒ½è¯„ä¼° å•å‘¨æœŸCPUä¸­æ‰€ä½¿ç”¨çš„ALUæ¶æ„å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå…¶å®ç°äº†åŠ æ³•å™¨çš„å¤ç”¨ï¼Œé€šè¿‡å•ä¸ªåŠ æ³•å™¨å®ç°äº†åŠ æ³•ã€å‡æ³•ã€å°äºï¼ˆæœ‰ç¬¦å·ï¼‰ã€ å°äºï¼ˆæ— ç¬¦å·ï¼‰ ä¸ç­‰äºå…±5ç§è¿ç®—ã€‚æ­¤å¤„ï¼Œæˆ‘ä»¬ä¸»è¦æ¢è®¨ä¸€ä¸‹ALUæ€§èƒ½è¯„ä¼°ä¸­çš„ä¸€ä¸ªæ³¨æ„ç‚¹ï¼Œè€Œä¸å†èµ˜è¿°ALUçš„å…·ä½“å®ç°åŸç†ã€‚\nç”±äºALUé€šè¿‡çº¯ç»„åˆé€»è¾‘å®ç°ï¼Œå› æ­¤åœ¨ä½¿ç”¨Yosys-STAè¿›è¡Œæ€§èƒ½è¯„ä¼°æ—¶ï¼Œæˆ‘ä»¬æ— æ³•è·å–å…¶æ—¶åºæ–¹é¢çš„ç›¸å…³æ€§èƒ½æŒ‡æ ‡ï¼ˆå¦‚æœ€å¤§å·¥ä½œé¢‘ç‡ï¼‰ã€‚è€Œå¯¹äºçº¯ç»„åˆé€»è¾‘æ¨¡å—è€Œè¨€ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨ç«¯åˆ°ç«¯æœ€å¤§ç»„åˆé€»è¾‘å»¶æ—¶è¿™ä¸€æ€§èƒ½æŒ‡æ ‡ï¼Œå®ƒå¯ä»¥è¯„ä¼°å½“æˆ‘ä»¬å°†è¯¥æ¨¡å—é›†æˆè‡³å­˜åœ¨æ—¶åºé€»è¾‘çš„ç³»ç»Ÿä¸­æ—¶ï¼Œè¯¥æ¨¡å—æ‰€èƒ½æ‰¿è½½çš„æœ€å¤§å·¥ä½œé¢‘ç‡ã€‚\nè€Œå½“æˆ‘ä»¬å•ç‹¬å¯¹ALUè¿›è¡Œæ€§èƒ½è¯„ä¼°æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡å¯„å­˜å™¨å°†ALUçš„è¾“å…¥/è¾“å‡ºæ‰“ä¸€æ‹ï¼Œå°†å…¶è½¬æ¢ä¸ºå«æ—¶åºé€»è¾‘çš„æ¨¡å—ï¼Œä»è€Œå®ç°å¯¹è¯¥æ€§èƒ½æŒ‡æ ‡çš„é‡åŒ–ã€‚\n","date":"2025-10-31T00:00:00Z","image":"https://posvirus.github.io/p/rv32e-npc/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rv32e-npc/","title":"RV32Eå•å‘¨æœŸCPUçš„å®ç°è¯´æ˜"},{"content":"RT-Threadä¸Šä¸‹æ–‡åˆ›å»º é¦–å…ˆï¼Œæˆ‘ä»¬è€ƒè™‘RT-Threadä¸­çš„ä¸Šä¸‹æ–‡åˆ›å»ºå‡½æ•°rt_hw_stack_init()çš„å®ç°ï¼Œè§‚å¯Ÿå…¶å‚æ•°åˆ—è¡¨ï¼š\n1 rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) è¯¥å‡½æ•°æ¥æ”¶ä¸€ä¸ªæ ˆåº•æŒ‡é’ˆstack_addrç”¨äºæ„å»ºä¸Šä¸‹æ–‡ï¼ŒåŒæ—¶ä¿è¯è¯¥ä¸Šä¸‹æ–‡å…¥å£ä¸ºtentryï¼Œå‚æ•°ä¸ºparameterï¼Œå¹¶è¿”å›è¿™ä¸ªä¸Šä¸‹æ–‡ç»“æ„çš„æŒ‡é’ˆã€‚æ­¤å¤–ï¼Œè‹¥ä¸Šä¸‹æ–‡å¯¹åº”çš„å†…æ ¸çº¿ç¨‹ä»tentryè¿”å›ï¼Œåˆ™è°ƒç”¨texitã€‚\nè¿™é‡Œé¦–å…ˆéœ€è¦è§£é‡Šï¼Œä¸ºä»€ä¹ˆåœ¨AMä¸­ï¼Œæˆ‘ä»¬ä¸å…è®¸å†…æ ¸çº¿ç¨‹ä»tentryè¿”å›ï¼šè¿™ä¸»è¦æ˜¯å› ä¸ºï¼Œå…¥å£ä¸ºtentryçš„ä¸Šä¸‹æ–‡æ˜¯äººå·¥æ„é€ çš„ï¼Œè€Œåœ¨AMä¸­æ„é€ ä¸Šä¸‹æ–‡çš„åŠŸèƒ½å‡½æ•°kcontext()ä¸­ï¼Œæˆ‘ä»¬å¹¶æ²¡æœ‰ä¸ºè¯¥å…¥å£æ„é€ ç›¸åº”çš„è¿”å›åœ°å€ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Context *kcontext(Area kstack, void (*entry)(void *), void *arg) { // instantiate a context Context *ret = (Context *)(kstack.end - sizeof(Context)); // create entry ret-\u0026gt;mepc = (uintptr_t)entry; // reset mstatus ret-\u0026gt;mstatus = (uintptr_t)0x1800; // function argument ret-\u0026gt;gpr[10] = (uintptr_t)arg; // other GPR settings ret-\u0026gt;gpr[0] = (uintptr_t)0; // $0 register ret-\u0026gt;gpr[2] = (uintptr_t)ret; // $sp register // return context pointer return ret; } æ‰€ä»¥çº¿ç¨‹ä¸€æ—¦ä»tentryè¿”å›ï¼Œå°†ä¼šè·³è½¬è‡³éæ³•çš„åœ°å€ï¼Œä»è€Œå¯¼è‡´ç¨‹åºéæ³•è¿è¡Œã€‚\nå›åˆ°rt_hw_stack_init()å‡½æ•°ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å¯¹è¾“å…¥çš„stack_addrè¿›è¡Œå¯¹é½ï¼š\n1 2 3 4 /* align the incoming stack pointer */ rt_uint8_t *stk; stk = stack_addr + sizeof(uintptr_t); stk = (rt_uint8_t *)RT_ALIGN_DOWN((uintptr_t)stk, sizeof(uintptr_t)); æ­¤å¤„æˆ‘ä»¬ä»¥sizeof(uintptr_t)ä¸ºæœ€å°å•ä½ï¼Œå¯¹è¯¥åœ°å€è¿›è¡Œå‘ä¸‹å¯¹é½ï¼ˆå› ä¸ºæ ˆåº•åœ¨å†…å­˜åˆ†å¸ƒä¸Šä½äºé«˜ä½åœ°å€ï¼‰ï¼Œè€ŒRT_ALIGN_DOWNæ˜¯RT-Threadå†…éƒ¨å®šä¹‰çš„å®ã€‚\néšåï¼Œç”±äºå¯¹kcontext()å‡½æ•°è€Œè¨€ï¼Œå…¶æ¥æ”¶çš„ç”¨äºæ„å»ºä¸Šä¸‹æ–‡çš„å‚æ•°åªæœ‰æ ˆç©ºé—´åˆ†å¸ƒkstackï¼Œä¸Šä¸‹æ–‡å…¥å£entryä»¥åŠå‘å…¥å£ä¼ é€’çš„å‚æ•°argï¼Œä½†æ˜¯RT-Threadä¸­çš„è¿˜å­˜åœ¨ä¸€ä¸ªtexitå‚æ•°ï¼Œè¿™å°±å¯¼è‡´ï¼Œæˆ‘ä»¬éœ€è¦æ„é€ ä¸€ä¸ªåŒ…è£¹å‡½æ•°ï¼Œè¿™é‡Œç§°ä¸ºtentry_wrapper()ï¼š\n1 2 3 4 5 6 7 static void tentry_wrapper(void *arg) { struct wrapper_args *stk_arg = (struct wrapper_args *)arg; // call tentry(parameter) first ((void (*)(void *))stk_arg-\u0026gt;tentry)(stk_arg-\u0026gt;parameter); // if return, call texit() ((void (*)())stk_arg-\u0026gt;texit)(); } è¯¥åŒ…è£¹å‡½æ•°çš„ä½œç”¨æ˜¯ï¼Œæ¥æ”¶ä¸€ä¸ªvoid *ç±»å‹çš„å‚æ•°argï¼Œè¯¥å‚æ•°åœ¨å‡½æ•°å†…è¢«å¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºä¸€ä¸ªç»“æ„ä½“ç±»å‹wrapper_argsï¼Œè¯¥ç±»å‹åŒ…æ‹¬ä¸‰ä¸ªå­—æ®µï¼š\n1 2 3 4 5 struct wrapper_args { void *tentry; void *texit; void *parameter; }; å…¶ä¸­tentryå³ä¸ºä¸Šä¸‹æ–‡çš„å…¥å£ï¼Œparameterå³ä¸ºä¸Šä¸‹æ–‡å…¥å£tentryå¯¹åº”çš„å‚æ•°ï¼Œtexitå³ä¸ºçº¿ç¨‹å¦‚æœåœ¨tentryè¿”å›çš„è¯éœ€è¦è°ƒç”¨çš„å‡½æ•°ï¼Œè¿›è€Œæˆ‘ä»¬å¯ä»¥åœ¨tentry_wrapper()å‡½æ•°ä¸­å…ˆå¯¹tentryè¿›è¡Œè°ƒç”¨ï¼Œéšåå¯¹texitè¿›è¡Œè°ƒç”¨ï¼Œè¿™æ ·ä¸€æ—¦tentryè¿”å›ï¼Œéšåä¼šè°ƒç”¨texitè¿›è¡Œå¤„ç†ã€‚\næœ‰äº†tentry_wrapper()å‡½æ•°ï¼Œæˆ‘ä»¬åœ¨åˆ›å»ºä¸Šä¸‹æ–‡æ—¶å®é™…ä¸Šå°±å¯ä»¥é€šè¿‡å¦‚ä¸‹å½¢å¼è°ƒç”¨kcontext()å‡½æ•°ï¼š\n1 kcontext([kstack], tentry_wrapper, [arg]); ä»¥ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦è€ƒè™‘çš„æ˜¯kcontext()å‡½æ•°çš„å¦å¤–ä¸¤ä¸ªå‚æ•°åº”è¯¥å¦‚ä½•è®¾å®šï¼Œé¦–å…ˆè€ƒè™‘argå‚æ•°ï¼Œå¯¹äºtentry_wrapper()å‡½æ•°ï¼Œæˆ‘ä»¬éœ€è¦ä¼ é€’ä¸€ä¸ªæŒ‡å‘ä¸€ä¸ªwrapper_argsç»“æ„ä½“çš„æŒ‡é’ˆï¼Œè¿™é‡Œå°±æ¶‰åŠåˆ°è¯¥ç»“æ„ä½“å¦‚ä½•åˆ›å»ºåŠå­˜å‚¨çš„é—®é¢˜ï¼Œä¸å¦¨å…ˆåœ¨rt_hw_stack_init()å‡½æ•°ä¸­å…ˆåˆå§‹åŒ–ä¸€ä¸ªwrapper_argsç»“æ„ä½“ï¼š\n1 2 3 4 5 /* allocate function arguments */ struct wrapper_args tmp_args; tmp_args.tentry = tentry; tmp_args.texit = texit; tmp_args.parameter = parameter; éšåï¼Œæˆ‘ä»¬éœ€è¦ç¡®å®šè¯¥ç»“æ„ä½“å­˜å‚¨çš„ä½ç½®ï¼Œé¦–å…ˆï¼Œè¿™ä¸ªç»“æ„ä½“è‚¯å®šä¸èƒ½ä»¥ä¸´æ—¶å˜é‡è¿›è¡Œå­˜å‚¨ï¼Œå› ä¸ºrt_hw_stack_init()å‡½æ•°å®é™…ä¸Šèµ·åˆ°ä¸€ä¸ªåˆå§‹åŒ–ä¸Šä¸‹æ–‡çš„åŠŸèƒ½ï¼Œæ‰€ä»¥è¯¥å‡½æ•°ä¸­çš„ä¸´æ—¶å˜é‡æ˜¯æ— æ³•åœ¨ç¨‹åºçš„æ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­éƒ½å­˜åœ¨çš„ã€‚å› æ­¤ï¼Œä¸€ä¸ªåˆé€‚çš„æ–¹æ³•ï¼Œå°±æ˜¯å°†è¿™ä¸ªç»“æ„ä½“å¤åˆ¶åˆ°è¯¥ä¸Šä¸‹æ–‡æ‰€åœ¨çš„æ ˆä¸Šï¼Œæ­¤å¤„å¯ä»¥ç›´æ¥å…ˆä»æ ˆåº•å¼€å§‹åˆ†é…ç©ºé—´ï¼š\n1 2 3 4 5 6 /* re-allocate the stack pointer */ size_t arg_size = sizeof(struct wrapper_args); stk = stk - arg_size; /* Copy wrapper arguments to stack */ memcpy(stk, \u0026amp;tmp_args, arg_size); æ­¤æ—¶ï¼Œæˆ‘ä»¬å°†stkä¸‹ç§»sizeof(struct wrapper_args)ï¼Œå¹¶è°ƒç”¨memcpy()å‡½æ•°å°†ç»“æ„ä½“å¤åˆ¶åˆ°è¿™ä¸€æ®µç©ºé—´ä¸­ï¼Œæ­¤æ—¶stkä¸€æ–¹é¢æŒ‡å‘çš„å°±æ˜¯æ ˆä¸Šå­˜å‚¨çš„ç»“æ„ä½“ï¼Œå¦ä¸€æ–¹é¢stkä¹Ÿå¯ä»¥ä½œä¸ºkstackå‚æ•°å¯¹åº”æ ˆç©ºé—´çš„æ ˆåº•ï¼Œä»¥ä½¿kcontext()å‡½æ•°å¯ä»¥ä»¥stkä¸ºæ ˆåº•æ„å»ºä¸Šä¸‹æ–‡ï¼Œäºæ˜¯rt_hw_stack_init()å‡½æ•°çš„å‰©ä½™éƒ¨åˆ†å¯ä»¥ä½œå¦‚ä¸‹å®ç°ï¼š\n1 2 3 4 5 /* create stack area */ Area stack_area = { .end = stk }; /* return context pointer */ return (rt_uint8_t *)kcontext(stack_area, tentry_wrapper, (void *)stk); RT-Threadçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ ä¸ºå®ç°RT-Threadçš„ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œæˆ‘ä»¬éœ€è¦å®ç°3ä¸ªå‡½æ•°ï¼š\n1 void rt_hw_context_switch(rt_ubase_t from, rt_ubase_t to); é¦–å…ˆï¼Œæ˜¯rt_hw_context_switch()å‡½æ•°ï¼Œå…¶åŒ…å«fromä¸toä¸¤ä¸ªå‚æ•°ï¼Œå…¶éƒ½æ˜¯æŒ‡å‘ä¸Šä¸‹æ–‡æŒ‡é’ˆå˜é‡çš„æŒ‡é’ˆï¼ˆäºŒçº§æŒ‡é’ˆï¼‰ã€‚ å®ƒç”¨äºåˆ‡æ¢åˆ°toæŒ‡å‘çš„ä¸Šä¸‹æ–‡æŒ‡é’ˆå˜é‡æ‰€æŒ‡å‘çš„ä¸Šä¸‹æ–‡ï¼Œå¹¶å°†å½“å‰ä¸Šä¸‹æ–‡çš„æŒ‡é’ˆå†™å…¥fromæŒ‡å‘çš„ä¸Šä¸‹æ–‡æŒ‡é’ˆå˜é‡ä¸­ã€‚\n1 void rt_hw_context_switch_to(rt_ubase_t to); å…¶æ¬¡ï¼Œæ˜¯rt_hw_context_switch_to()å‡½æ•°ï¼Œå®ƒåªåŒ…å«toä¸€ä¸ªå‚æ•°ï¼Œä»…å®ç°åˆ‡æ¢åˆ°toæŒ‡å‘çš„ä¸Šä¸‹æ–‡æŒ‡é’ˆå˜é‡æ‰€æŒ‡å‘çš„ä¸Šä¸‹æ–‡è¿™ä¸€åŠŸèƒ½ï¼Œé‚£ä¹ˆï¼Œè¯¥å‡½æ•°æ˜¾ç„¶å¯ä»¥å¤ç”¨rt_hw_context_switch()å®ç°ï¼š\n1 2 3 4 void rt_hw_context_switch_to(rt_ubase_t to) { // reuse function rt_hw_context_switch((rt_ubase_t)NULL, to); } æœ€åï¼Œæˆ‘ä»¬éœ€è¦å®ç°RT-Threadå¯¹åº”çš„äº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°ev_handler()ï¼š\n1 static Context* ev_handler(Event e, Context *c); é€šè¿‡ä¸Šè¿°åˆ†æï¼Œæˆ‘ä»¬å…¶å®ä»…éœ€å®ç°rt_hw_context_switch()å‡½æ•°ä¸ev_handler()å‡½æ•°å³å¯ï¼Œé¦–å…ˆè€ƒæŸ¥å‰è€…çš„å®ç°ï¼šæŒ‰PAè®²ä¹‰çš„è¯´æ³•ï¼Œä¸ºäº†è¿›è¡Œä¸Šä¸‹æ–‡åˆ‡æ¢, æˆ‘ä»¬å¯ä»¥é€šè¿‡yield()è§¦å‘ä¸€æ¬¡è‡ªé™·, åœ¨äº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°ev_handler()ä¸­è¯†åˆ«å‡ºä»£å¤„ç†äº‹ä»¶å, å†å¤„ç†toå’Œfromï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å°†toä¸fromå‚æ•°ä¼ é€’è‡³ev_handler()ã€‚\nç”±äºæ— æ³•é€šè¿‡å‡½æ•°å‚æ•°ä¼ é€’çš„æ–¹å¼ä¼ é€’toä¸fromï¼ŒåŒæ—¶ä¹Ÿä¸é€‚åˆç›´æ¥é€šè¿‡å…¨å±€å˜é‡çš„æ–¹å¼ä¼ é€’ï¼ˆå¤šçº¿ç¨‹æ—¶å­˜åœ¨é£é™©ï¼‰ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨è¿›ç¨‹æ§åˆ¶å—ï¼ˆPCB, process control blockï¼‰å­˜å‚¨toä¸fromï¼Œå› ä¸ºè¿™ä¸€æ•°æ®ç»“æ„ä¸ºå„çº¿ç¨‹æ‰€ç‹¬æœ‰ï¼Œä¸ä¼šå­˜åœ¨å¤šçº¿ç¨‹çš„å†²çªã€‚åœ¨RT-Threadä¸­ï¼ŒPCBå¯¹åº”çš„ç»“æ„ä½“åç§°ä¸ºrt_thread_tï¼Œå¯é€šè¿‡rt_thread_self()è·å–å½“å‰çº¿ç¨‹å¯¹åº”çš„PCBã€‚\n1 rt_thread_t current = rt_thread_self(); åŒæ—¶ï¼Œrt_thread_tç»“æ„ä½“ä¸­å­˜åœ¨user_dataå­—æ®µï¼Œç”¨äºå­˜å‚¨å½“å‰çº¿ç¨‹çš„ç§æœ‰ç”¨æˆ·æ•°æ®ï¼Œæˆ‘ä»¬å¯ä»¥å°†toä¸fromå­˜å‚¨äºè¯¥å­—æ®µä¸­ï¼š\n1 2 3 4 5 6 7 8 /* create private user data copy */ rt_ubase_t temp_user_data = current-\u0026gt;user_data; /* passing arguments */ rt_ubase_t param[2]; param[0] = to; param[1] = from; current-\u0026gt;user_data = (rt_ubase_t)param; æ­¤å¤„ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å¦å¤–å®šä¹‰ä¸€ä¸ªä¸´æ—¶å˜é‡temp_user_dataï¼Œä½œä¸ºå½“å‰çº¿ç¨‹åŸå§‹user_dataå­—æ®µçš„å¤‡ä»½ã€‚éšåï¼Œæˆ‘ä»¬ä¾¿å¯è°ƒç”¨yield()å‡½æ•°å®ç°ä¸Šä¸‹æ–‡åˆ‡æ¢ï¼Œå½“åˆ‡æ¢å›å½“å‰ä¸Šä¸‹æ–‡æ—¶ï¼ˆå³yield()è¿”å›æ—¶ï¼‰ï¼Œå†å°†ä¸´æ—¶å˜é‡å†…çš„user_dataå­—æ®µæ¢å¤ï¼š\n1 2 3 4 yield(); /* recover user data */ current-\u0026gt;user_data = temp_user_data; éšåï¼Œè€ƒè™‘äº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°ev_handler()çš„å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 static Context* ev_handler(Event e, Context *c) { rt_thread_t current; rt_ubase_t* param; switch (e.event) { case EVENT_YIELD: current = rt_thread_self(); param = (rt_ubase_t*)current-\u0026gt;user_data; rt_ubase_t to = param[0]; rt_ubase_t from = param[1]; if (from) *((Context **)from) = c; c = *(Context **)to; break; case EVENT_IRQ_TIMER: break; default: // printf(\u0026#34;Unhandled event ID = %d\\n\u0026#34;, e.event); } return c; } é˜…è¯»AM CTEçš„å®ç°å¯çŸ¥ï¼Œäº‹ä»¶å¤„ç†å›è°ƒå‡½æ•°æ˜¯åœ¨ä¸Šä¸‹æ–‡çœŸæ­£å‘ç”Ÿåˆ‡æ¢ä¹‹å‰è¢«è°ƒç”¨çš„ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬ä»å¯é€šè¿‡rt_thread_self()å‡½æ•°è·å–å½“å‰çš„PCBï¼Œå¹¶æå–fromä¸toå­—æ®µã€‚\n","date":"2025-10-21T00:00:00Z","image":"https://posvirus.github.io/p/rt-thread/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rt-thread/","title":"RT-Threadçš„ä¸Šä¸‹æ–‡"},{"content":"ç‰¹æƒçº§ä¸å¼‚å¸¸å“åº”æœºåˆ¶çš„å…³ç³» åœ¨PA3ä¸­ï¼Œè®²ä¹‰åŒæ—¶å¼•å…¥äº†ç‰¹æƒçº§ä¸å¼‚å¸¸å“åº”æœºåˆ¶è¿™ä¸¤ä¸ªæ¦‚å¿µï¼Œä»¥ä¸‹å°†ç®€å•é˜è¿°è¿™ä¸¤è€…ä¹‹é—´çš„å…³ç³»ï¼š\nä»¥RISC-Væ¶æ„ä¸ºä¾‹ï¼šé¦–å…ˆï¼ŒRISC-V å®šä¹‰äº†å¤šä¸ªç‰¹æƒçº§ï¼ˆå¦‚Machineæ¨¡å¼ã€Supervisoræ¨¡å¼ã€Useræ¨¡å¼ï¼‰ï¼Œæƒé™é€çº§é™ä½ã€‚ç”¨æˆ·ç¨‹åºé€šå¸¸åœ¨æœ€ä½ç‰¹æƒçº§ï¼ˆUæ¨¡å¼ï¼‰è¿è¡Œï¼Œæ— æ³•ç›´æ¥è®¿é—®å…³é”®ç³»ç»Ÿèµ„æºï¼Œè€Œå½“ç”¨æˆ·ç¨‹åºè¯•å›¾æ‰§è¡Œéæ³•æ“ä½œï¼ˆå¦‚è®¿é—®å—ä¿æŠ¤å†…å­˜ã€æ‰§è¡Œç‰¹æƒæŒ‡ä»¤ï¼‰æ—¶ï¼Œä¼šè§¦å‘ä¸€ä¸ªå¼‚å¸¸æˆ–ä¸­æ–­ã€‚è€Œæ­¤æ—¶ï¼Œå¼‚å¸¸ä½œä¸ºè¿›å…¥é«˜ç‰¹æƒçº§çš„å…¥å£ï¼ŒCPUä¼šè‡ªåŠ¨ä»å½“å‰ç‰¹æƒçº§é™·å…¥ï¼ˆTrapï¼‰åˆ°ä¸€ä¸ªé¢„å®šä¹‰çš„æ›´é«˜ç‰¹æƒçº§ï¼ˆé€šå¸¸æ˜¯Sæ¨¡å¼æˆ–Mæ¨¡å¼ï¼‰ã€‚\nå…¶æ¬¡ï¼Œåœ¨æ›´é«˜ç‰¹æƒçº§ä¸‹ï¼Œæ“ä½œç³»ç»Ÿæ‹¥æœ‰è¶³å¤Ÿçš„æƒé™æ¥åˆ†æå¼‚å¸¸åŸå› ã€é‡‡å–ç›¸åº”æªæ–½ï¼ˆå¦‚ç»ˆæ­¢éæ³•ç¨‹åºã€è°ƒåº¦å…¶ä»–ä»»åŠ¡ç­‰ï¼‰ã€‚å¤„ç†å®Œæ¯•åï¼Œæ“ä½œç³»ç»Ÿé€šè¿‡ç‰¹æ®Šçš„è¿”å›æŒ‡ä»¤ï¼ˆå¦‚ sret æˆ– mretï¼‰å°†æ§åˆ¶æƒäº¤è¿˜ç»™ç”¨æˆ·ç¨‹åºï¼Œå¹¶è¿”å›åˆ°åŸæ¥çš„ç‰¹æƒçº§å’Œç¨‹åºæ–­ç‚¹ç»§ç»­æ‰§è¡Œã€‚\nNEMUä¸­CSRçš„å®ç° CSRæœ¬è´¨ä»ä¸ºå¯„å­˜å™¨ï¼Œå› æ­¤åœ¨å®ç°æ—¶ä¸é€šç”¨å¯„å­˜å™¨ï¼ˆGPRï¼‰ç±»ä¼¼ï¼Œé¦–å…ˆï¼Œæˆ‘ä»¬å¯åœ¨CPU_stateç»“æ„ä½“ä¸­è¡¥å……å®šä¹‰CSRï¼š\n1 2 3 4 5 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; word_t csr[4]; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); ç”±äºæˆ‘ä»¬ç›®å‰ä»…ä½¿ç”¨äº†mstatusï¼Œmepcï¼Œmcauseä¸mtvecè¿™4ä¸ªCSRï¼Œå› æ­¤ä»…ä¾‹åŒ–4ä¸ªCSRå®ä¾‹å³å¯ã€‚\nåŒæ—¶ï¼Œæˆ‘ä»¬ä»¿ç…§GPRçš„å®ç°ï¼Œå®šä¹‰é’ˆå¯¹CSRçš„è®¿é—®å‡½æ•°ä¸å®ï¼š\n1 2 3 4 5 6 7 8 9 10 11 /* CSRs name mapping */ enum { MSTATUS = 0, MEPC, MCAUSE, MTVEC, }; static inline int check_csr_idx(int idx) { IFDEF(CONFIG_RT_CHECK, assert(idx \u0026gt;= 0 \u0026amp;\u0026amp; idx \u0026lt; 4)); return idx; } #define csr(idx) (cpu.csr[check_csr_idx(idx)]) åŒæ—¶ï¼Œç”±äºåœ¨RISC-Væ¶æ„ä¸­ï¼Œå¯¹å„ä¸ªCSRæœ‰å”¯ä¸€çš„ç¼–å€ï¼Œå› æ­¤æˆ‘ä»¬è¿˜éœ€å®ç°CSRç¼–å€ä¸æ•°ç»„ç´¢å¼•çš„æ˜ å°„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 static inline int csr_addr_map(int addr) { switch (addr) { case 0x300: return MSTATUS; // Machine Status Registers case 0x305: return MTVEC; // Machine Trap-Vector Base-Address Register case 0x341: return MEPC; // Machine Exception Program Counter case 0x342: return MCAUSE; // Machine Cause Register default: printf(\u0026#34;Illegal CSR\u0026#39;s index: %03x!\\n\u0026#34;, addr); return -1; } } #define csr_map(addr) (csr(csr_addr_map(addr))) æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨ï¼š\n1 csr_map(addr) è®¿é—®ç¼–å€ä¸ºaddrçš„CSRï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ï¼š\n1 csr(NAME) ç›´æ¥è®¿é—®åç§°ä¸ºNAMEçš„CSRï¼Œå¦‚csr(MSTATUS)è®¿é—®çš„å³ä¸ºmstatusã€‚\nåˆ©ç”¨ä¸Šè¿°å®ç°ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“åœ°åœ¨NEMUä¸­å®ç°ä¸å¼‚å¸¸å“åº”ä»¥åŠCSRç›¸å…³çš„æŒ‡ä»¤ï¼ŒåŒ…æ‹¬ecallï¼Œmretï¼Œcsrrwï¼Œcsrrsã€‚åŒæ—¶ï¼Œåœ¨å®ç°æŒ‡ä»¤çš„è¿‡ç¨‹ä¸­ï¼Œå¯èƒ½æ¶‰åŠå¯¹CSRçš„ä½æ“ä½œï¼Œå› æ­¤ï¼Œæˆ‘ä»¬è¡¥å……å®šä¹‰äº†å¦‚ä¸‹2ä¸ªå®ï¼š\n1 2 #define BITRST(x, bit) (x \u0026amp; ~(1u \u0026lt;\u0026lt; bit)) #define BITTO(x, src, tgt) (BITRST(x, tgt) | (((x \u0026gt;\u0026gt; src) \u0026amp; 1u) \u0026lt;\u0026lt; tgt)) å…¶ä¸­ï¼ŒBITRST(x, y)å¯ä»¥å°†xäºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„ç¬¬yä½ç½®é›¶ï¼ŒBITTO(x, s, t)å¯ä»¥å°†xäºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„ç¬¬sä½èµ‹å€¼ç»™ç¬¬tä½ã€‚\nyield testçš„æ‰§è¡Œæµç¨‹ é¦–å…ˆï¼Œæˆ‘ä»¬ç»™å‡ºyield testçš„å®Œæ•´ä»£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;amtest.h\u0026gt; Context *simple_trap(Event ev, Context *ctx) { switch(ev.event) { case EVENT_IRQ_TIMER: putch(\u0026#39;t\u0026#39;); break; case EVENT_IRQ_IODEV: putch(\u0026#39;d\u0026#39;); break; case EVENT_YIELD: putch(\u0026#39;y\u0026#39;); break; default: panic(\u0026#34;Unhandled event\u0026#34;); break; } return ctx; } void hello_intr() { printf(\u0026#34;Hello, AM World @ \u0026#34; __ISA__ \u0026#34;\\n\u0026#34;); printf(\u0026#34; t = timer, d = device, y = yield\\n\u0026#34;); io_read(AM_INPUT_CONFIG); iset(1); while (1) { for (volatile int i = 0; i \u0026lt; 1000000; i++) ; yield(); } } å½“ä¸»å‡½æ•°è°ƒç”¨hello_intr()å‡½æ•°å¹¶è¿è¡Œè‡³yield()å‡½æ•°æ—¶ï¼Œè§¦å‘è‡ªé™·æ“ä½œï¼Œå°†å‘ç”Ÿå¦‚ä¸‹è¡Œä¸ºï¼š\né¦–å…ˆï¼Œyield()å‡½æ•°è¢«æ‰§è¡Œï¼Œå…¶è¡Œä¸ºå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 void yield() { #ifdef __riscv_e asm volatile(\u0026#34;li a5, -1; ecall\u0026#34;); #else asm volatile(\u0026#34;li a7, -1; ecall\u0026#34;); #endif } å¯çŸ¥ï¼Œè¯¥å‡½æ•°ä¼šæ‰§è¡ŒecallæŒ‡ä»¤ã€‚è€ŒecallæŒ‡ä»¤ä¼šé…ç½®mstatusï¼Œä¾æ®å½“å‰ç³»ç»Ÿæ‰€å¤„çš„æ¨¡å¼å°†å¼‚å¸¸å·ä¿å­˜åœ¨mcauseä¸­ï¼Œä¿å­˜å½“å‰çš„PCè‡³mepcä¸­ï¼ˆæ­¤å¤„é»˜è®¤ç³»ç»Ÿåœ¨Mæ¨¡å¼ä¸­ï¼Œå¼‚å¸¸å·ä¸º11ï¼‰ï¼Œå¹¶è·³è½¬è‡³mtvecä¸­å­˜å‚¨çš„åœ°å€ï¼Œå¼€å§‹å¼‚å¸¸å“åº”æµç¨‹ï¼Œè¿™é‡ŒecallæŒ‡ä»¤çš„é€»è¾‘æ˜¯åœ¨NEMUä¸­å®ç°çš„ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 word_t isa_raise_intr(word_t NO, vaddr_t epc) { /* TODO: Trigger an interrupt/exception with \u0026#39;NO\u0026#39;. * Then return the address of the interrupt/exception vector. */ /* TODO: correctly set mstatus register */ csr(MSTATUS) = BITTO(csr(MSTATUS), 3, 7); // MPIE = MIE csr(MSTATUS) = BITRST(csr(MSTATUS), 3); // MIE = 0 csr(MEPC) = epc; csr(MCAUSE) = NO; return csr(MTVEC); } 1 INSTPAT(\u0026#34;0000000 00000 00000 000 00000 11100 11\u0026#34;, ecall , N, NEMUERROR(s-\u0026gt;pc, s-\u0026gt;dnpc, 11)); 1 2 3 #define NEMUERROR(thispc, nextpc, code) do { \\ nextpc = isa_raise_intr(code, thispc); \\ } while (0) ä¸ºä»€ä¹ˆyield()å‡½æ•°ä¸­ä¼šæœ‰li a5, -1è¿™ä¸€æ¡æŒ‡ä»¤ï¼šå› ä¸ºå¯¹äºRISC-Væ¶æ„è€Œè¨€ï¼ŒecallæŒ‡ä»¤æœ¬èº«ä¸å¸¦å‚æ•°ï¼Œä½†æ˜¯ä¸åŒç±»å‹çš„å¼‚å¸¸éƒ½éœ€è¦é€šè¿‡åŒæ ·çš„ecallå®ç°ï¼Œä¸ºäº†æ–¹ä¾¿æ“ä½œç³»ç»ŸåŒºåˆ†å¼‚å¸¸ç±»å‹ï¼Œæˆ‘ä»¬å°±éœ€è¦é€šè¿‡é¢å¤–çš„å¯„å­˜å™¨å¯¹å…¶è¿›è¡Œæ ‡è¯†ã€‚\næ›´å…·ä½“çš„å†…å®¹å¯ä»¥å‚è€ƒï¼šhttps://www.cnblogs.com/cilinmengye/p/18986213\né‚£ä¹ˆï¼Œç¨‹åºæ˜¯å¦‚ä½•ä¿è¯mtvecä¸­å­˜å‚¨çš„åœ°å€ä¸€å®šæ˜¯æŒ‡å‘å¼‚å¸¸å“åº”çš„ç¨‹åºæ®µçš„å‘¢ï¼Ÿè¿™æ˜¯é€šè¿‡cte_init()å‡½æ•°å®ç°çš„ï¼š\n1 2 3 4 5 6 7 8 9 bool cte_init(Context*(*handler)(Event, Context*)) { // initialize exception entry asm volatile(\u0026#34;csrw mtvec, %0\u0026#34; : : \u0026#34;r\u0026#34;(__am_asm_trap)); // register event handler user_handler = handler; return true; } è¯»è¯¥å‡½æ•°å¯çŸ¥ï¼Œç¨‹åºéšåä¼šè·³è½¬è‡³__am_asm_trapè¿™ä¸€ç¨‹åºæ®µæ‰€åœ¨ä½ç½®ï¼Œè€Œè¯¥ç¨‹åºæ®µç”±trap.Sä¸­çš„æ±‡ç¼–ç¨‹åºç»™å‡ºï¼Œé¦–å…ˆï¼Œå…¶ä¼šå¯¹ç¨‹åºçš„ä¸Šä¸‹æ–‡ï¼ˆæ‰€æœ‰GPRï¼ŒCSRï¼‰è¿›è¡Œå‹æ ˆï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 .align 3 .globl __am_asm_trap __am_asm_trap: addi sp, sp, -CONTEXT_SIZE MAP(REGS, PUSH) csrr t0, mcause csrr t1, mstatus csrr t2, mepc STORE t0, OFFSET_CAUSE(sp) STORE t1, OFFSET_STATUS(sp) STORE t2, OFFSET_EPC(sp) # set mstatus.MPRV to pass difftest li a0, (1 \u0026lt;\u0026lt; 17) or t1, t1, a0 csrw mstatus, t1 éšåï¼Œè¯¥ç¨‹åºæ®µä¼šè°ƒç”¨__am_irq_handle()å‡½æ•°ï¼Œè¯¥å‡½æ•°éœ€è¦æ¥æ”¶ä¸€ä¸ªContext *ç±»å‹çš„å‚æ•°ï¼Œå› æ­¤æˆ‘ä»¬ä½¿ç”¨mvæŒ‡ä»¤ï¼Œå°†æ ˆæŒ‡é’ˆspä½œä¸ºå‚æ•°ä¼ é€’ç»™è¯¥å‡½æ•°ï¼Œå› ä¸ºæ­¤æ—¶spæŒ‡å‘çš„æ­£æ˜¯å…ˆå‰é€šè¿‡å‹æ ˆç»„ç»‡èµ·çš„ä¸Šä¸‹æ–‡ç»“æ„ä½“ã€‚\n1 2 mv a0, sp call __am_irq_handle è€Œ__am_irq_handle()å‡½æ•°ä¼šæ‰§è¡Œå¦‚ä¸‹æ“ä½œï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 Context* __am_irq_handle(Context *c) { if (user_handler) { Event ev = {0}; switch (c-\u0026gt;mcause) { case 11: #ifdef __riscv_e if (c-\u0026gt;gpr[15] == -1) { // $a5 #else if (c-\u0026gt;gpr[17] == -1) { // $a7 #endif ev.event = EVENT_YIELD; // software: jump to next instruction c-\u0026gt;mepc += 4; break; } else { ev.event = EVENT_SYSCALL; break; } default: ev.event = EVENT_ERROR; break; } c = user_handler(ev, c); assert(c != NULL); } return c; } æ­¤æ—¶ï¼Œè¯¥å‡½æ•°ä¼šè°ƒç”¨user_handler()å‡½æ•°ï¼Œå¤„ç†ä¸åŒç±»å‹çš„å¼‚å¸¸ï¼Œå¼‚å¸¸çš„ç±»å‹æ˜¯é€šè¿‡ä¸Šä¸‹æ–‡ç»“æ„ä½“ä¸­ä¿å­˜çš„mcauseä»¥åŠGPRä¸­ä¿å­˜çš„æ ‡è¯†å…±åŒè§£æçš„ï¼Œè€Œæ­¤æ—¶çš„user_handler()å‡½æ•°è¢«èµ‹å€¼ä¸ºsimple_trap()å‡½æ•°ï¼ˆåœ¨am-testsçš„ä¸»å‡½æ•°ä¸­é¦–å…ˆå°†simple_trap()å‡½æ•°ä¼ å‚ç»™cte_init()å‡½æ•°ï¼Œéšååœ¨è¯¥å‡½æ•°ä¸­èµ‹å€¼user_handler()å‡½æ•°ï¼‰ã€‚\nåŒæ—¶ï¼Œå¯¹äºè‡ªé™·æ“ä½œï¼ŒecallæŒ‡ä»¤åœ¨mepcä¸­ä¿å­˜çš„æ˜¯è‡ªé™·æ“ä½œæœ¬èº«æ‰€åœ¨çš„PC, å› æ­¤è½¯ä»¶éœ€è¦å¯¹ä¿å­˜çš„PCåŠ ä¸Š4, ä½¿å¾—å°†æ¥è¿”å›åˆ°è‡ªé™·æ“ä½œçš„ä¸‹ä¸€æ¡æŒ‡ä»¤ã€‚\nsimple_trap()å‡½æ•°å®Œæˆæ‰§è¡Œåï¼Œä¼šä¸€ç›´è¿”å›è‡³__am_asm_trapç¨‹åºæ®µè°ƒç”¨__am_irq_handle()å‡½æ•°çš„ä½ç½®ï¼Œå¹¶å¼€å§‹æ¢å¤ä¸Šä¸‹æ–‡ï¼Œå°†ä¸Šä¸‹æ–‡ä¸­çš„GPRä¸CSRé€ä¸ªå¼¹æ ˆï¼š\n1 2 3 4 5 6 7 8 9 LOAD t1, OFFSET_STATUS(sp) LOAD t2, OFFSET_EPC(sp) csrw mstatus, t1 csrw mepc, t2 MAP(REGS, POP) addi sp, sp, CONTEXT_SIZE mret å®Œæˆä¸Šä¸‹æ–‡æ¢å¤åï¼Œæœ€åè°ƒç”¨mretæŒ‡ä»¤è·³è½¬å›mepcæ‰€å­˜å‚¨çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯æœ€åˆæ‰§è¡Œecallæ—¶çš„PC+4ï¼Œè€Œç»è¿‡while (1)çš„æ­»å¾ªç¯ï¼Œåˆä¼šé‡æ–°è¿è¡Œåˆ°yield()å‡½æ•°ï¼Œè¿›è€Œæ— é™é‡å¤å…ˆå‰æ‰€è¿°çš„æµç¨‹ï¼Œåœ¨ç¨‹åºè¿è¡Œç»“æœä¸­è¡¨ç°ä¸ºä¸æ–­è°ƒç”¨simple_trap()å‡½æ•°å¹¶è¾“å‡ºyã€‚\n","date":"2025-10-14T00:00:00Z","image":"https://posvirus.github.io/p/yield/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/yield/","title":"NEMUå¼‚å¸¸å“åº”æœºåˆ¶çš„å®ç°"},{"content":"NEMUå¯¹RV32Eæ¶æ„çš„é€‚é… åœ¨åŸå§‹çš„NEMUä¸­ï¼Œå¦‚æœå°è¯•ä½¿ç”¨RV32Eæ¶æ„çš„NEMUè¿è¡ŒNEMUï¼Œä¼šç›´æ¥æŠ¥é”™ï¼Œä¸ºä¿®å¤è¿™ä¸€é—®é¢˜ï¼Œæˆ‘ä»¬éœ€è¦å¯¹NEMUåšå¦‚ä¸‹ä¿®æ”¹ï¼š\né¦–å…ˆï¼Œåœ¨am-kernels/kernels/nemuæ–‡ä»¶å¤¹ä¸­çš„Makefileä¸­ï¼Œæˆ‘ä»¬é€šè¿‡build_amç›®æ ‡æ„å»ºå¯åœ¨AMä¸Šè¿è¡Œçš„NEMUï¼š\n1 2 3 4 build_am: $(MAKE) -C $(NEMU_HOME) $(ISA)-am_defconfig $(MAKE) -C $(NEMU_HOME) ARCH=$(ARCH) mainargs=$(mainargs) || \\ ($(MAKE) restore_config; false) è€Œè¿™ä¸€ä¾èµ–é¡¹ä¼šæŸ¥æ‰¾NEMUé¡¹ç›®ä¸­çš„$(ISA)-am_defconfigæ–‡ä»¶ï¼Œè€Œç›®å‰NEMUé¡¹ç›®çš„configsç›®å½•ä¸‹ç¼ºå°‘riscv32e-am_defconfigæ–‡ä»¶ï¼Œéœ€è¦äºˆä»¥è¡¥å……ï¼š\n1 2 3 4 CONFIG_TARGET_AM=y # CONFIG_TRACE is not set CONFIG_MSIZE=0x2000000 CONFIG_DEVICE=y éšåï¼Œå¯¹äºNEMUè€Œè¨€ï¼Œå…¶æ„å»ºçš„å¯æ‰§è¡Œæ–‡ä»¶çš„åç§°ï¼Œæ˜¯é€šè¿‡NEMUé¡¹ç›®æ ¹ç›®å½•ä¸‹Makefileçš„å¦‚ä¸‹ä»£ç ï¼š\n1 2 3 GUEST_ISA ?= $(call remove_quote,$(CONFIG_ISA)) ENGINE ?= $(call remove_quote,$(CONFIG_ENGINE)) NAME = $(GUEST_ISA)-nemu-$(ENGINE) ä»¥åŠAMé¡¹ç›®æ ¹ç›®å½•ä¸‹Makefileçš„å¦‚ä¸‹ä»£ç è”åˆæŒ‡å®šçš„ï¼š\n1 2 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) è¿™é‡Œçš„CONFIG_ISAåœ¨Kconfigä¸­åªä¼šè¢«é…ç½®ä¸ºriscv32ï¼Œè€Œä½¿ç”¨è¯¥æ¶æ„çš„Eæ‰©å±•æ˜¯é€šè¿‡CONFIG_RVEæ¥é…ç½®çš„ï¼Œè¿™å°±å¯¼è‡´ï¼Œåœ¨NEMUé¡¹ç›®çš„buildç›®å½•ä¸‹ï¼Œç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸ºriscv32-nemu-interpreter-riscv32e-nemu.binï¼Œéšåæˆ‘ä»¬ä¼šé€šè¿‡ï¼š\n1 2 3 4 5 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin åœ¨NEMUä¸Šè¿è¡ŒNEMUï¼Œä½†è¿™é‡Œå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œè¿™é‡ŒæŒ‡å®šçš„å¯æ‰§è¡Œæ–‡ä»¶ä¸­ï¼ŒISAæ˜¯åœ¨ARCHä¸­æå–çš„ï¼Œå› æ­¤å¦‚æœæˆ‘ä»¬è¾“å…¥ARCH=riscv32e-nemuçš„è¯ï¼Œå®é™…æå–çš„ISA=riscv32eï¼Œè¿™å°±å¯¼è‡´riscv32e-nemu-interpreter-riscv32e-nemu.binå¹¶ä¸å­˜åœ¨ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥å¯¹è¯¥Makefileç¨ä½œä¿®æ”¹ï¼Œä½¿å…¶å¯ä»¥æ­£å¸¸æ‰§è¡ŒåŠŸèƒ½ï¼š\n1 2 3 4 5 6 7 8 9 all: $(MAKE) save_config $(MAKE) build_am $(MAKE) restore_config @if [ \u0026#34;$(ISA)\u0026#34; = \u0026#34;riscv32e\u0026#34; ]; then \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/riscv32-nemu-interpreter-$(ARCH).bin; \\ else \\ $(MAKE) -C $(NEMU_HOME) run IMG=$(NEMU_HOME)/build/$(ISA)-nemu-interpreter-$(ARCH).bin; \\ fi AMç¨‹åºçš„è¿è¡Œé€»è¾‘ å¦‚æœæˆ‘ä»¬åœ¨am-kernels/kernels/nemu/ç›®å½•ä¸‹ï¼Œæ‰§è¡Œ\n1 make ARCH=$ISA-nemu mainargs=$executable_file_path è¿™ä¼šè®©æˆ‘ä»¬åœ¨NEMUä¸Šè¿è¡Œä¸€ä¸ªè½½å…¥å¯æ‰§è¡Œç¨‹åºé•œåƒçš„NEMUï¼Œå‡è®¾æˆ‘ä»¬åˆ©ç”¨æ­¤æ–¹æ³•è¿è¡Œam-kernels/kernelsç›®å½•ä¸‹çš„æ‰“å­—æ¸¸æˆï¼Œé‚£ä¹ˆæ‰“å­—æ¸¸æˆæ˜¯å¦‚ä½•å®ç°é…ç½®å¤–å±‚NEMUçš„è®¾å¤‡è¿›è¡Œè¯»å–æŒ‰é”®/åˆ·æ–°å±å¹•çš„å‘¢ï¼Ÿæ­¤å¤„å°†ç®€å•è¿›è¡Œè¯´æ˜ï¼š\né¦–å…ˆï¼Œæ­¤æ—¶æ•´ä¸ªç³»ç»Ÿçš„å±‚æ¬¡å¦‚ä¸‹ï¼š\n1 [OUTER NEMU]--\u0026gt;[INNER NEMU]--\u0026gt;[TYPING-GAME] æ‰“å­—æ¸¸æˆçš„å¯æ‰§è¡Œæ–‡ä»¶é•œåƒå°†è¢«åŠ è½½è‡³å†…å±‚NEMUä¸­ï¼Œè€Œå†…å­˜NEMUçš„å¯æ‰§è¡Œæ–‡ä»¶é•œåƒåˆè¢«åŠ è½½è‡³å¤–å±‚NEMUä¸­ã€‚\nå› æ­¤ï¼Œå½“æ‰“å­—æ¸¸æˆé¦–å…ˆè°ƒç”¨IOE APIå®ç°è®¾å¤‡é…ç½®æ—¶ï¼Œç”±äºå…¶è¿è¡Œåœ¨å†…å±‚NEMUä¸Šï¼Œå› æ­¤å…¶ä¼šè°ƒç”¨å†…å±‚NEMUè®¾å¤‡çš„å›è°ƒå‡½æ•°ï¼š\n1 [OUTER NEMU DEVICE] ??? [INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] ä½†æ˜¯ï¼Œå†…å±‚NEMUè®¾å¤‡æ˜¯å¦‚ä½•å°†é…ç½®ä¼ é€’ç»™å¤–å±‚NEMUçš„å‘¢ï¼Ÿè¿™å°±æ¶‰åŠåˆ°å½“å®šä¹‰CONFIG_TARGET_AMæ—¶ï¼Œå†…å­˜NEMUè®¾å¤‡çš„å›è°ƒå‡½æ•°è¡Œä¸ºä¼šé‡æ–°è¢«å®šä¹‰ï¼Œæ¯”å¦‚ï¼Œå¯¹äºVGAè€Œè¨€ï¼Œå…¶æ›´æ–°å±å¹•çš„é€»è¾‘å¦‚ä¸‹ï¼š\n1 2 3 4 5 static void init_screen() {} static inline void update_screen() { io_write(AM_GPU_FBDRAW, 0, 0, vmem, screen_width(), screen_height(), true); } å¯çŸ¥ï¼Œå†…å±‚NEMUæ­¤æ—¶ä¹Ÿè°ƒç”¨äº†IOE APIï¼Œè€Œç”±äºå…¶è¿è¡Œåœ¨å¤–å±‚NEMUä¸Šï¼Œæ­¤å¤„çš„IOE APIä¾¿ä¼šè°ƒç”¨å¤–å±‚è®¾å¤‡çš„å›è°ƒå‡½æ•°ï¼Œè€Œæ­¤æ—¶APIçš„ä½œç”¨ä¹Ÿæ˜¯å°†è‡ªèº«è®¾å¤‡çš„é…ç½®ä¼ é€’ç»™å¤–å±‚NEMUçš„è®¾å¤‡ï¼Œæ¯”å¦‚è¿™é‡Œçš„update_screen()å‡½æ•°ï¼Œå…¶è¡Œä¸ºå³æ˜¯å°†æ•´ä¸ªé¡µé¢æŒ‰ç…§vmemçš„å–å€¼æ›´æ–°ã€‚\n1 [OUTER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[INNER NEMU DEVICE]\u0026lt;--[IOE API]\u0026lt;--[TYPING-GAME] ","date":"2025-10-11T00:00:00Z","image":"https://posvirus.github.io/p/nemu-run-nemu/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-run-nemu/","title":"ä½¿ç”¨RV32Eæ¶æ„çš„NEMUè¿è¡ŒNEMU"},{"content":"è®¾å¤‡å®æ—¶æ—¶é’Ÿçš„å®ç° åœ¨PA2ä¸­ï¼Œæˆ‘ä»¬åªè¢«è¦æ±‚å®ç°AM_TIMER_UPTIMEï¼Œå³ç³»ç»Ÿå¯åŠ¨åçš„å¾®ç§’æ•°ï¼Œè€Œæ­¤å¤„ä¸ºäº†æ›´å¥½çš„å±•ç¤ºæ•ˆæœï¼Œæˆ‘ä»¬å°†å®ç°AM_TIMER_RTCï¼Œå®ç°å¯¹å½“å‰çœŸå®æ—¶é—´çš„è¯»å–ã€‚\nåœ¨AMçš„timer.cä¸­æˆ‘ä»¬å¯ä»¥çœ‹åˆ°ï¼Œrtcå…±æœ‰secondã€minuteã€hourã€dayã€monthä¸yearå…±6ä¸ªå­—æ®µï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦åœ¨NEMUçš„ä¸­ä¸ºè¿™äº›å­—æ®µåˆ†é…ç›¸åº”çš„ç©ºé—´ï¼Œä½†æ˜¯ï¼Œå¦‚æœæˆ‘ä»¬ä¸ºæ¯ä¸ªå­—æ®µéƒ½åˆ†é…ä¸€ä¸ª32ä½çš„ç©ºé—´ï¼Œæ—¶é’Ÿè®¾å¤‡çš„åœ°å€ç©ºé—´ä¼šä¸å…¶å®ƒè®¾å¤‡äº§ç”Ÿäº¤å ï¼Œä½†æˆ‘ä»¬åˆä¸å¸Œæœ›ä¿®æ”¹æ•´ä¸ªåœ°å€ç©ºé—´æ˜ å°„ï¼Œåº”è¯¥å¦‚ä½•è§£å†³è¿™ä¸ªé—®é¢˜å‘¢ï¼Ÿ\næˆ‘ä»¬æ³¨æ„åˆ°ï¼Œsecondã€minuteã€hourã€dayã€monthè¿™äº›å­—æ®µï¼Œå®ƒä»¬çš„å–å€¼å…¶å®éå¸¸æœ‰é™ï¼Œä»¥è‡³äºæˆ‘ä»¬åˆ†é…8ä½/16ä½çš„ç©ºé—´ç»™å®ƒä»¬å°±è¶³å¤Ÿäº†ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬é€šè¿‡ä¸‹é¢è¿™ç§æ–¹å¼ï¼Œå°†è¿™6ä¸ªå­—æ®µå‹ç¼©è‡³2ä¸ª32ä½ç©ºé—´ä¸­ï¼š\n1 2 // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] äºæ˜¯æˆ‘ä»¬ä»…éœ€å†ä¸ºæ—¶é’Ÿç”³è¯·8ä¸ªå­—èŠ‚çš„åœ°å€ç©ºé—´å³å¯ï¼š\n1 2 3 4 5 6 7 8 9 void init_timer() { rtc_port_base = (uint32_t *)new_space(16); #ifdef CONFIG_HAS_PORT_IO add_pio_map (\u0026#34;rtc\u0026#34;, CONFIG_RTC_PORT, rtc_port_base, 16, rtc_io_handler); #else add_mmio_map(\u0026#34;rtc\u0026#34;, CONFIG_RTC_MMIO, rtc_port_base, 16, rtc_io_handler); #endif IFNDEF(CONFIG_TARGET_AM, add_alarm_handle(timer_intr)); } è€Œå¯¹äºè¿™äº›å­—æ®µçš„èµ‹å€¼ï¼Œæˆ‘ä»¬è°ƒç”¨time.hä¸­çš„time()å‡½æ•°è·å–å½“å‰æ—¶é—´ï¼Œå¹¶è°ƒç”¨localtime()å‡½æ•°å°†å…¶æ ¼å¼åŒ–å³å¯ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 static void rtc_io_handler(uint32_t offset, int len, bool is_write) { assert(offset == 0 || offset == 4 || offset == 8 || offset == 12); if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { uint64_t us = get_time(); rtc_port_base[0] = (uint32_t)us; rtc_port_base[1] = us \u0026gt;\u0026gt; 32; time_t timep; struct tm *p; time(\u0026amp;timep); p = localtime(\u0026amp;timep); // rtc register allocation // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] rtc_port_base[2] = (((uint32_t)p-\u0026gt;tm_year) \u0026lt;\u0026lt; 16) | ((uint32_t)p-\u0026gt;tm_sec); rtc_port_base[3] = (((uint32_t)p-\u0026gt;tm_mon) \u0026lt;\u0026lt; 24) | (((uint32_t)p-\u0026gt;tm_mday) \u0026lt;\u0026lt; 16) | (((uint32_t)p-\u0026gt;tm_hour) \u0026lt;\u0026lt; 8) | ((uint32_t)p-\u0026gt;tm_min); } } æœ€åï¼Œæˆ‘ä»¬å³å¯åœ¨AMä¸­çš„timer.cä¸­å®ç°å­—æ®µçš„è§£ç ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 void __am_timer_rtc(AM_TIMER_RTC_T *rtc) { // rtc[2] = [(u16)year][(u16)second] // rtc[3] = [(u8)month][(u8)day][(u8)hour][(u8)minute] uint32_t time_cmb0 = inl(RTC_ADDR + 8); uint32_t time_cmb1 = inl(RTC_ADDR + 12); rtc-\u0026gt;second = (int)(time_cmb0 \u0026amp; ((uint32_t)0xffffu)); rtc-\u0026gt;minute = (int)(time_cmb1 \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;hour = (int)((time_cmb1 \u0026gt;\u0026gt; 8) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;day = (int)((time_cmb1 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;month = 1 + (int)((time_cmb1 \u0026gt;\u0026gt; 24) \u0026amp; ((uint32_t)0xffu)); rtc-\u0026gt;year = 1900 + (int)((time_cmb0 \u0026gt;\u0026gt; 16) \u0026amp; ((uint32_t)0xffffu)); } æ­¤å¤„ï¼Œæˆ‘ä»¬éœ€è¦æ³¨æ„ï¼Œlocaltime()å‡½æ•°è§£ç åçš„tm_yearå­—æ®µæ˜¯ç›¸å¯¹1900å¹´ç»è¿‡çš„å¹´ä»½ï¼Œtm_monå­—æ®µåˆ™å°†12ä¸ªæœˆç¼–ç ä¸º0-11ã€‚\nå¦å¤–ï¼Œæˆ‘ä»¬éœ€è¦è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆrtc_io_handler()ä¸­ä¼šå­˜åœ¨å¦‚ä¸‹è¯­å¥ï¼š\n1 if (!is_write \u0026amp;\u0026amp; (offset == 4 || offset == 8)) { } è¿™æ˜¯å› ä¸ºå¯¹AMè€Œè¨€ï¼Œè¯»å–AM_TIME_UPTIMEæ—¶ï¼š\n1 2 3 4 5 6 7 8 9 void __am_timer_uptime(AM_TIMER_UPTIME_T *uptime) { // read RTC register uint32_t time_msb = inl(RTC_ADDR + 4); uint32_t time_lsb = inl(RTC_ADDR); ; // convert to uptime uptime-\u0026gt;us = (((uint64_t)time_msb) \u0026lt;\u0026lt; 32) + (uint64_t)time_lsb; } æˆ‘ä»¬ä¼šåˆ†åˆ«å¯¹è¯¥æ—¶é—´çš„é«˜32ä½ä¸ä½32ä½è¿›è¡Œè¯»å–ï¼Œè€Œæˆ‘ä»¬åªå¸Œæœ›rtc_io_handler()å‡½æ•°ä¸­çš„usåœ¨è¯»å–é«˜32ä½ï¼ˆå³offsetä¸º4ï¼‰æ—¶è¿›è¡Œæ›´æ–°ï¼Œå› ä¸ºå¦‚æœusåœ¨ä¸¤æ¬¡è¯»å–ä¸­å‡è¿›è¡Œæ›´æ–°ï¼Œå‡è®¾è¯»å–é«˜32ä½æ—¶uså¯¹åº”å–å€¼ä¸º{32'h0, 32'hffffffff}ï¼Œè€Œè¯»å–ä½32ä½æ—¶uså¯¹åº”å–å€¼ä¸º{32'h1, 32'h00001234}ï¼Œé‚£ä¹ˆæˆ‘ä»¬æœ€ç»ˆè¯»å–çš„ç»“æœå°±æ˜¯{32'h0, 32'h00001234}ï¼Œè¿™æ˜¾ç„¶ä¸çœŸå®å€¼å­˜åœ¨è¾ƒå¤§çš„è¯¯å·®ã€‚å› æ­¤ï¼Œæˆ‘ä»¬è®©usåªåœ¨ç¬¬ä¸€æ¬¡è¯»å–æ—¶ï¼ˆæ­¤å¤„ä¸ºè¯»å–é«˜32ä½ï¼‰è¿›è¡Œæ›´æ–°ï¼Œä»¥ä¿è¯è¯»å–ç»“æœçš„æ­£ç¡®æ€§ã€‚\nå¯¹äºAM_TIME_RTCè€Œè¨€ï¼Œæˆ‘ä»¬ä¹Ÿåšäº†ç±»ä¼¼çš„å¤„ç†ï¼Œåªä¸è¿‡å› ä¸ºAM_TIME_RTCçš„æœ€å°æ—¶é—´å•ä½ä¸ºç§’ï¼Œæ‰€ä»¥å‘ç”Ÿä¸Šè¿°é”™è¯¯çš„å‡ ç‡å°äº†è®¸å¤šã€‚\nåŠŸèƒ½æ›´å¼ºå¤§çš„sprintf()å‡½æ•° åœ¨è¿è¡Œè®¾å¤‡æµ‹è¯•æ—¶ï¼Œæˆ‘ä»¬éœ€è¦åœ¨klibä¸­å®ç°åŠŸèƒ½æ›´å¼ºå¤§çš„I/Oè¾“å‡ºå‡½æ•°ï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦å¯¹å…ˆå‰å®ç°çš„sprintf()å‡½æ•°è¿›è¡Œä¼˜åŒ–ï¼Œä¼˜åŒ–ä¸»è¦é›†ä¸­åœ¨ä¸¤æ–¹é¢ï¼š\né¦–å…ˆï¼Œéœ€è¦å®Œæ•´å®ç°stdio.cä¸­çš„å‡½æ•°ï¼Œè¿™æ¶‰åŠåˆ°å¯¹å½“å‰å·²å®ç°å‡½æ•°çš„é‡æ„ä¸å¤ç”¨ã€‚ å…¶æ¬¡ï¼Œéœ€è¦å¢åŠ æ‰“å°å‡½æ•°çš„åŠŸèƒ½ï¼Œå…¶éœ€è¦è¯†åˆ«å‰å¯¼0ä¸å›ºå®šä½å®½çš„æ ‡è¯†ç¬¦ï¼Œå¦‚%02dï¼Œå› ä¸ºåœ¨è®¾å¤‡æµ‹è¯•ä¸­ä¼šä½¿ç”¨åˆ°è¯¥åŠŸèƒ½ã€‚ stdio.cä¸­åº“å‡½æ•°çš„å®Œæ•´å®ç° åœ¨åŸæ¥çš„stdio.cå®ç°ä¸­ï¼Œæˆ‘ä»¬ç›´æ¥å¯¹sprintf()å‡½æ•°è¿›è¡Œå®ç°ï¼Œè€Œæ²¡æœ‰å®ç°å‰©ä½™çš„å‡½æ•°ï¼Œä½†æ˜¯é€šè¿‡æ¢ç©¶å‘ç°ï¼Œå°†å‡½æ•°çš„åŠŸèƒ½ä¸»ä½“é›†ä¸­äºsprintf()å‡½æ•°ä¸­å®ç°å¹¶ä¸æ˜¯æœ€ä¼˜é€‰é¡¹ï¼Œä¸ºè¿½æ±‚å‡½æ•°å®ç°çš„å¯å¤ç”¨æ€§ï¼Œä¸€ä¸ªè¾ƒå¥½çš„å®ç°ç­–ç•¥å¦‚ä¸‹ï¼š\né¦–å…ˆï¼Œå®ç°vsprintf()å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šæ¥æ”¶ä¸€ä¸ªva_listå˜é‡æ¥å¯¹è¾“å…¥ä¸­çš„æ ‡è¯†ç¬¦è¿›è¡Œä¾‹åŒ–ã€‚\nå…¶æ¬¡ï¼ŒåŸºäºvsprintf()å‡½æ•°ï¼Œå®ç°sprintf()å‡½æ•°ä¸printf()å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int printf(const char *fmt, ...) { char buf[STR_MAX]; // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(buf, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); // put string to terminal putstr(buf); return strlen(buf); } 1 2 3 4 5 6 7 8 9 10 11 12 int sprintf(char *out, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); if (vsprintf(out, fmt, args) \u0026lt; 0) { va_end(args); return -1; } // end of args extraction va_end(args); return strlen(out); } æ­¤æ—¶ï¼Œæˆ‘ä»¬åªéœ€è¦å°†sprintf()å‡½æ•°çš„å¯å˜è¾“å…¥åˆ›å»ºä¸ºä¸€ä¸ªva_listå˜é‡ï¼Œéšåè°ƒç”¨vsprintf()å‡½æ•°å³å¯ã€‚printf()å‡½æ•°ä¹ŸåŒç†ï¼Œæˆ‘ä»¬åªéœ€åˆ©ç”¨vsprintf()å‡½æ•°å°†è¾“å‡ºæš‚å­˜äºä¸€ä¸ªå­—ç¬¦æ•°ç»„ä¸­ï¼Œéšåä½¿ç”¨putstr()å®å°†å…¶è¾“å‡ºå³å¯ã€‚\næœ€åï¼ŒåŸºäºvsprintf()å‡½æ•°ï¼Œå®ç°vsnprintf()å‡½æ•°ï¼Œå¹¶åŸºäºvsnprintf()å‡½æ•°å®ç°snprintf()å‡½æ•°å³å¯ï¼Œå¤ç”¨æ–¹æ³•ç±»ä¼¼ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int vsnprintf(char *out, size_t n, const char *fmt, va_list ap) { char buf[STR_MAX]; if (vsprintf(buf, fmt, ap) \u0026lt; 0) return -1; if (n == 0) return strlen(buf); strncpy(out, buf, n-1); out[n-1] = \u0026#39;\\0\u0026#39;; // ensure there is an EOL return strlen(buf); } int snprintf(char *out, size_t n, const char *fmt, ...) { // va-args initialization va_list args; va_start(args, fmt); int ret = vsnprintf(out, n, fmt, args); // end of args extraction va_end(args); return ret; } æ‰“å°å‡½æ•°çš„åŠŸèƒ½æ‰©å±• ä¸ºäº†å¢åŠ å¯¹å‰å¯¼0ä¸å›ºå®šä½å®½çš„è¯†åˆ«åŠŸèƒ½ï¼Œæˆ‘ä»¬éœ€è¦æ‰©å±•stdio.cä¸­å­˜å‚¨æ ‡è¯†ç¬¦çš„ç»“æ„ä½“SP_Tokenï¼š\n1 2 3 4 5 6 typedef struct sp_token { int type; char str[256]; int len; // limited string length (unlimited len = -1) bool pad; // 1: \u0026#39;0\u0026#39;; 0: \u0026#39; \u0026#39;; (only used in number) } SP_Token; è¿™é‡Œä¸ºå…¶å¢åŠ äº†2ä¸ªå­—æ®µï¼Œlenä»£è¡¨è¯¥æ ‡è¯†ç¬¦å¯¹åº”å®é™…å­—ç¬¦ä¸²çš„é•¿åº¦ï¼ˆä¸é™åˆ¶é•¿åº¦åˆ™å–-1ï¼‰ï¼Œpadåˆ™ä»£è¡¨ä½¿ç”¨ç©ºæ ¼è¿˜æ˜¯0è¿›è¡Œå‰å¯¼å¡«å……ã€‚\néšåï¼Œåœ¨sp_make_token()å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬éœ€è¦åœ¨è¯†åˆ«åˆ°%å­—ç¬¦åï¼Œè¡¥å……å¯¹å‰å¯¼0ä¸å›ºå®šä½å®½çš„è¯†åˆ«é€»è¾‘ï¼Œéšåå†è¿›è¡Œåç»­è¯†åˆ«ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // set initial state sp_tokens[nr_sp_token].len = -1; sp_tokens[nr_sp_token].pad = false; // %0, zero filled number if (fmt[position] == \u0026#39;0\u0026#39;) { sp_tokens[nr_sp_token].pad = true; position = position + 1; } // limited length data if ((fmt[position] \u0026gt; \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { int str_len = (int)(fmt[position] - \u0026#39;0\u0026#39;); // MSB position = position + 1; while ((fmt[position] \u0026gt;= \u0026#39;0\u0026#39;) \u0026amp;\u0026amp; (fmt[position] \u0026lt;= \u0026#39;9\u0026#39;)) { str_len = 10 * str_len + (int)(fmt[position] - \u0026#39;0\u0026#39;); position = position + 1; } sp_tokens[nr_sp_token].len = str_len; } /* ... */ return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } æœ€åï¼Œåœ¨å°†æ ‡è¯†ç¬¦å¯¹åº”è¾“å…¥å‚æ•°æ˜ å°„ä¸ºå­—ç¬¦ä¸²åï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–ä¾æ®æ ‡è¯†ç¬¦ç»“æ„ä½“ä¸­çš„lenä¸padå­—æ®µä¸ºå…¶æ·»åŠ å‰å¯¼å¡«å……ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 static char *cutstr(char *re, int len, bool pad) { int str_len = strlen(re); if ((len == -1) || (len \u0026lt;= str_len)) return re; char buf[256]; memset(buf, (pad) ? (\u0026#39;0\u0026#39;) : (\u0026#39; \u0026#39;), len - str_len); buf[len - str_len] = \u0026#39;\\0\u0026#39;; if ((re[0] == \u0026#39;-\u0026#39;) \u0026amp;\u0026amp; (pad)) { // negative number with \u0026#39;0\u0026#39; filling strcat(buf, re + 1); strcpy(re + 1, buf); } else { strcat(buf, re); strcpy(re, buf); } return re; } è¿™é‡Œéœ€è¦æ³¨æ„ï¼Œå¯¹äºè´Ÿæ•°ï¼Œå…¶å‰å¯¼å¡«å……å¦‚æœæ˜¯ç©ºæ ¼ï¼Œåˆ™å¡«å……åœ¨è´Ÿå·å‰ï¼›å¦‚æœæ˜¯0ï¼Œåˆ™å¡«å……åœ¨è´Ÿå·ä¸æ•°å­—ä¹‹é—´ã€‚\n","date":"2025-10-05T00:00:00Z","image":"https://posvirus.github.io/p/rtc-and-sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/rtc-and-sprintf/","title":"è®¾å¤‡å®æ—¶æ—¶é’Ÿä¸æ›´å¼ºå¤§çš„sprintf()å‡½æ•°"},{"content":"NEMUä¸­è®¾å¤‡åˆå§‹åŒ–çš„æµç¨‹ NEMUä¸­å„è®¾å¤‡çš„åˆå§‹åŒ–éµå¾ªä¸€ä¸ªç»Ÿä¸€çš„æµç¨‹ï¼Œä»¥ä¸‹å°†ä½œç®€è¦è¯´æ˜ï¼š\né¦–å…ˆï¼Œè®¾å¤‡ä¼šè°ƒç”¨new_space()å‡½æ•°ï¼Œè¿™ä¼šä»I/Oåœ°å€ç©ºé—´ä¸­åˆ†é…æŒ‡å®šå¤§å°çš„ç©ºé—´ç»™è¯¥è®¾å¤‡ï¼Œè¯¥å‡½æ•°åœ¨map.cä¸­å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 static uint8_t *io_space = NULL; static uint8_t *p_space = NULL; uint8_t* new_space(int size) { uint8_t *p = p_space; // page aligned; size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; p_space += size; assert(p_space - io_space \u0026lt; IO_SPACE_MAX); return p; } ä¸ºè§£é‡Šè¯¥å‡½æ•°çš„ä½œç”¨ï¼Œæˆ‘ä»¬é¦–å…ˆéœ€è¦æ˜ç¡®map.cä¸­å¦ä¸€ä¸ªå‡½æ•°init_map()çš„ä½œç”¨ï¼Œè¯¥å‡½æ•°åœ¨device.cä¸­çš„init_device()å‡½æ•°ä¸­è¢«è°ƒç”¨ï¼Œç”¨äºåˆå§‹åŒ–I/Oåœ°å€ç©ºé—´ï¼Œåœ¨å®Œæˆåˆå§‹åŒ–åæ‰ä¼šè°ƒç”¨å„è®¾å¤‡çš„åˆå§‹åŒ–å‡½æ•°ï¼Œå°†åœ°å€ç©ºé—´åˆ†é…ç»™å„ä¸ªè®¾å¤‡ã€‚\n1 2 3 4 5 void init_map() { io_space = malloc(IO_SPACE_MAX); assert(io_space); p_space = io_space; } è¿™é‡Œinit_map()å‡½æ•°é€šè¿‡malloc()å‡½æ•°åˆ›å»ºäº†ä¸€ä¸ªå¤§å°ä¸ºIO_SPACE_MAXçš„ç©ºé—´ï¼Œå¹¶å°†p_spaceä¸io_spaceå‡æŒ‡å‘è¯¥ç©ºé—´èµ·å§‹ä½ç½®ã€‚è¿™é‡Œp_spaceå®é™…ç”¨äºæŒ‡ç¤ºå½“å‰æœªåˆ†é…ç©ºé—´çš„èµ·å§‹ä½ç½®ï¼Œio_spaceåˆ™å§‹ç»ˆæ‰§è¡ŒI/Oåœ°å€ç©ºé—´çš„èµ·å§‹ä½ç½®ã€‚\næ³¨æ„ï¼ŒI/Oåœ°å€ç©ºé—´åœ¨NEMUæ•´ä¸ªç”Ÿå‘½å‘¨æœŸä¸­éƒ½éœ€è¦å­˜åœ¨ï¼Œä¸”å½“NEMUé€€å‡ºæ—¶ï¼Œæ“ä½œç³»ç»Ÿä¼šè‡ªåŠ¨å›æ”¶æ‰€æœ‰åˆ†é…çš„å†…å­˜ï¼Œæ‰€ä»¥æˆ‘ä»¬æ— éœ€æ‰‹åŠ¨é‡Šæ”¾åŠ¨æ€åˆ†é…çš„ç©ºé—´ã€‚\néšååœ¨è®¾å¤‡åˆå§‹åŒ–ä¸­è°ƒç”¨new_space()å‡½æ•°ï¼Œå®ƒä¼šé¦–å…ˆå°†p_spaceèµ‹å€¼ç»™æŒ‡é’ˆpï¼Œå³å°†pæŒ‡å‘å½“å‰æœªåˆ†é…ç©ºé—´çš„èµ·å§‹ä½ç½®ï¼Œä¹Ÿæ˜¯å³å°†åˆ†é…ç»™è¯¥è®¾å¤‡ç©ºé—´çš„åˆå§‹ä½ç½®ã€‚éšåï¼Œæˆ‘ä»¬å¯¹sizeè¿›è¡Œå‘ä¸Šå–æ•´çš„æ“ä½œï¼Œä½¿sizeå˜ä¸ºPAGE_SIZEçš„æ•´æ•°å€ï¼š\n1 size = (size + (PAGE_SIZE - 1)) \u0026amp; ~PAGE_MASK; æˆ‘ä»¬å¯ä»¥ç»“åˆå®é™…ç®€è¦ç†è§£è¿™æ®µä»£ç ï¼Œå‡è®¾PAGE_SIZEå–1ul \u0026lt;\u0026lt; 12ï¼ˆå³4096ï¼‰ï¼Œè¿™é‡Œsize + (PAGE_SIZE - 1)çš„æ“ä½œç¡®ä¿äº†ï¼š\nå½“sizeä¸ºPAGE_SIZEæ•´æ•°å€æ—¶ï¼Œsize + (PAGE_SIZE - 1)ä»åœ¨å½“å‰é¡µçš„èŒƒå›´å†…ã€‚ å½“sizeä¸ä¸ºPAGE_SIZEæ•´æ•°å€æ—¶ï¼Œsize + (PAGE_SIZE - 1)ä¼šè¿›å…¥ä¸‹ä¸€é¡µçš„èŒƒå›´å†…ã€‚ éšåï¼Œåˆ©ç”¨PAGE_MASKï¼Œæˆ‘ä»¬å¯ä»¥å°†size + (PAGE_SIZE - 1)äºŒè¿›åˆ¶è¡¨ç¤ºä¸­çš„ä½è‹¥å¹²ä½æ¸…é›¶ï¼Œä»è€Œå®ç°å–æ•´çš„æ“ä½œï¼Œæ¯”å¦‚PAGE_SIZEå–1ul \u0026lt;\u0026lt; 12æ—¶ï¼ŒPAGE_MASKå¯å–(1ul \u0026lt;\u0026lt; 12) - 1ï¼Œè¯¥æ•°äºŒè¿›åˆ¶è¡¨ç¤ºçš„ä½12ä½å‡ä¸º0ï¼Œä»è€Œä¸è¯¥æ•°æŒ‰ä½ä¸åä¸€å®šæ˜¯PAGE_SIZEçš„å€æ•°ï¼Œä¸”size + (PAGE_SIZE - 1)çš„æ“ä½œä¿è¯æœ€ç»ˆåˆ†é…çš„ç©ºé—´å¤§å°ä¸€å®šä¸å°äºåŸå§‹è¯·æ±‚çš„å¤§å°ã€‚\nå®Œæˆå¯¹é½åï¼Œæˆ‘ä»¬å¯ä»¥ç§»åŠ¨p_spaceæŒ‡é’ˆï¼Œå°†sizeå¤§å°çš„ç©ºé—´æ ‡è®°ä¸ºå·²åˆ†é…ï¼ŒåŒæ—¶æ£€æŸ¥æ˜¯å¦æœ‰è¶³å¤Ÿçš„ç©ºé—´å¯ä»¥åˆ†é…ï¼Œå¦‚æœ‰ï¼Œåˆ™è¿”å›æŒ‡é’ˆpï¼Œä»£è¡¨ç©ºé—´åˆ†é…å®Œæˆã€‚\néšåï¼Œè®¾å¤‡ä¼šè°ƒç”¨add_mmio_map()å‡½æ•°ï¼ˆè¿™é‡Œæˆ‘ä»¬åªè€ƒè™‘MMIOï¼‰ï¼Œè¿™ä¸€å‡½æ•°åœ¨mmio.cä¸­å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static IOMap maps[NR_MAP] = {}; static int nr_map = 0; static void report_mmio_overlap(const char *name1, paddr_t l1, paddr_t r1, const char *name2, paddr_t l2, paddr_t r2) { panic(\u0026#34;MMIO region %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;] is overlapped \u0026#34; \u0026#34;with %s@[\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, name1, l1, r1, name2, l2, r2); } /* device interface */ void add_mmio_map(const char *name, paddr_t addr, void *space, uint32_t len, io_callback_t callback) { assert(nr_map \u0026lt; NR_MAP); paddr_t left = addr, right = addr + len - 1; if (in_pmem(left) || in_pmem(right)) { report_mmio_overlap(name, left, right, \u0026#34;pmem\u0026#34;, PMEM_LEFT, PMEM_RIGHT); } for (int i = 0; i \u0026lt; nr_map; i++) { if (left \u0026lt;= maps[i].high \u0026amp;\u0026amp; right \u0026gt;= maps[i].low) { report_mmio_overlap(name, left, right, maps[i].name, maps[i].low, maps[i].high); } } maps[nr_map] = (IOMap){ .name = name, .low = addr, .high = addr + len - 1, .space = space, .callback = callback }; Log(\u0026#34;Add mmio map \u0026#39;%s\u0026#39; at [\u0026#34; FMT_PADDR \u0026#34;, \u0026#34; FMT_PADDR \u0026#34;]\u0026#34;, maps[nr_map].name, maps[nr_map].low, maps[nr_map].high); nr_map ++; } è¿™ä¸€å‡½æ•°ä¸»è¦åˆ›å»ºä¸€ä¸ªIOMapç»“æ„ä½“ï¼Œè¯¥ç»“æ„ä½“å­˜å‚¨äº†å†…å­˜åœ°å€ç©ºé—´ä¸I/Oåœ°å€ç©ºé—´çš„æ˜ å°„å…³ç³»ï¼Œå®ƒçš„å®šä¹‰åœ¨map.hä¸­ï¼š\n1 2 3 4 5 6 7 8 typedef struct { const char *name; // we treat ioaddr_t as paddr_t here paddr_t low; paddr_t high; void *space; io_callback_t callback; } IOMap; ä¸»è¦åŒ…æ‹¬ä»¥ä¸‹å­—æ®µï¼š\nnameï¼šè®¾å¤‡åç§°ã€‚ low/highï¼šç”¨äºæ˜ å°„çš„å†…å­˜åœ°å€ç©ºé—´çš„ä¸Š/ä¸‹è¾¹ç•Œã€‚ spaceï¼šæŒ‡å‘è®¾å¤‡I/Oåœ°å€ç©ºé—´èµ·å§‹ä½ç½®çš„æŒ‡é’ˆã€‚ callbackï¼šè®¾å¤‡å›è°ƒå‡½æ•°æŒ‡é’ˆï¼ŒæŒ‡å‘å„è®¾å¤‡çš„å›è°ƒå‡½æ•°ã€‚ äº†è§£IOMapçš„å®šä¹‰åï¼Œadd_mmio_map()å‡½æ•°æœ¬èº«çš„å®ç°æ˜¯ç®€å•çš„ï¼Œé¦–å…ˆéœ€è¦åˆ¤æ–­æ˜ å°„çš„å†…å­˜åœ°å€ç©ºé—´ä¸ç‰©ç†å†…å­˜åœ°å€ç©ºé—´ã€å·²æ³¨å†Œçš„è®¾å¤‡å†…å­˜åœ°å€ç©ºé—´æ˜¯å¦é‡å ï¼Œå¦‚æœä¸é‡å ï¼Œåˆ›å»ºç»“æ„ä½“å³å¯ã€‚\næœ‰äº†IOMapç»“æ„ä½“åï¼Œæˆ‘ä»¬ä¾¿å¯åœ¨NEMUä¸­ä½¿ç”¨map_read()å‡½æ•°ä¸map_write()å‡½æ•°æ¥è®¿é—®è®¾å¤‡å¹¶è°ƒç”¨å„è®¾å¤‡çš„å›è°ƒå‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 word_t map_read(paddr_t addr, int len, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; invoke_callback(map-\u0026gt;callback, offset, len, false); // prepare data to read word_t ret = host_read(map-\u0026gt;space + offset, len); return ret; } void map_write(paddr_t addr, int len, word_t data, IOMap *map) { assert(len \u0026gt;= 1 \u0026amp;\u0026amp; len \u0026lt;= 8); check_bound(map, addr); paddr_t offset = addr - map-\u0026gt;low; host_write(map-\u0026gt;space + offset, len, data); invoke_callback(map-\u0026gt;callback, offset, len, true); } mainargsçš„ä¼ é€’ å½“æˆ‘ä»¬åœ¨æµ‹è¯•ç¨‹åºç›®å½•ä¸‹è¾“å…¥mainargså‚æ•°æ—¶ï¼Œæµ‹è¯•ç¨‹åºç›®å½•ä¸‹çš„Makefileä¼šå…ˆåŒ…å«AM_HOMEç›®å½•ä¸‹ï¼ˆabstract-machineï¼‰çš„ä¸»Makefileï¼Œè€Œè¿™ä¸€ä¸»Makefileåˆä¼šä½¿ç”¨ä»¥ä¸‹è¯­å¥åŒ…å«ç‰¹å®šæ¶æ„çš„Makefileï¼š\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk ç‰¹å®šæ¶æ„çš„Makefileåˆä¼šåŒ…å«å…¶æ‰€è¿è¡Œå¹³å°ï¼ˆnemu/npc/nativeï¼‰çš„Makefileï¼Œä»¥riscv32-nemu.mkä¸ºä¾‹ï¼Œå…¶åŒ…å«ï¼š\n1 include $(AM_HOME)/scripts/platform/nemu.mk æœ€ç»ˆï¼Œå½“æˆ‘ä»¬ä½¿ç”¨make runæ—¶ï¼Œmainargsä¼šè¢«ä¼ é€’åˆ°è¿è¡Œå¹³å°ï¼ˆnemu/npc/nativeï¼‰çš„Makefileä¸­ï¼Œä»¥NEMUä¸ºä¾‹ï¼š\n1 2 3 4 5 insert-arg: image @python $(AM_HOME)/tools/insert-arg.py $(IMAGE).bin $(MAINARGS_MAX_LEN) \u0026#34;$(MAINARGS_PLACEHOLDER)\u0026#34; \u0026#34;$(mainargs)\u0026#34; run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin æ­¤æ—¶ï¼Œrunç›®æ ‡ä¼šä¾èµ–insert-argç›®æ ‡ï¼Œè€Œinsert-argç›®æ ‡ä¼šè°ƒç”¨Pythonç¨‹åºinsert-arg.pyï¼Œmainargsä¾¿ä½œä¸ºè¯¥Pythonç¨‹åºçš„è¾“å…¥å‚æ•°ï¼Œé‚£ä¹ˆï¼Œè¿™æ®µPythonç¨‹åºä¸»è¦åœ¨åšä»€ä¹ˆå‘¢ï¼Ÿ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env python3 from sys import argv bin = argv[1] max_len = int(argv[2]) placeholder = argv[3] mainargs = argv[4] if len(mainargs) \u0026gt;= max_len: print(\u0026#34;Error: mainargs should not be longer than {0} bytes\\n\u0026#34;.format( max_len)) exit(1) print(\u0026#34;mainargs={0}\u0026#34;.format(mainargs)) fp = open(bin, \u0026#39;r+b\u0026#39;) data = fp.read() idx = data.find(str.encode(placeholder)) if idx == -1: print(\u0026#34;Error: placeholder not found!\\n\u0026#34;) exit(1) fp.seek(idx) mainargs_pad = str.encode(mainargs)+ ((max_len - len(mainargs)) * str.encode(\u0026#34;\\0\u0026#34;)) if len(mainargs_pad) != max_len: print(\u0026#34;Error: len(mainargs_pad) != max_len\\n\u0026#34;) exit(1) fp.write(mainargs_pad) fp.close() é¦–å…ˆï¼Œå®ƒä¼šå°†mainargsæ‰“å°å‡ºæ¥ï¼ˆä½†è¿™ä¸ªæ‰“å°å¹¶å¯¹åº”helloç¨‹åºä¸­è¾“å‡ºmainargsçš„æ‰“å°è¡Œä¸ºï¼Œåè€…æ‰€helloç¨‹åºæœ¬èº«å†…ç½®çš„ï¼‰ï¼ŒåŒæ—¶å‘ç¼–è¯‘åçš„å¯æ‰§è¡Œæ–‡ä»¶æ³¨å…¥mainargså‚æ•°ã€‚éšåï¼Œåœ¨trm.cä¸­ï¼Œæˆ‘ä»¬ä¾¿å¯å°†mainargså‚æ•°é€šè¿‡_trm_init()å‡½æ•°æ³¨å…¥åˆ°mainå‡½æ•°ä¸­ï¼š\n1 2 3 4 5 6 static const char mainargs[MAINARGS_MAX_LEN] = MAINARGS_PLACEHOLDER; // defined in CFLAGS void _trm_init() { int ret = main(mainargs); halt(ret); } ","date":"2025-10-04T00:00:00Z","image":"https://posvirus.github.io/p/device-note/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/device-note/","title":"NEMUçš„è®¾å¤‡å®ç°æ³¨æ„äº‹é¡¹"},{"content":"æ­¤å¤„ï¼Œæˆ‘ä»¬ä¸»è¦å…³æ³¨å‘NPCä¸­é›†æˆDiffTestæ—¶çš„ä¸€äº›æ³¨æ„äº‹é¡¹ï¼š\nCPUçŠ¶æ€çš„å­˜å‚¨ åœ¨è¿è¡ŒDiffTestæ—¶ï¼Œæˆ‘ä»¬éœ€è¦æ¯”è¾ƒREFä¸DUTçš„CPUçš„çŠ¶æ€æ˜¯å¦ä¸€è‡´ï¼Œè€ŒNPCå…ˆå‰æœªå®šä¹‰å­˜å‚¨CPUçŠ¶æ€çš„ç»“æ„ä½“ï¼ˆå› ä¸ºCPUçš„çŠ¶æ€å®é™…å­˜å‚¨åœ¨RTLä»£ç ä¸­ï¼‰ï¼Œä¸ºæ–¹ä¾¿DiffTestçš„ä¼ å‚ï¼Œæˆ‘ä»¬è¡¥å……å®šä¹‰å­˜å‚¨CPUçŠ¶æ€çš„ç»“æ„ä½“CPU_stateï¼Œä»¥åŠå®ƒå¯¹åº”çš„åˆå§‹åŒ–å‡½æ•°ä¸çŠ¶æ€åŒæ­¥å‡½æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 typedef struct { word_t grf[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } CPU_state; CPU_state cpu; // defining struct facilitates parameter passing void load_cpu(Vtop* top) { cpu.pc = top-\u0026gt;inst_addr; long long temp_grf; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { gpr((long long)i, \u0026amp;temp_grf); cpu.grf[i] = (word_t)temp_grf; } } // the NPC RegisterFile has no reset signal, // so the initial value of gpr need to be given manually void init_cpu() { cpu.pc = RESET_VECTOR; for (int i = 0; i \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); i++) { cpu.grf[i] = 0; } } è¿™é‡Œï¼Œæˆ‘ä»¬é¦–å…ˆå®šä¹‰äº†load_cpu()å‡½æ•°ï¼Œå®ƒä¼šå°†å½“å‰CPUæ¨¡å—ä¸­çš„PCå¯„å­˜å™¨ä¸å¯„å­˜å™¨å †çš„å€¼ä¼ é€’è‡³cpuä¸­ã€‚å…¶æ¬¡ï¼Œæˆ‘ä»¬è¿˜è¡¥å……å®šä¹‰äº†init_cpu()å‡½æ•°ï¼Œè¿™æ˜¯å› ä¸ºï¼Œç›®å‰æˆ‘ä»¬åœ¨init_monitor()å‡½æ•°ä¸­è¿›è¡ŒDiffTestçš„åˆå§‹åŒ–ï¼Œè€Œè¯¥å‡½æ•°åœ¨ä¸»å‡½æ•°ä¸­ä¼šå…ˆäºç³»ç»Ÿä»¿çœŸå¤ä½å‡½æ•°æ‰§è¡Œï¼Œä¸ºä¿è¯cpuå¯ä»¥æ­£ç¡®è·å–CPUæ¨¡å—å¤ä½çš„çŠ¶æ€ï¼Œæˆ‘ä»¬éœ€è¦æ‰‹åŠ¨ä¸ºcpuä¸­çš„å­—æ®µèµ‹å€¼ã€‚\nRV32EæŒ‡ä»¤é›†çš„é€‚é… NEMUçš„Kconfigä¸­æœ‰ä¸€ä¸ªRVEçš„é€‰é¡¹ï¼Œç”¨äºå°†NEMUçš„æŒ‡ä»¤é›†æ¶æ„æŒ‡å®šä¸ºRV32Eï¼Œé€‰ä¸­è¯¥é€‰é¡¹åï¼Œä¼šåœ¨ç”ŸæˆCONFIG_RVEçš„å®å®šä¹‰ï¼Œä¸ºä½¿NEMUé€‚é…RV32EæŒ‡ä»¤é›†ï¼Œæˆ‘ä»¬éœ€è¦å¯¹NEMUä»£ç è¿›è¡Œç›¸åº”æ›´æ”¹ï¼Œä¿®æ”¹ä¸»è¦é›†ä¸­äºå¯¹NEMUçš„å¯„å­˜å™¨å †è®¿é—®ï¼Œéœ€è¦æ ¹æ®CONFIG_RVEåˆ¤æ–­å¯„å­˜å™¨çš„æ€»æ•°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 void isa_reg_display() { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { printf(\u0026#34;%s\\t0x%08x\\t%d\\n\u0026#34;, regs[reg_cnt], gpr(reg_cnt), gpr(reg_cnt)); } // extra print PC register printf(\u0026#34;pc\\t0x%08x\\t%d\\n\u0026#34;, cpu.pc, cpu.pc); } word_t isa_reg_str2val(const char *s, bool *success) { for (int reg_cnt = 0; reg_cnt \u0026lt; MUXDEF(CONFIG_RVE, 16, 32); reg_cnt = reg_cnt + 1) { if (strcmp(s, regs[reg_cnt]) == 0) { *success = true; return gpr(reg_cnt); } } // extra find pc register if (strcmp(s, \u0026#34;pc\u0026#34;) == 0) { *success = true; return cpu.pc; } *success = false; printf(\u0026#34;register %s not found!\\n\u0026#34;, s); return 0; } 1 2 3 4 5 6 7 8 9 10 11 12 bool isa_difftest_checkregs(CPU_state *ref_r, vaddr_t pc) { int reg_num = MUXDEF(CONFIG_RVE, 16, 32); extern const char* regs[]; for (int i = 0; i \u0026lt; reg_num; i++) { if (!difftest_check_reg(regs[i], pc, ref_r-\u0026gt;gpr[i], cpu.gpr[i])) return false; } if (!difftest_check_reg(\u0026#34;pc\u0026#34;, pc, ref_r-\u0026gt;pc, cpu.pc)) return false; return true; } NEMUä½œä¸ºREFçš„è‡ªåŠ¨åŒ–ç¼–è¯‘ åœ¨é›†æˆDiffTestæ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†NEMUç¼–è¯‘æˆåŠ¨æ€åº“æ–‡ä»¶ï¼Œå¹¶åœ¨NPCä¸­åŠ¨æ€é“¾æ¥è¯¥åŠ¨æ€åº“æ–‡ä»¶ï¼Œä»è€Œå®ç°NEMUä½œä¸ºREFçš„DiffTestã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å®é™…ä¸Šä¸å¸Œæœ›åœ¨æ¯æ¬¡è¿è¡ŒNPCçš„DiffTestæ—¶ï¼Œè¿˜è¦è¿›å…¥NEMUçš„ç›®å½•ä¸‹æ‰‹åŠ¨ä¿®æ”¹NEMUçš„é…ç½®å¹¶ç¼–è¯‘åŠ¨æ€åº“æ–‡ä»¶ï¼Œæˆ‘ä»¬å¸Œæœ›çš„ä¸€ä¸ªç†æƒ³çš„æ“ä½œæµæ˜¯ï¼š\nåœ¨NPCçš„Kconfigä¸­ä½¿èƒ½DiffTeståï¼Œæ„å»ºNPCæ—¶ä¼šè‡ªåŠ¨é…ç½®NEMUå¹¶ç¼–è¯‘NEMUçš„åŠ¨æ€åº“æ–‡ä»¶ã€‚ NEMUçš„é…ç½®åœ¨NPCè¿è¡ŒDiffTeståä¸åº”å‘ç”Ÿä»»ä½•æ›´æ”¹ã€‚ ä¸ºæ­¤ï¼Œæˆ‘ä»¬å®ç°å¦‚ä¸‹çš„Makefileï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 define remove_quote $(strip $(subst \u0026#34;,,$(1))) endef ifdef CONFIG_DIFFTEST DIFF_REF_PATH = $(NEMU_HOME) DIFF_REF_SO = $(NEMU_HOME)/build/$(call remove_quote,$(CONFIG_ISA))-$(call remove_quote,$(CONFIG_DIFFTEST_REF_NAME))-$(call remove_quote,$(CONFIG_ENGINE))-so MKFLAGS = GUEST_ISA=$(call remove_quote,$(CONFIG_ISA)) SHARE=1 ENGINE=$(call remove_quote,$(CONFIG_ENGINE)) ARGS_DIFF = --diff=$(DIFF_REF_SO) # Backup and restore NEMU config files NEMU_AUTO_CONF = $(NEMU_HOME)/include/config/auto.conf NEMU_AUTOCONF_H = $(NEMU_HOME)/include/generated/autoconf.h NEMU_AUTO_CONF_BK = $(NEMU_HOME)/include/config/auto.conf.bk NEMU_AUTOCONF_H_BK = $(NEMU_HOME)/include/generated/autoconf.h.bk backup-nemu: @echo \u0026#34;Backing up NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF) ]; then \\ cp $(NEMU_AUTO_CONF) $(NEMU_AUTO_CONF_BK); \\ sed -i \u0026#39;/^CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_TRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTO_CONF); \\ sed -i \u0026#39;/^CONFIG_ISA/d\u0026#39; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA=\\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ echo \u0026#34;CONFIG_ISA_riscv=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^CONFIG_RVE=\u0026#39; $(NEMU_AUTO_CONF); then \\ echo \u0026#34;CONFIG_RVE=y\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTO_CONF); \\ fi; \\ fi; \\ fi @if [ -f $(NEMU_AUTOCONF_H) ]; then \\ cp $(NEMU_AUTOCONF_H) $(NEMU_AUTOCONF_H_BK); \\ sed -i \u0026#39;/^#define CONFIG_TARGET_NATIVE_ELF/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_TRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ITRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_MTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_FTRACE/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_EXPR_TEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_DIFFTEST/d\u0026#39; $(NEMU_AUTOCONF_H); \\ sed -i \u0026#39;/^#define CONFIG_ISA/d\u0026#39; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA \\\u0026#34;riscv32\\\u0026#34;\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ echo \u0026#34;#define CONFIG_ISA_riscv 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ if [ -n \u0026#34;$(CONFIG_RVE)\u0026#34; ]; then \\ if ! grep -q \u0026#39;^#define CONFIG_RVE\u0026#39; $(NEMU_AUTOCONF_H); then \\ echo \u0026#34;#define CONFIG_RVE 1\u0026#34; \u0026gt;\u0026gt; $(NEMU_AUTOCONF_H); \\ fi; \\ fi; \\ fi restore-nemu: @echo \u0026#34;Restoring NEMU config files...\u0026#34; @if [ -f $(NEMU_AUTO_CONF_BK) ]; then \\ mv $(NEMU_AUTO_CONF_BK) $(NEMU_AUTO_CONF); \\ fi @if [ -f $(NEMU_AUTOCONF_H_BK) ]; then \\ mv $(NEMU_AUTOCONF_H_BK) $(NEMU_AUTOCONF_H); \\ fi ifdef CONFIG_DIFFTEST_REF_NEMU $(DIFF_REF_SO): @$(MAKE) backup-nemu @$(MAKE) -s -C $(DIFF_REF_PATH) $(MKFLAGS) @$(MAKE) restore-nemu endif .PHONY: $(DIFF_REF_SO) backup-nemu restore-nemu endif è¯¥Makefileçš„åŸºæœ¬ç»“æ„å‚è€ƒäº†nemu/tools/difftest.mkï¼Œå…¶ä¸­DIFF_REF_SOå³ä¸ºREFçš„åŠ¨æ€åº“æ–‡ä»¶ï¼Œå½“å°†è¯¥MakefileåŒ…å«åœ¨ä¸»Makefileä¸­ï¼Œå³å¯é€šè¿‡ï¼š\n1 2 3 4 5 run: $(VERILOG_INPUT) $(VRC_INPUT) ifdef CONFIG_DIFFTEST @echo \u0026#34;-------- REF COMPILE ---------\u0026#34; @$(MAKE) $(DIFF_REF_SO) endif è°ƒç”¨å¹¶æ„å»ºNEMUçš„åŠ¨æ€åº“æ–‡ä»¶ã€‚ä»¥ä¸‹ï¼Œæˆ‘ä»¬å°†è§£é‡Šè¯¥Makefileæ˜¯å¦‚ä½•å®ç°å¯¹NEMUçš„é…ç½®åŠæ¢å¤çš„ï¼Œè¿™ä¸»è¦åŒ…æ‹¬ä¸¤æ–¹é¢ï¼š\né¦–å…ˆï¼Œåœ¨DIFF_REF_SOçš„MKFLAGSä¸­ï¼Œæˆ‘ä»¬å°†é€šè¿‡Makfileä¼ é€’NEMUçš„GUEST_ISAã€SHAREä¸ENGINEå‚æ•°ã€‚æ­¤å¤„è®¾ç½®SHARE=1ï¼ŒNEMUä¾¿ä¼šè‡ªåŠ¨ç¼–è¯‘æˆåŠ¨æ€åº“æ–‡ä»¶ã€‚\nå…¶æ¬¡ï¼Œå½“NEMUä½œä¸ºREFæ—¶ï¼Œæˆ‘ä»¬éœ€è¦é™¤èƒ½NEMUé…ç½®ä¸­ä¸€äº›éå¿…è¦çš„åŠŸèƒ½ï¼Œæ¯”å¦‚itraceã€ftraceã€mtraceç­‰ï¼Œå› ä¸ºè¿™äº›åŠŸèƒ½æœ¬èº«å…·æœ‰è¾“å‡ºåŠŸèƒ½ï¼Œå¦‚æœç¼–è¯‘åŠ¨æ€åº“æ–‡ä»¶ä¸­åŒ…å«è¿™äº›åŠŸèƒ½ï¼Œåœ¨NPCä¸­è¿è¡ŒDiffTestæ—¶å°†ä¼šæ··æ‚NEMUçš„è¾“å‡ºï¼Œé€ æˆåŠŸèƒ½å¼‚å¸¸ã€‚\nä¸ºæ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†backup-nemuä¸restore-nemuä¸¤ä¸ªç›®æ ‡ï¼Œå‰è€…ç”¨äºå°†NEMUé€šè¿‡Kconfigç”Ÿæˆçš„é…ç½®æ–‡ä»¶ï¼ˆautoconf.hä¸auto.confï¼‰ä¿å­˜ä¸ºå‰¯æœ¬ï¼Œå¹¶ä¿®æ”¹é…ç½®æ–‡ä»¶çš„é…ç½®é¡¹ï¼›åè€…åˆ™ç”¨äºå°†å‰¯æœ¬é‡æ–°åŠ è½½ä¸ºNEMUé…ç½®æ–‡ä»¶ã€‚åœ¨backup-nemuä¸­ï¼Œæˆ‘ä»¬ä¿®æ”¹çš„é…ç½®ä¸»è¦åŒ…æ‹¬ï¼š\né™¤èƒ½CONFIG_TARGET_NATIVE_ELFï¼Œä¿è¯NEMUç¼–è¯‘æˆåŠ¨æ€åº“æ–‡ä»¶ï¼Œæ­¤å¤„ä¹‹æ‰€ä»¥æ²¡æœ‰è¡¥å……å®šä¹‰CONFIG_TARGET_SHAREï¼Œæ˜¯å› ä¸ºå®šä¹‰è¯¥é…ç½®çš„æ•ˆæœå®Œå…¨ç­‰åŒäºåœ¨æ„å»ºæ—¶ä¼ é€’SHARE=1ã€‚ é™¤èƒ½NEMUçš„æŒ‡ä»¤é›†æ¶æ„ï¼Œå°†å…¶ç»Ÿä¸€è®¾ç½®ä¸ºRISCV32ï¼Œè¿™ä½¿å¾—å³ä½¿æˆ‘ä»¬æ²¡æœ‰ä½¿ç”¨RISCV32æ¶æ„çš„NEMUï¼Œä»ç„¶å¯ä»¥åœ¨NPCä¸­æˆåŠŸç¼–è¯‘RISCV32æ¶æ„çš„NEMUåŠ¨æ€åº“æ–‡ä»¶ã€‚ é™¤èƒ½NEMUçš„itraceï¼Œmtraceï¼ŒftraceåŠŸèƒ½ã€‚ é™¤èƒ½NEMUçš„sdbè¡¨è¾¾å¼æ±‚å€¼æµ‹è¯•åŠŸèƒ½ã€‚ å½“NPCæŒ‡ä»¤é›†æ¶æ„ä¸ºRV32Eï¼Œåœ¨NEMUä¸­è¡¥å……å®šä¹‰CONFIG_RVEï¼Œå°†å…¶æŒ‡ä»¤é›†æ¶æ„ä¿®æ”¹ä¸ºRV32Eã€‚ DiffTestçš„æ—¶åºé—®é¢˜ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 static void trace_and_difftest(Vtop *top) { #ifdef CONFIG_ITRACE log_write(\u0026#34;%s\\n\u0026#34;, logbuf); #endif if (g_print_step) { IFDEF(CONFIG_ITRACE, puts(logbuf)); } #ifdef CONFIG_DIFFTEST pc_get(\u0026amp;pc_d, \u0026amp;dnpc_d); load_cpu(top); difftest_step((vaddr_t)pc_d, (vaddr_t)dnpc_d); // current-cycle difftest #endif } static void exec_once(Vtop *top, VerilatedContext *contextp, VerilatedFstC *tfp, bool rst) { if (rst) { EDGE_TRG_EVENT(top, top-\u0026gt;rst = 0; top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); } #ifdef CONFIG_ITRACE IRingBuffer_write(top); #endif half_cycle(top, contextp, tfp); EDGE_TRG(top); half_cycle(top, contextp, tfp); #ifdef CONFIG_FTRACE int type_ft; long long int pc_ft, dnpc_ft; ftrace_type(\u0026amp;type_ft); pc_get(\u0026amp;pc_ft, \u0026amp;dnpc_ft); switch (type_ft) { case 1: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, false); break; case 2: print_return((vaddr_t)pc_ft); break; case 3: print_call((vaddr_t)pc_ft, (vaddr_t)dnpc_ft, true); break; default: break; } #endif #ifdef CONFIG_ITRACE char *p = logbuf; p += snprintf(p, MAX_LOGBUF_LEN, FMT_WORD \u0026#34;:\u0026#34;, top-\u0026gt;inst_addr); int i; uint8_t *inst = (uint8_t *)\u0026amp;top-\u0026gt;inst; for (i = 4 - 1; i \u0026gt;= 0; i --) { p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } memset(p, \u0026#39; \u0026#39;, 1); p += 1; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, logbuf + MAX_LOGBUF_LEN - p, top-\u0026gt;inst_addr, (uint8_t *)\u0026amp;top-\u0026gt;inst, 4); #endif EDGE_TRG_EVENT(top, top-\u0026gt;inst = vaddr_ifetch(top-\u0026gt;inst_addr, 4)); // next instruction fetch } ç”±äºæˆ‘ä»¬é‡‡ç”¨è‡ªå®šä¹‰çš„å®EDGE_TRG_EVENT()æ¥å®ç°å¯¹Verilatorç”Ÿæˆæ–‡ä»¶çš„æ¿€åŠ±ï¼Œè¿™ä¼šåœ¨å®ç°DiffTestæ—¶å¸¦æ¥ä¸€äº›æ—¶åºé—®é¢˜ï¼Œå…·ä½“è€Œè¨€ï¼šNPCä¸­å®šä¹‰çš„exec_once()å‡½æ•°å®é™…ä¸Šä»¿çœŸçš„æ˜¯ä»å½“å‰æ—¶é’Ÿå‘¨æœŸæ—¶é’Ÿä¸Šå‡æ²¿å¼€å§‹ï¼Œåˆ°ä¸‹ä¸€æ—¶é’Ÿå‘¨æœŸä¸Šå‡æ²¿å‰çš„æ—¶é—´ï¼Œè¿™ä½¿å¾—å½“è¯¥å‡½æ•°æ‰§è¡Œå®Œæˆï¼Œå½“å‰æŒ‡ä»¤è¿˜æ²¡æœ‰å¯¹å¯„å­˜å™¨å †è¿›è¡Œå†™å›æ“ä½œï¼ˆè¿™éœ€è¦ç­‰åˆ°ä¸‹ä¸€æ—¶é’Ÿä¸Šå‡æ²¿åï¼‰ï¼Œå¯„å­˜å™¨å †å†…éƒ¨çš„å–å€¼è¿˜æ²¡æœ‰æ›´æ–°ï¼Œå› æ­¤ï¼Œå¦‚æœåƒNEMUä¸­ï¼Œåœ¨exec_once()æ‰§è¡Œå®Œæˆåç›´æ¥è¿›è¡ŒDiffTestï¼Œä¾¿ä¼šå¼•å‘é”™è¯¯ã€‚\nä¸ºæ­¤ï¼Œæˆ‘ä»¬è°ƒæ•´äº†exec_once()å‡½æ•°çš„æ‰§è¡Œé¡ºåºï¼Œå°†å…¶ä»¿çœŸçš„æ—¶é—´ä¿®æ”¹ä¸ºä»å½“å‰æ—¶é’Ÿå‘¨æœŸæ—¶é’Ÿä¸Šå‡æ²¿åå¼€å§‹ï¼Œåˆ°ä¸‹ä¸€æ—¶é’Ÿä¸Šå‡æ²¿åç»“æŸï¼Œå³åœ¨exec_once()å‡½æ•°ä¸­ä¼šé¢„å–ä¸‹ä¸€å‘¨æœŸçš„æŒ‡ä»¤ã€‚åŒæ—¶ï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–ä¿è¯åœ¨ç³»ç»Ÿå¤ä½åï¼Œexec_once()å‡½æ•°ä¸­ä¹Ÿä¼šé¢„å–ç¬¬ä¸€å‘¨æœŸçš„æŒ‡ä»¤ã€‚\n","date":"2025-09-30T00:00:00Z","image":"https://posvirus.github.io/p/npc-note2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note2/","title":"NPCå®ç°æ—¶çš„æ³¨æ„äº‹é¡¹ï¼ˆ2ï¼‰"},{"content":"NPCæŒ‡ä»¤çš„åæ±‡ç¼– å½“ç›´æ¥åœ¨NPCä¸­ä½¿ç”¨capstoneé¡¹ç›®æä¾›çš„åæ±‡ç¼–åŠŸèƒ½ï¼Œå¹¶å°†NEMUä¸­çš„disasm.cå¤åˆ¶åˆ°NPCä¸­ï¼Œä¼šå‡ºç°æŠ¥é”™ã€‚å…·ä½“è€Œè¨€ï¼Œæˆ‘ä»¬éœ€è¦å¯¹disasm.cä¸­çš„å‡ ä¸ªå‡½æ•°æŒ‡é’ˆè¿›è¡Œæ˜¾ç¤ºå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼š\n1 2 3 4 5 6 7 8 9 cs_err (*cs_open_dl)(cs_arch arch, cs_mode mode, csh *handle) = NULL; cs_open_dl = reinterpret_cast\u0026lt;cs_err (*)(cs_arch, cs_mode, csh*)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_open\u0026#34;)); assert(cs_open_dl); cs_disasm_dl = reinterpret_cast\u0026lt;size_t (*)(csh, const uint8_t*, size_t, uint64_t, size_t, cs_insn**)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_disasm\u0026#34;)); assert(cs_disasm_dl); cs_free_dl = reinterpret_cast\u0026lt;void (*)(cs_insn*, size_t)\u0026gt;(dlsym(dl_handle, \u0026#34;cs_free\u0026#34;)); assert(cs_free_dl); NPCä¸­sdbå‘½ä»¤è¡Œçš„å®ç° sdbå‘½ä»¤è¡Œéœ€è¦è°ƒç”¨readline.håº“å®ç°ï¼Œåœ¨C++ä¸­ï¼Œç”±äºreadlineæ˜¯ä¸€ä¸ªåŠ¨æ€åº“ï¼Œç¼–è¯‘çš„æ—¶å€™éœ€è¦åŠ ä¸Š-lreadlineï¼Œä¸ç„¶ä¼šæ‰¾ä¸åˆ°ç›¸å…³çš„å‡½æ•°ã€‚åœ¨Verilatorä¸­ï¼Œæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨-LDFLAGåŠ è½½è¿™ä¸€åŠ¨æ€åº“ã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 13 # load readline library (used for sdb) LDFLAGS_VR += -lreadline run: $(VERILOG_INPUT) $(VRC_INPUT) @rm -rf input.vc @echo \u0026#34;$(INPUT_FLAG)\u0026#34; | cat \u0026gt; input.vc @echo @echo \u0026#34;---------- VERILATE ----------\u0026#34; @rm -rf $(OBJ_PATH)/* @@$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ $(addprefix -LDFLAGS , $(LDFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $^ sdbæ‰«æNPCå¯„å­˜å™¨çš„å®ç° æˆ‘ä»¬è€ƒè™‘é€šè¿‡DPI-Cå®ç°ï¼Œè¯·æ³¨æ„DPI-Cå®é™…ä¸Šæ˜¯åŒå‘çš„ï¼Œå³ï¼šæˆ‘å¯ä»¥åœ¨RTLä»£ç ä¸­è°ƒç”¨C++ä¸­å®ç°çš„å‡½æ•°ï¼ˆimportï¼‰ï¼Œä¹Ÿå¯ä»¥åœ¨C++ä»£ç ä¸­è°ƒç”¨RTLä»£ç ä¸­å®šä¹‰çš„ä»»åŠ¡ï¼ˆexportï¼‰ã€‚åœ¨sdbä¸­å®ç°æ‰«æNPCå¯„å­˜å™¨æ˜¾ç„¶å±äºåè€…ï¼Œå³æˆ‘ä»¬éœ€è¦åœ¨RTLä»£ç ä¸­å®šä¹‰ä¸€ä¸ªè¯»å–å¯„å­˜å™¨çš„ä»»åŠ¡ï¼Œå†åœ¨C++ä»£ç ä¸­è°ƒç”¨è¯¥ä»»åŠ¡ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 export \u0026#34;DPI-C\u0026#34; task gpr; task gpr; input longint addr; // 64-bit space output longint data; // 64-bit space if (addr == -1) begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, cur_pc}; end else begin data = {{(64-`ysyx_25070184_DATA_WIDTH){1\u0026#39;b0}}, u_ysyx_25070184_IDU.u_ysyx_25070184_RegisterFile.rf[addr[`ysyx_25070184_REG_ADDR_WIDTH-1:0]]}; end endtask åœ¨å®ç°è¯¥ä»»åŠ¡æ—¶ï¼Œæœ‰ä»¥ä¸‹å‡ ç‚¹éœ€è¦æ³¨æ„ï¼š\nè¿™é‡Œæˆ‘ä»¬å°†ä»»åŠ¡åå®šä¹‰æˆgprï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨C++ä»£ç ä¸­é€šè¿‡gpr(N)è¯»å–ç¬¬Nä¸ªå¯„å­˜å™¨çš„å€¼ï¼Œä¿æŒå…¶ä¸NEMUä»£ç ä¸­çš„ä¸€è‡´æ€§ã€‚ æˆ‘ä»¬å°†ä»»åŠ¡å®šä¹‰åœ¨é¡¶å±‚æ¨¡å—ä¸­ï¼Œè¿™æ ·å¯ä»¥åŒæ—¶è¯»å–PCå¯„å­˜å™¨ä¸é€šç”¨å¯„å­˜å™¨ã€‚ ä¸ºé˜²æ­¢RTLä»£ç ä¸C++ä»£ç ä¸­å¤æ‚çš„ç±»å‹è½¬æ¢ï¼Œæˆ‘ä»¬ç»Ÿä¸€å°†addrä¸dataç±»å‹å®šä¹‰ä¸ºlongintï¼Œè¿™æ ·å¯ä»¥ç›´æ¥æ˜ å°„è‡³C++ä¸­çš„long longç±»å‹ï¼Œä¸”å¯¹32/64ä½çš„CPUå‡ä¸ä¼šäº§ç”Ÿæº¢å‡ºã€‚ Verilatorçš„ä¼˜åŒ–è¾“å‡º Verilatorç¼–è¯‘çš„åŸå§‹è¾“å‡ºç›¸å¯¹æ¯”è¾ƒå†—æ‚ï¼Œéš¾ä»¥åœ¨å…¶ä¸­æå–æœ‰æ•ˆä¿¡æ¯ï¼Œæˆ‘å¸Œæœ›å¯ä»¥é€šè¿‡ä¿®æ”¹Makefileå°†å…¶è¾“å‡ºä¼˜åŒ–ä¸ºNEMUçš„è§„æ•´ç¼–è¯‘è¾“å‡ºã€‚ä½†æ˜¯NEMUæ˜¯åŸºäºå¤šä¸ªMakefileçš„åµŒå¥—ï¼Œå®ç°å¯¹é¡¹ç›®çš„é€æ–‡ä»¶ç¼–è¯‘ï¼Œåœ¨NPCä¸­è¾ƒéš¾å®ç°è¿™ä¸€ç‚¹ï¼ˆä¸€èˆ¬æˆ‘ä»¬æ˜¯å°†éœ€è¦ç¼–è¯‘çš„æ–‡ä»¶ä¸€æ¬¡æ€§åœ¨Makefileä¸­åµŒå…¥Verilatorç¼–è¯‘æŒ‡ä»¤ä¸­ï¼‰ã€‚\näºæ˜¯ï¼Œæˆ‘è¿™é‡Œé‡‡ç”¨äº†ä¸€ç§å–å·§çš„æ–¹æ³•ï¼Œç›´æ¥å°†Verilatorçš„åŸå§‹ç¼–è¯‘è¾“å‡ºé‡å®šå‘å¹¶ä¾æ®å…¶è¾“å‡ºæ ¼å¼è¿›è¡Œä¿¡æ¯æå–ï¼Œä»è€Œå®ç°è§„æ•´è¾“å‡ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @$(VERILATOR) $(VERILATOR_FLAGS) --top-module $(VERILOG_TOP) \\ $(addprefix -CFLAGS , $(CXXFLAGS_VR)) \\ --Mdir $(OBJ_PATH) $(VERILATOR_INPUT) $^ 2\u0026gt;\u0026amp;1 | \\ while IFS= read -r line; do \\ if [[ \u0026#34;$$line\u0026#34; == *\u0026#34;g++\u0026#34;* ]]; then \\ last_word=$$(echo \u0026#34;$$line\u0026#34; | awk \u0026#39;{print $$NF}\u0026#39;); \\ if [[ \u0026#34;$$last_word\u0026#34; == *\u0026#34;.cpp\u0026#34; ]]; then \\ echo \u0026#34;[CXX] $$last_word\u0026#34;; \\ else \\ echo \u0026#34;[BUILD] $$last_word\u0026#34;; \\ fi; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;python3\u0026#34;* ]] \u0026amp;\u0026amp; [[ \u0026#34;$$line\u0026#34; == *\u0026#34;.cpp\u0026#34;* ]]; then \\ echo \u0026#34;$$line\u0026#34; | grep -o \u0026#39;[^ ]*\\.cpp\u0026#39; | while read -r cpp_file; do \\ echo \u0026#34;[PYTHON] verilator include: $$cpp_file\u0026#34;; \\ done; \\ elif [[ \u0026#34;$$line\u0026#34; == *\u0026#34;echo\u0026#34;* ]] || [[ \u0026#34;$$line\u0026#34; == *\u0026#34;rm\u0026#34;* ]]; then \\ continue; \\ else \\ echo \u0026#34;$$line\u0026#34;; \\ fi; \\ done sdbé€€å‡ºæŒ‡ä»¤çš„ä¼˜åŒ– åœ¨å®ç°NPCæ—¶ï¼Œå‘ç°NEMU sdbä¸­çš„é€€å‡ºæŒ‡ä»¤ï¼ˆqï¼‰æœ‰ä¸€ä¸ªbugï¼ŒåŸå§‹çš„cmd_q()å‡½æ•°é€šå¸¸å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 static int cmd_q(char *args) { nemu_state.state = NEMU_QUIT; return -1; } è¿™ä¼šå¯¼è‡´åœ¨è¿è¡Œam-kernelsä¸­çš„æµ‹è¯•ç¨‹åºæ—¶ï¼Œå¦‚æœæ²¡æœ‰ä½¿ç”¨æ‰¹å¤„ç†æ¨¡å¼ï¼Œä¸”ç¨‹åºæœ€ç»ˆHIT BAD TRAPï¼Œæ­¤æ—¶ç›´æ¥ä½¿ç”¨é€€å‡ºæŒ‡ä»¤é€€å‡ºï¼ŒNEMUçš„çŠ¶æ€ä¼šè¢«é‡ç½®ä¸ºNEMU_QUITï¼Œå¯¼è‡´æœ€åis_exit_status_bad()å‡½æ•°çš„è¿”å›å€¼ä»ä¸º0ï¼Œè¿™ä½¿å¾—ç¨‹åºè™½ç„¶æµ‹è¯•å¤±è´¥ï¼Œä½†æœ€ç»ˆä»ä¼šè¿”å›PASSçš„ç»“æœã€‚\nä¸ºæ­¤ï¼Œæˆ‘ä»¬éœ€è¦é¢å¤–å¯¹è¿è¡Œé€€å‡ºæŒ‡ä»¤æ—¶NEMUçš„çŠ¶æ€è¿›è¡Œåˆ¤æ–­ï¼Œå¦‚æœç¨‹åºéæ­£å¸¸é€€å‡ºï¼Œåˆ™ä¿æŒç¨‹åºå½“å‰çš„çŠ¶æ€ï¼š\n1 2 3 4 5 6 7 8 9 10 static int cmd_q(char *args) { // if nemu hits bad trap, hold state if ((nemu_state.state == NEMU_ABORT) || ((nemu_state.state == NEMU_END) \u0026amp;\u0026amp; (nemu_state.halt_ret != 0))) { // do nothing } else { nemu_state.state = NEMU_QUIT; } return -1; } è¿™é‡Œå…¶å®è¿˜æœ‰å¦å¤–ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¦‚æœåœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­é€€å‡ºï¼Œæ˜¯å¦éœ€è¦ä¿ç•™å½“å‰NEMUçš„çŠ¶æ€ï¼Ÿæ­¤å¤„æˆ‘ä»¬æš‚æ—¶è®¤ä¸ºæ— éœ€ä¿ç•™ï¼Œå³NEMUçš„çŠ¶æ€ä¼šè¢«é‡ç½®ä¸ºNEMU_QUITï¼Œç¨‹åºæµ‹è¯•ä¼šè¿”å›PASSçš„ç»“æœã€‚\nNPCé»˜è®¤ç¨‹åºçš„æ—¥å¿—è¾“å‡º åœ¨NPCä¸­ç›´æ¥è¿è¡Œé»˜è®¤ç¨‹åºï¼Œä¼šå‘ç°æ¯æ¡æ—¥å¿—è¾“å‡ºéƒ½ä¼šåœ¨å‘½ä»¤è¡Œä¸­é‡å¤è¾“å‡ºä¸¤æ¬¡ï¼Œè¿™ä¸»è¦æ˜¯å› ä¸ºåœ¨init_log()å‡½æ•°ä¸­ï¼š\n1 2 3 4 5 6 7 8 9 void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } log_fpè¢«åˆå§‹åŒ–ä¸ºstdoutï¼Œè¿™ä½¿å¾—log_write()åœ¨è°ƒç”¨fprintf()å‡½æ•°æ—¶ï¼Œä¹Ÿä¼šç›´æ¥å°†æ—¥å¿—è¾“å‡ºè‡³å‘½ä»¤è¡Œä¸­ã€‚\nä¸ºè§£å†³è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬åªéœ€åœ¨Makfileä¸­åŠ å…¥ï¼š\n1 override ARGS ?= --log=$(BUILD_PATH)/npc-log.txt ä½¿å¾—è¿è¡ŒNPCé»˜è®¤ç¨‹åºæ—¶çš„æ—¥å¿—ä¼šè¾“å‡ºè‡³æ„å»ºç›®å½•çš„npc-log.txtä¸­å³å¯ã€‚\n","date":"2025-09-25T00:00:00Z","image":"https://posvirus.github.io/p/npc-note1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/npc-note1/","title":"NPCå®ç°æ—¶çš„æ³¨æ„äº‹é¡¹ï¼ˆ1ï¼‰"},{"content":"åœ¨è®²ä¹‰ä¸­æåˆ°ï¼Œå½“ä½¿ç”¨difftest_regcpy()ä¼ é€’DUTä¸REFçš„å¯„å­˜å™¨çŠ¶æ€æ—¶ï¼Œéœ€è¦DUTçš„å¯„å­˜å™¨é¡ºåºä¸REFä¿æŒä¸€è‡´ã€‚æ­¤å¤„æˆ‘å°†è¯´æ˜å¦‚ä½•æ£€æŸ¥è¿™ä¸€ç‚¹ï¼š\né¦–å…ˆï¼Œå¯¹äºNEMUï¼ŒRISCV32æ¶æ„çš„å¯„å­˜å™¨é¡ºåºåœ¨reg.cä¸­å®šä¹‰ï¼š\n1 2 3 4 5 6 const char *regs[] = { \u0026#34;$0\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; ä»¥ä¸‹æˆ‘ä»¬åªéœ€è¦æŸ¥çœ‹RISCV32çš„REFï¼ˆå³Spikeï¼‰ä¸­ï¼Œå¯„å­˜å™¨çš„é¡ºåºæ˜¯å¦ä¸ä¹‹ä¸€è‡´å³å¯ï¼Œé¦–å…ˆï¼Œåœ¨toolç›®å½•ä¸‹çš„difftest.ccä¸­å¯è§ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void sim_t::diff_get_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { ctx-\u0026gt;gpr[i] = state-\u0026gt;XPR[i]; } ctx-\u0026gt;pc = state-\u0026gt;pc; } void sim_t::diff_set_regs(void* diff_context) { struct diff_context_t* ctx = (struct diff_context_t*)diff_context; for (int i = 0; i \u0026lt; NR_GPR; i++) { state-\u0026gt;XPR.write(i, (sword_t)ctx-\u0026gt;gpr[i]); } state-\u0026gt;pc = ctx-\u0026gt;pc; } å…¶ä¸­gpr[]æ˜¯NEMUä¸­çš„é€šç”¨å¯„å­˜å™¨æˆå‘˜ï¼Œè€ŒXPR[]åˆ™åº”è¯¥æ˜¯Spikeä¸­å¯¹åº”çš„é€šç”¨å¯„å­˜å™¨æˆå‘˜ï¼Œäºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥è¿›ä¸€æ­¥åœ¨Spikeçš„é¡¹ç›®ç›®å½•ä¸‹æœç´¢è¯¥æˆå‘˜å®šä¹‰ï¼Œæœ€åå‘ç°åœ¨regnames.ccä¸­å®šä¹‰äº†Spikeå¯¹åº”çš„å¯„å­˜å™¨é¡ºåºï¼š\n1 2 3 4 5 6 const char* xpr_name[] = { \u0026#34;zero\u0026#34;, \u0026#34;ra\u0026#34;, \u0026#34;sp\u0026#34;, \u0026#34;gp\u0026#34;, \u0026#34;tp\u0026#34;, \u0026#34;t0\u0026#34;, \u0026#34;t1\u0026#34;, \u0026#34;t2\u0026#34;, \u0026#34;s0\u0026#34;, \u0026#34;s1\u0026#34;, \u0026#34;a0\u0026#34;, \u0026#34;a1\u0026#34;, \u0026#34;a2\u0026#34;, \u0026#34;a3\u0026#34;, \u0026#34;a4\u0026#34;, \u0026#34;a5\u0026#34;, \u0026#34;a6\u0026#34;, \u0026#34;a7\u0026#34;, \u0026#34;s2\u0026#34;, \u0026#34;s3\u0026#34;, \u0026#34;s4\u0026#34;, \u0026#34;s5\u0026#34;, \u0026#34;s6\u0026#34;, \u0026#34;s7\u0026#34;, \u0026#34;s8\u0026#34;, \u0026#34;s9\u0026#34;, \u0026#34;s10\u0026#34;, \u0026#34;s11\u0026#34;, \u0026#34;t3\u0026#34;, \u0026#34;t4\u0026#34;, \u0026#34;t5\u0026#34;, \u0026#34;t6\u0026#34; }; ç»éªŒè¯ï¼Œå³å¯å‘ç°DUTä¸REFçš„å¯„å­˜å™¨é¡ºåºæ˜¯ä¸€è‡´çš„ï¼Œæ— éœ€é¢å¤–è°ƒæ•´ã€‚\n","date":"2025-08-24T00:00:00Z","image":"https://posvirus.github.io/p/difftest-gpr/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/difftest-gpr/","title":"DiffTestä¸­çš„å¯„å­˜å™¨ä¸€è‡´æ€§"},{"content":"nativeå¯æ‰§è¡Œæ–‡ä»¶çš„ç”Ÿæˆ åœ¨AM Makefileä¸­ï¼Œæˆ‘ä»¬ä¼šé€šè¿‡ï¼š\n1 2 ### Paste in arch-specific configurations (e.g., from `scripts/x86_64-qemu.mk`) -include $(AM_HOME)/scripts/$(ARCH).mk åŒ…å«æ¶æ„ç›¸å…³çš„Makefileï¼Œå½“æˆ‘ä»¬æŒ‡å®šARCH=nativeæ—¶ï¼ŒåŒ…å«çš„Makefileå†…å®¹å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 AM_SRCS := native/trm.c \\ native/ioe.c \\ native/cte.c \\ native/trap.S \\ native/vme.c \\ native/mpe.c \\ native/platform.c \\ native/ioe/input.c \\ native/ioe/timer.c \\ native/ioe/gpu.c \\ native/ioe/uart.c \\ native/ioe/audio.c \\ native/ioe/disk.c \\ CFLAGS += -fpie $(shell sdl2-config --cflags) ASFLAGS += -fpie -pie comma = , LDFLAGS_CXX = $(addprefix -Wl$(comma), $(LDFLAGS)) -pie -ldl $(shell sdl2-config --libs) run: image $(IMAGE).elf gdb: image gdb -ex \u0026#34;handle SIGUSR1 SIGUSR2 SIGSEGV noprint nostop\u0026#34; $(IMAGE).elf é¦–å…ˆï¼Œè¯¥Makefileä¼šå®šä¹‰AM_SRCSï¼ŒåŒ…å«GNU/Linuxé»˜è®¤çš„è¿è¡Œæ—¶ç¯å¢ƒnativeç”¨äºå®ç°AM APIçš„æ‰€æœ‰æºæ–‡ä»¶ï¼Œè¯¥å˜é‡ä¼šåœ¨amè·¯å¾„ä¸‹çš„Makefileä¸­è¢«ä½¿ç”¨ï¼Œä½œä¸ºSRCè¿›è¡Œç¼–è¯‘ï¼š\n1 2 3 4 5 NAME := am SRCS = $(addprefix src/, $(AM_SRCS)) INC_PATH += $(AM_HOME)/am/src include $(AM_HOME)/Makefile éšåï¼Œè¯¥Makefileä¼šè¡¥å……nativeæ¶æ„ä¸‹å¯¹åº”çš„ç¼–è¯‘é€‰é¡¹ï¼Œè¿™éƒ¨åˆ†æˆ‘ä»¬æš‚ä¸”ä¸ä½œè¯´æ˜ã€‚\næœ€åï¼Œè¯¥Makefileå®šä¹‰äº†runä¸gdbä¸¤ä¸ªç›®æ ‡ï¼Œåˆ†åˆ«ç”¨äºç›´æ¥æ‰§è¡Œ$(IMAGE).elfä¸è°ƒè¯•æ‰§è¡Œ$(IMAGE).elfã€‚\nMakefileçš„é”™è¯¯ç  ä½¿ç”¨å¦‚ä¸‹æŒ‡ä»¤åœ¨nativeæ¶æ„ä¸‹æ‰§è¡Œæµ‹è¯•ï¼š\n1 make ARCH=native ALL=$PROGRAM run å¦‚è‹¥æ‰§è¡Œå¤±è´¥ï¼Œåˆ™ä¼šè¿”å›ï¼š\n1 make[1]: *** [run] Error 1 æ­¤å¤„æˆ‘ä»¬å°†åˆ†æè¿™é‡Œé”™è¯¯ç 1çš„æ¥æºï¼šé¦–å…ˆï¼Œæˆ‘ä»¬çŸ¥é“æµ‹è¯•ç¨‹åºçš„æ­£ç¡®ä¸é”™è¯¯æ˜¯é€šè¿‡ç¨‹åºä¸­çš„check()å‡½æ•°å®ç°çš„ï¼Œäºæ˜¯æˆ‘ä»¬å¯æŸ¥çœ‹è¯¥å‡½æ•°çš„å®ç°ï¼Œåœ¨trap.hä¸­ï¼š\n1 2 3 void check(bool cond) { if (!cond) halt(1); } æ®æ­¤å¯è§‚å¯Ÿåˆ°ï¼Œå½“æ¡ä»¶condä¸ºfalseæ—¶ï¼Œå‡½æ•°ä¼šè°ƒç”¨halt(1)ï¼Œè¯¥å‡½æ•°åº”è¯¥æ˜¯æ§åˆ¶é”™è¯¯ç çš„æ ¸å¿ƒå‡½æ•°ï¼Œäºæ˜¯æˆ‘ä»¬å¯»æ‰¾è¯¥å‡½æ•°çš„å®šä¹‰ï¼Œåœ¨AMçš„trm.cä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 void halt(int code) { const char *fmt = \u0026#34;Exit code = 40h\\n\u0026#34;; for (const char *p = fmt; *p; p++) { char ch = *p; if (ch == \u0026#39;0\u0026#39; || ch == \u0026#39;4\u0026#39;) { ch = \u0026#34;0123456789abcdef\u0026#34;[(code \u0026gt;\u0026gt; (ch - \u0026#39;0\u0026#39;)) \u0026amp; 0xf]; } putch(ch); } __am_exit_platform(code); putstr(\u0026#34;Should not reach here!\\n\u0026#34;); while (1); } ä¸éš¾å‘ç°ï¼Œhalt()å‡½æ•°çš„codeå‚æ•°å³ç”¨äºæ§åˆ¶é”™è¯¯ç ã€‚ä¸ºéªŒè¯è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬ä¸å¦¨å°†check()å‡½æ•°ä¸­çš„halt(1)æ”¹ä¸ºhalt(3)ï¼Œå†æ¬¡è¿è¡ŒæŸä¸ªç¨‹åºï¼Œå¹¶æ‰“å°å¯¹åº”çš„é”™è¯¯è¾“å‡ºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Building add-run [native] # Building am-archive [native] + CC src/native/cte.c + CC src/native/vme.c + CC src/native/mpe.c + CC src/native/platform.c + CC src/native/ioe/audio.c + AR -\u0026gt; build/am-native.a # Building klib-archive [native] + CC src/stdio.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-native.a + CC tests/add.c # Creating image [native] + LD -\u0026gt; build/add-native.elf Exit code = 03h make[1]: *** [/home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk:21: run] Error 3 test list [1 item(s)]: add [ add] ***FAIL*** æ­¤æ—¶å¯è§‚å¯Ÿåˆ°ï¼Œç¨‹åºçš„é”™è¯¯ç è¾“å‡ºå·²å˜æˆ3ã€‚\nklibçš„é“¾æ¥ æ¡†æ¶ä»£ç ç¼–è¯‘åˆ°nativeçš„æ—¶å€™é»˜è®¤é“¾æ¥åˆ°glibc, æˆ‘ä»¬éœ€è¦æŠŠè¿™äº›åº“å‡½æ•°çš„è°ƒç”¨é“¾æ¥åˆ°æˆ‘ä»¬ç¼–å†™çš„klibæ¥è¿›è¡Œæµ‹è¯•. æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨klib.h ä¸­é€šè¿‡å®šä¹‰å®__NATIVE_USE_KLIB__æ¥æŠŠåº“å‡½æ•°é“¾æ¥åˆ°klibã€‚è¯¥åŠŸèƒ½çš„å®ç°åŸç†å¦‚ä¸‹ï¼š\nç¼–è¯‘é˜¶æ®µï¼š åœ¨klibçš„åº“å‡½æ•°å®ç°ä¸­åŒ…å«å¦‚ä¸‹å­—æ®µï¼š 1 2 3 #if !defined(__ISA_NATIVE__) || defined(__NATIVE_USE_KLIB__) ... #endif è¯¥å­—æ®µè¡¨æ˜ï¼Œå¦‚æœç¨‹åºåœ¨énativeæ¶æ„ä¸‹ç¼–è¯‘ï¼Œæˆ–åœ¨nativeæ¶æ„ä¸‹ç¼–è¯‘ä¸”å®šä¹‰äº†__NATIVE_USE_KLIB__ï¼Œåˆ™è¯‘è¯¥æ–‡ä»¶ä¸­çš„å‡½æ•°å®ç°ã€‚ é“¾æ¥é˜¶æ®µï¼š é“¾æ¥å™¨ä¼šæŒ‰é¡ºåºå¤„ç†ç›®æ ‡æ–‡ä»¶å’Œåº“ã€‚è‡ªå®šä¹‰å®ç°çš„ç¬¦å·ä¼šä¼˜å…ˆè¢«é“¾æ¥ï¼Œè€Œä¸æ˜¯ç³»ç»Ÿæ ‡å‡†åº“ä¸­çš„ç›¸åŒç¬¦å·ï¼ˆå› ä¸ºé“¾æ¥å™¨é»˜è®¤å…ˆå¤„ç†æ˜¾å¼æŒ‡å®šçš„ç›®æ ‡æ–‡ä»¶ï¼Œåå¤„ç†åº“ï¼‰ã€‚ ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-2/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-2/","title":"AM Makefileè§£è¯»ï¼ˆ2ï¼‰"},{"content":"æ­¤å¤„è¯´æ˜ftraceå®ç°çš„ä¸€äº›ç›¸å…³æ³¨æ„äº‹é¡¹ï¼š\nELFæ–‡ä»¶çš„è§£æ å‚è€ƒè®²ä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨man 5 elfæŸ¥çœ‹ELFæ–‡ä»¶çš„ç»“æ„ï¼ˆå¯è§†åŒ–ç»“æ„å¦‚ä¸Šå›¾æ‰€ç¤ºï¼‰ã€‚è¿™é‡Œä¸»è¦è¯´æ˜å¦‚ä½•å¯¹å…¶è¿›è¡Œè§£æï¼š\né¦–å…ˆï¼Œéœ€è¦æŒ‡å‡ºï¼ŒELFæ–‡ä»¶æœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥ä½¿ç”¨fread(), fopen()ç­‰å¯¹æ–‡ä»¶ç›¸å…³çš„æ ‡å‡†åº“å‡½æ•°å¯¹å…¶è¿›è¡Œè¯»å–ã€‚å…¶æ¬¡ï¼ŒåŸºäºELFæ–‡ä»¶çš„ç»“æ„ï¼Œæˆ‘ä»¬éœ€è¦æŸ¥æ‰¾å¹¶å­˜å‚¨æ‰€æœ‰å‡½æ•°ç¬¦å·çš„åœ°å€ï¼ˆValueï¼‰åŠå¯¹åº”å¤§å°ï¼ˆSizeï¼‰ï¼Œéœ€è¦ç»è¿‡å¦‚ä¸‹æ­¥éª¤ï¼š\né˜…è¯»ELFæ–‡ä»¶çš„Headerï¼Œä½¿ç”¨fread()å‡½æ•°å°†å…¶å†™å…¥ä¸€ä¸ªElfN_Ehdrç»“æ„ä½“ä¸­ï¼Œå¹¶ä»ä¸­æå–ï¼š Section Header Tableï¼ˆèŠ‚å¤´è¡¨ï¼‰çš„åœ°å€åç§»é‡ï¼ˆe_shoffï¼‰ã€‚ èŠ‚å¤´è¡¨çš„è¡¨é¡¹ä¸ªæ•°ï¼ˆäº¦å³è¡¨çš„è¡Œæ•°ï¼Œe_shnumï¼‰ã€‚ Section Header String Tableï¼ˆèŠ‚å¤´åå­—è¡¨ï¼‰å¯¹åº”çš„èŠ‚å¤´è¡¨è¡¨é¡¹ç´¢å¼•å€¼ï¼ˆe_shstrndxï¼‰ã€‚è¿™é‡Œéœ€è¦æŒ‡å‡ºï¼Œå¯¹äºèŠ‚å¤´è¡¨çš„æ¯ä¸€ä¸ªè¡¨é¡¹ï¼Œå‡ç´¢å¼•ELFæ–‡ä»¶ä¸­çš„ä¸€ä¸ªå®ä½“åŒºåŸŸï¼ŒèŠ‚å¤´è¡¨çš„å„è¡¨é¡¹ä»…ç”¨äºè®°å½•è¿™ä¸ªå®ä½“çš„å„ç§å‚æ•°ï¼ˆå¦‚åå­—ã€åœ°å€åç§»é‡ã€å¤§å°ä¸è¡¨é¡¹ä¸ªæ•°ç­‰ç­‰ï¼‰ï¼Œè€Œå­˜åœ¨ä¸€ä¸ªç§°ä¸ºèŠ‚å¤´åå­—è¡¨çš„å®ä½“ï¼Œä¸“é—¨ç”¨äºå‚¨å­˜èŠ‚å¤´è¡¨å„è¡¨é¡¹çš„åå­—ï¼Œä¸”èŠ‚å¤´è¡¨åŒæ ·ä¼šå­˜åœ¨ä¸€ä¸ªè¡¨é¡¹ç´¢å¼•å®ƒã€‚æ‰€ä»¥å¦‚æœæˆ‘ä»¬å‘è·å–èŠ‚å¤´è¡¨ä¸­çš„æŸä¸ªè¡¨é¡¹çš„åå­—ï¼Œæˆ‘ä»¬å°±éœ€è¦å…ˆè¯»å–èŠ‚å¤´åå­—è¡¨ï¼Œå†æ ¹æ®è¡¨é¡¹æä¾›çš„å‚æ•°åœ¨èŠ‚å¤´åå­—è¡¨å†…å®šä½åˆ°è¯¥è¡¨é¡¹å¯¹åº”çš„åå­—ã€‚ æ ¹æ®æå–çš„å‚æ•°ï¼ŒæŸ¥æ‰¾èŠ‚å¤´è¡¨ä¸­èŠ‚å¤´åå­—è¡¨å¯¹åº”çš„è¡¨é¡¹ï¼Œä½¿ç”¨fread()å‡½æ•°å°†å…¶å†™å…¥ä¸€ä¸ªElfN_Shdrç»“æ„ä½“ä¸­ï¼Œå¹¶ä»ä¸­æå–ï¼š èŠ‚å¤´åå­—è¡¨å¯¹åº”çš„åœ°å€åç§»é‡ï¼ˆsh_offsetï¼‰ã€‚ ä¾æ®èŠ‚å¤´åå­—è¡¨çš„åœ°å€åç§»é‡ï¼Œæˆ‘ä»¬å³å¯å®šä½åˆ°èŠ‚å¤´åå­—è¡¨ï¼Œéšåå¼€å§‹æ‰«æèŠ‚å¤´è¡¨çš„å„è¡¨é¡¹ï¼Œä½¿ç”¨fread()å‡½æ•°å¾ªç¯å°†å„è¡¨é¡¹å†™å…¥ä¸€ä¸ªElfN_Shdrç»“æ„ä½“ä¸­ï¼Œå¹¶æ ¹æ®è¡¨é¡¹çš„sh_nameå­—æ®µåœ¨èŠ‚å¤´åå­—è¡¨ä¸­è¯»å–å®šä½è¯¥è¡¨é¡¹çš„åå­—ï¼Œæˆ‘ä»¬éœ€è¦æŸ¥æ‰¾ä¸¤ä¸ªè¡¨é¡¹ï¼š åå­—ä¸º.symtabçš„è¡¨é¡¹ï¼šç¬¦å·è¡¨ï¼Œç”¨äºå­˜å‚¨ç¨‹åºä¸­çš„ç¬¦å·ï¼Œæˆ‘ä»¬éœ€è¦è·å–å…¶å¯¹åº”çš„åœ°å€åç§»é‡ï¼ˆsh_offsetï¼‰ä¸è¡¨é¡¹ä¸ªæ•°ï¼ˆè¿™é‡Œå¯ä»¥ä½¿ç”¨ç¬¦å·è¡¨æ€»å¤§å°sh_sizeä¸ç¬¦å·è¡¨å•ä¸ªè¡¨é¡¹çš„å¤§å°sh_entsizeç›¸é™¤å¾—åˆ°ï¼‰ã€‚ åå­—ä¸º.strtabçš„è¡¨é¡¹ï¼šç¬¦å·åå­—è¡¨ï¼Œç”¨äºå­˜å‚¨ç¬¦å·è¡¨ä¸­å„è¡¨é¡¹çš„åå­—ï¼Œå®ƒä¸ç¬¦å·è¡¨çš„å…³ç³»ç±»ä¼¼èŠ‚å¤´åå­—è¡¨ä¸èŠ‚å¤´è¡¨çš„å…³ç³»ã€‚æˆ‘ä»¬éœ€è¦è·å–å…¶å¯¹åº”çš„åœ°å€åç§»é‡ï¼ˆsh_offsetï¼‰ä¸å¤§å°ï¼ˆsh_sizeï¼‰ã€‚ å®Œæˆè¡¨é¡¹çš„æŸ¥æ‰¾åï¼Œä¾æ®ç¬¦å·è¡¨çš„åœ°å€åç§»é‡ï¼Œæˆ‘ä»¬å¯å®šä½åˆ°ç¬¦å·è¡¨ï¼Œéšåä¾¿å¯å¼€å§‹æŸ¥æ‰¾å‡½æ•°ç¬¦å·å¯¹åº”çš„è¡¨é¡¹ï¼Œå…·ä½“åŸç†æ˜¯ä½¿ç”¨fread()å‡½æ•°å¾ªç¯å°†å„è¡¨é¡¹å†™å…¥ä¸€ä¸ªElfN_Symç»“æ„ä½“ä¸­ï¼Œå¹¶æå–å…¶ä¸­çš„st_infoå­—æ®µï¼Œä½¿ç”¨ELFN_ST_TYPE()å®å³å¯ä»è¯¥å­—æ®µä¸­è§£æå¾—åˆ°è¯¥ç¬¦å·è¡¨é¡¹çš„ç±»å‹ï¼Œå¦‚æœæ˜¯STT_FUNCï¼ˆå‡½æ•°ç¬¦å·å¯¹åº”çš„ç±»å‹ï¼‰ï¼Œåˆ™å­˜å‚¨è¯¥è¡¨é¡¹çš„åœ°å€ï¼ˆst_valueï¼‰ä¸å¤§å°ï¼ˆst_sizeï¼‰ã€‚ åŒæ—¶ï¼Œå¯¹äºå‡½æ•°ç¬¦å·å¯¹åº”çš„è¡¨é¡¹ï¼Œæˆ‘ä»¬åŒæ ·å¯ä»¥ä¾æ®è¯¥è¡¨é¡¹çš„st_nameå­—æ®µï¼Œåœ¨ç¬¦å·åå­—è¡¨ä¸­å®šä½å¹¶å­˜å‚¨ç›¸åº”çš„å‡½æ•°åã€‚ åŸºäºä¸Šè¿°æµç¨‹ï¼Œå³å¯å®Œæˆå¯¹ELFæ–‡ä»¶çš„è§£æã€‚\nå‡½æ•°è°ƒç”¨ä¸è¿”å›çš„åˆ¤æ–­ å‡½æ•°è°ƒç”¨ä¸è¿”å›çš„åˆ¤æ–­éœ€è¦å‚è€ƒRISCVçš„ABIï¼ˆApplication Binary Interfaceï¼Œåº”ç”¨ç¨‹åºäºŒè¿›åˆ¶æ¥å£ï¼Œå®ƒå®šä¹‰äº†åº”ç”¨ç¨‹åºä¹‹é—´æˆ–åº”ç”¨ç¨‹åºå’Œæ“ä½œç³»ç»Ÿä¹‹é—´è¿›è¡ŒäºŒè¿›åˆ¶çº§äº¤äº’æ—¶å¿…é¡»éµå¾ªçš„è§„åˆ™å’Œçº¦å®šï¼‰ã€‚å…·ä½“è€Œè¨€ï¼ŒRISCVçš„å‡½æ•°è°ƒç”¨ä¸è¿”å›ä¸»è¦æ¶‰åŠä½¿ç”¨jalä¸jalræŒ‡ä»¤å¯¹raå¯„å­˜å™¨è¿›è¡Œå†™å…¥ä¸è¯»å–ï¼ŒåŒ…æ‹¬ï¼š\nå‡½æ•°è°ƒç”¨ï¼š å°†å½“å‰å‘ç”Ÿå‡½æ•°è°ƒç”¨çš„pcå­˜å‚¨åœ¨raä¸­ï¼Œä¸»è¦åˆ†ä¸ºä¸¤ç§æƒ…å†µï¼š ä½¿ç”¨jalï¼Œåˆ™æŒ‡ä»¤åº”å½“å½¢å¦‚jal ra funcï¼Œå°†å½“å‰pcå­˜å‚¨äºraåï¼Œç›´æ¥è·³è½¬è‡³funcã€‚ ä½¿ç”¨jalrï¼Œåˆ™æŒ‡ä»¤åº”å½“å½¢å¦‚jalr ra imm(rs1)ï¼Œå°†å½“å‰pcå­˜å‚¨äºraåï¼Œè·³è½¬è‡³imm(rs1)æŒ‡å‘çš„funcã€‚ å‡½æ•°è¿”å›ï¼š è¯»å–raå­˜å‚¨çš„pcå¹¶è·³è½¬ï¼ŒRISCVæœ‰ä¸“ç”¨çš„ä¼ªæŒ‡ä»¤retç”¨äºå‡½æ•°è¿”å›ï¼Œè¯¥æŒ‡ä»¤å±•å¼€åä¸ºï¼šjalr zero 0(ra)ã€‚ å› æ­¤ï¼Œæˆ‘ä»¬ä»…éœ€åœ¨NEMU ISAçš„jalï¼ŒjalræŒ‡ä»¤å®ç°ä¸­å¢åŠ å¯¹å‡½æ•°è°ƒç”¨ä¸å‡½æ•°è¿”å›çš„åˆ¤æ–­å³å¯ï¼š\n1 2 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); INSTPAT(\u0026#34;??????? ????? ????? ??? ????? 11011 11\u0026#34;, jal , J, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = s-\u0026gt;pc + imm; if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false)); å¯¹åº”åœ°ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ELFæ–‡ä»¶ä¸­çš„å‡½æ•°ç¬¦å·è§£æå®Œæˆåï¼Œå¢åŠ å¯¹åº”çš„å‡½æ•°è°ƒç”¨ä¸è¿”å›çš„æ‰“å°å‡½æ•°ã€‚\nå°¾è°ƒç”¨çš„å¤„ç† å•çº¯åŸºäºä¸Šè¿°é€»è¾‘å®ç°çš„ftraceæ— æ³•å¤„ç†å‡½æ•°çš„å°¾è°ƒç”¨ï¼Œå› ä¸ºå‡½æ•°å‘ç”Ÿå°¾è°ƒç”¨æ—¶ï¼Œä¸ä¼šå°†å½“å‰å‘ç”Ÿè°ƒç”¨çš„pcå­˜å‚¨åœ¨raä¸­ï¼Œåªä¼šä½¿ç”¨jalr zero 0(rs1)ç›´æ¥è·³è½¬è‡³funcã€‚ä¸ºå®ç°å¯¹å°¾è°ƒç”¨çš„è¿½è¸ªï¼Œæˆ‘ä»¬éœ€è¦å¢åŠ ä»¥ä¸‹ä¸‰ç‚¹åŠŸèƒ½ï¼š\nåœ¨NEMU ISAçš„jalræŒ‡ä»¤å®ç°ä¸­å¢åŠ å¯¹å‡½æ•°å°¾è°ƒç”¨çš„åˆ¤æ–­ï¼š 1 INSTPAT(\u0026#34;??????? ????? ????? 000 ????? 11001 11\u0026#34;, jalr , I, R(rd) = s-\u0026gt;snpc; s-\u0026gt;dnpc = (src1 + imm) \u0026amp; (~(word_t)1); if (s-\u0026gt;isa.inst == 0x00008067) print_return(s-\u0026gt;pc); else if (rd == 1) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, false); else if ((rd == 0) \u0026amp;\u0026amp; (imm == 0)) print_call(s-\u0026gt;pc, s-\u0026gt;dnpc, true)); ä¿®æ”¹å‡½æ•°è°ƒç”¨çš„æ‰“å°å‡½æ•°print_call()ï¼Œå¢åŠ å¯¹å°¾è°ƒç”¨çš„è¯†åˆ«åŠŸèƒ½ï¼Œå½“å‘ç”Ÿå°¾è°ƒç”¨æ—¶ï¼Œè¯¥å‡½æ•°ä¼šå­˜å‚¨å°¾è°ƒç”¨å‡½æ•°å¯¹åº”çš„è°ƒç”¨æ·±åº¦ã€PCå€¼è‡³ä¸€ä¸ªå…¨å±€é™æ€ç»“æ„ä½“æ•°ç»„ä¸­ï¼š 1 2 3 4 5 6 7 8 9 10 11 12 13 void print_call(vaddr_t pc, vaddr_t dnpc, bool tail) { int idx = check_func(dnpc); if (idx \u0026lt; 0) return; func_depth++; flog_write(FMT_PADDR \u0026#34;: %*scall [%s@\u0026#34; FMT_PADDR \u0026#34;]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name, dnpc); if (tail) { tail_hdr[tail_nr].pc = pc; tail_hdr[tail_nr++].depth = func_depth - 1; } } ä¿®æ”¹å‡½æ•°è¿”å›çš„æ‰“å°å‡½æ•°print_return()ï¼Œå¢åŠ å¯¹å°¾è°ƒç”¨çš„å¤„ç†ï¼Œå½“è°ƒç”¨è¯¥å‡½æ•°æ—¶ï¼Œè¯¥å‡½æ•°ä¼šåœ¨å­˜å‚¨å°¾è°ƒç”¨å‡½æ•°çš„ç»“æ„ä½“æ•°ç»„ä¸­æŸ¥æ‰¾å½“å‰æ˜¯å¦å­˜åœ¨å°¾è°ƒç”¨å‡½æ•°ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™ä¸€å¹¶è¾“å‡ºå‡½æ•°è¿”å›ä¿¡æ¯ã€‚ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void print_return(vaddr_t pc) { int idx = check_func(pc); if (idx \u0026lt; 0) return; flog_write(FMT_PADDR \u0026#34;: %*sret [%s]\\n\u0026#34;, pc, (func_depth - 1) * 2, \u0026#34;\u0026#34;, func_hdr[idx].name); func_depth--; // tail call handler (recursion) if (tail_nr \u0026gt; 0) { if (tail_hdr[tail_nr-1].depth == func_depth) { tail_nr--; print_return(tail_hdr[tail_nr].pc); } } } æ³¨æ„print_return()å‡½æ•°ä¸­å¯¹å°¾è°ƒç”¨å‡½æ•°çš„æŸ¥æ‰¾æ˜¯é€’å½’çš„ï¼Œå› ä¸ºå¯èƒ½å­˜åœ¨è¿ç»­åµŒå¥—çš„å°¾è°ƒç”¨ã€‚ ","date":"2025-08-23T00:00:00Z","image":"https://posvirus.github.io/p/ftrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/ftrace/","title":"ftraceå®ç°çš„æ³¨æ„äº‹é¡¹"},{"content":"mtraceæœ¬èº«å®ç°éå¸¸ç®€å•ï¼Œæ­¤å¤„ä»…åˆ—ä¸¾åœ¨å®ç°è¿‡ç¨‹ä¸­é‡åˆ°çš„è‹¥å¹²ç»†èŠ‚ï¼š\nmtraceå†™å…¥NEMU Logæ–‡ä»¶ å¯¹äºmtraceè¿™ç§å¤§è§„æ¨¡è¾“å‡ºï¼Œæˆ‘ä»¬ä¸èƒ½ä»…é€šè¿‡printf()å‡½æ•°å°†å…¶æ‰“å°åœ¨ç»ˆç«¯ä¸Šï¼Œè€Œè¦å°†å…¶å†™å…¥NEMUçš„Logæ–‡ä»¶ä¸­ï¼ŒNEMUæä¾›äº†ä¸€ä¸ªlog_write()å‡½æ•°ç”¨äºå®ç°è¿™ä¸€ç‚¹ï¼Œå®ƒå¯å°†æŒ‡å®šå­—ç¬¦ä¸²å†™å…¥NEMUçš„Logæ–‡ä»¶nemu-log.txtã€‚\nè¿™æ—¶æˆ‘äº§ç”Ÿäº†ä¸€ä¸ªç–‘é—®ï¼Œåœ¨log_write()å‡½æ•°ä¸­å¹¶æ²¡æœ‰æŒ‡å®šå†™å…¥æ–‡ä»¶çš„å‚æ•°ï¼ŒNEMUæ˜¯å¦‚ä½•é€šè¿‡è¯¥å‡½æ•°å†™å…¥æŒ‡å®šçš„Logæ–‡ä»¶å‘¢ï¼Ÿäºæ˜¯ï¼Œæˆ‘è‡ªç„¶éœ€è¦å»æŸ¥çœ‹log_write()çš„å®šä¹‰ï¼Œåœ¨utils.hä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 #define log_write(...) IFDEF(CONFIG_TARGET_NATIVE_ELF, \\ do { \\ extern FILE* log_fp; \\ extern bool log_enable(); \\ if (log_enable() \u0026amp;\u0026amp; log_fp != NULL) { \\ fprintf(log_fp, __VA_ARGS__); \\ fflush(log_fp); \\ } \\ } while (0) \\ ) æ®æ­¤å¯è§ï¼Œlog_write()å‡½æ•°åªæ˜¯ä¸€æ®µå®å®šä¹‰ï¼Œè¿™é‡Œçš„æ–‡ä»¶é€šè¿‡log_fpæŒ‡å®šï¼Œè€Œlog_fpå—åˆ°externå…³é”®å­—ä¿®é¥°ï¼Œè¿™è¯´æ˜å®ƒçš„å®šä¹‰æ¥è‡ªå…¶ä»–çš„æ–‡ä»¶ï¼Œæˆ‘ä»¬ç»§ç»­æœç´¢log_fpçš„å®šä¹‰ï¼Œåœ¨log.cä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 FILE *log_fp = NULL; void init_log(const char *log_file) { log_fp = stdout; if (log_file != NULL) { FILE *fp = fopen(log_file, \u0026#34;w\u0026#34;); Assert(fp, \u0026#34;Can not open \u0026#39;%s\u0026#39;\u0026#34;, log_file); log_fp = fp; } Log(\u0026#34;Log is written to %s\u0026#34;, log_file ? log_file : \u0026#34;stdout\u0026#34;); } æ®æ­¤å¯çŸ¥ï¼Œlog_fpæ˜¯é€šè¿‡init_log()å‡½æ•°èµ‹å€¼çš„ï¼Œå½“é€šè¿‡init_log()æŒ‡å®šNEMUçš„Logæ–‡ä»¶log_fileï¼Œlog_fpä¾¿ä¼šè¢«èµ‹å€¼ä¸ºæŒ‡å‘è¯¥æ–‡ä»¶çš„æŒ‡é’ˆï¼Œè€Œinit_log()å‡½æ•°åœ¨monitor.cä¸­è¢«è°ƒç”¨ï¼ŒNEMUçš„Logæ–‡ä»¶æ˜¯é€šè¿‡å‘½ä»¤è¡Œå‚æ•°-læŒ‡å®šçš„ã€‚\nmtraceçš„é…ç½®é¡¹ æˆ‘ä»¬ä»¿ç…§itraceçš„é…ç½®é¡¹ï¼Œç»™å‡ºäº†mtraceçš„åŸºæœ¬é…ç½®é¡¹ï¼š\n1 2 3 4 5 6 7 8 9 config MTRACE depends on TRACE \u0026amp;\u0026amp; TARGET_NATIVE_ELF \u0026amp;\u0026amp; ENGINE_INTERPRETER bool \u0026#34;Enable memory tracer\u0026#34; default y config MTRACE_COND depends on MTRACE string \u0026#34;Only trace memory when the condition is true\u0026#34; default \u0026#34;true\u0026#34; æœ‰å…³Kconfigçš„ç›¸å…³è¯­æ³•ï¼Œå¯å‚è€ƒï¼šKconfig è¯­æ³•åˆ†æè¯¦è§£ã€‚\né…ç½®å®Œæˆåï¼Œåœ¨å¯åŠ¨mtraceè®°å½•è®¿å­˜è¡Œä¸ºæ—¶ï¼Œæˆ‘å‘ç°ä¸€ä¸ªå¥‡æ€ªçš„ç°è±¡ï¼Œä¼¼ä¹ä¾æ®Logæ–‡ä»¶çš„è¾“å‡ºï¼Œæ¯æ¡æŒ‡ä»¤éƒ½åœ¨è®¿å­˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 [MTRACE-R]: [0x80000da4] --\u0026gt; 0x032 0x80000da4: 40 f7 07 b3 sub\ta5, a4, a5 [MTRACE-R]: [0x80000da8] --\u0026gt; 0x032 0x80000da8: 01 87 97 93 slli\ta5, a5, 0x18 [MTRACE-R]: [0x80000dac] --\u0026gt; 0x032 0x80000dac: 41 87 d7 93 srai\ta5, a5, 0x18 [MTRACE-R]: [0x80000db0] --\u0026gt; 0x032 0x80000db0: fe 07 80 e3 beqz\ta5, -0x20 [MTRACE-R]: [0x80000d90] --\u0026gt; 0x032 0x80000d90: 00 15 05 13 addi\ta0, a0, 1 [MTRACE-R]: [0x80000d94] --\u0026gt; 0x032 0x80000d94: 02 07 04 63 beqz\ta4, 0x28 [MTRACE-R]: [0x80000d98] --\u0026gt; 0x032 [MTRACE-R]: [0x800010a1] --\u0026gt; 0x008 0x80000d98: 00 05 c7 83 lbu\ta5, 0(a1) [MTRACE-R]: [0x80000d9c] --\u0026gt; 0x032 [MTRACE-R]: [0x80009fc1] --\u0026gt; 0x008 0x80000d9c: 00 05 47 03 lbu\ta4, 0(a0) [MTRACE-R]: [0x80000da0] --\u0026gt; 0x032 0x80000da0: 00 15 85 93 addi\ta1, a1, 1 ä¸€å¼€å§‹æˆ‘ä»¥ä¸ºæ˜¯mtraceåŠŸèƒ½ä¸Šæœ‰bugï¼Œåæ¥æ‰æç„¶å¤§æ‚Ÿï¼Œå› ä¸ºæ¯æ¡æŒ‡ä»¤çš„å–æŒ‡éƒ½å¤©ç„¶å­˜åœ¨ä¸€æ¬¡è®¿å­˜è¡Œä¸ºï¼ä½†æ˜¯ï¼Œå¦‚è®²ä¹‰ä¸­æ‰€è¯´ï¼Œæœ‰æ—¶æˆ‘å¯èƒ½åªä¼šå…³å¿ƒæŸä¸€æ®µå†…å­˜åŒºé—´çš„è®¿é—®ï¼Œä»è€Œå¸Œæœ›mtraceå‡å°‘è¾“å‡ºã€‚å› æ­¤ï¼Œæˆ‘åˆåœ¨Kconfigä¸­å¢åŠ äº†å¦‚ä¸‹é…ç½®é¡¹ï¼š\n1 2 3 4 5 6 7 8 9 config MTRACE_MIN depends on MTRACE hex \u0026#34;Lower bound for memory tracing (unit: number of bytes)\u0026#34; default 0x00000000 config MTRACE_MAX depends on MTRACE hex \u0026#34;Upper bound for memory tracing (unit: number of bytes)\u0026#34; default 0xffffffff è¿™ä¸¤ä¸ªé…ç½®é¡¹é™åˆ¶äº†mtraceçš„è¿½è¸ªå†…å­˜åŒºé—´ï¼Œå…¶å–å€¼é‡‡ç”¨hexç±»å‹ï¼Œå› ä¸ºæˆ‘ä»¬é€šå¸¸ä¹ æƒ¯é€šè¿‡åå…­è¿›åˆ¶è¡¨ç¤ºå†…å­˜åœ°å€ã€‚\n","date":"2025-08-07T00:00:00Z","image":"https://posvirus.github.io/p/mtrace/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/mtrace/","title":"mtraceå®ç°çš„æ³¨æ„äº‹é¡¹"},{"content":"æŒ‡ä»¤ç¯å½¢ç¼“å†²å™¨ï¼ˆInstruction Ring Buffer, ä¸‹æ–‡ç®€ç§°IRBï¼‰çš„å®ç°åŸºäºä¸€ä¸ªç®€åŒ–çš„ç¯å½¢ç¼“å†²å™¨ç»“æ„ï¼Œå…·ä½“è€Œè¨€ï¼Œå…¶å¯åŸºäºä¸€ä¸ªä»…å…·æœ‰å¾ªç¯ï¼ˆè¦†ç›–ï¼‰å†™å…¥çš„é˜Ÿåˆ—å®ç°ï¼Œä¸”é˜Ÿåˆ—å•æ¬¡å†™å…¥çš„æ•°æ®é‡å‡ä¸º1ï¼ˆå³å•ä¸ªæŒ‡ä»¤å¯¹åº”çš„åæ±‡ç¼–è¾“å‡ºï¼‰ã€‚åŸºäºä¸Šè¿°åˆ†æï¼Œæˆ‘ä»¬å¯å®šä¹‰å¦‚ä¸‹çš„IRBï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 #define NR_RB 16 // instruction register typedef struct ireg { char logbuf[128]; int valid; } IReg; // instruction ring buffer typedef struct iringbuffer { IReg i_buf[NR_RB]; int end; } IRingBuffer; ä¸Šè¿°ä»£ç ä¸­ï¼Œä¸€ä¸ªå›ºå®šå®¹é‡ä¸º16çš„IRBç”±iringbufferç»“æ„ä½“å®šä¹‰ï¼Œå…¶ä¸­åŒ…å«å­˜å‚¨æŒ‡ä»¤åæ±‡ç¼–è¾“å‡ºçš„ç»“æ„ä½“æ•°ç»„i_bufï¼Œä»¥åŠç”¨äºå­˜å‚¨å½“å‰å†™å…¥çš„æ•°ç»„å…ƒç´ ç´¢å¼•endï¼Œå¯¹äºå­˜å‚¨æŒ‡ä»¤åæ±‡ç¼–è¾“å‡ºçš„ç»“æ„ä½“iregï¼Œå…¶åŒ…å«å®šé•¿å­—ç¬¦æ•°ç»„logbufä¸æ ‡è®°å­˜å‚¨å†…å®¹æœ‰æ•ˆçš„æŒ‡ç¤ºä½validã€‚\nä»¥ä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨å®ç°ç›‘è§†ç‚¹çš„ç±»ä¼¼æ–¹æ³•ï¼Œç›´æ¥ä¾‹åŒ–ä¸€ä¸ªå…¨å±€é™æ€çš„IRBï¼Œä½¿NEMUå¯é€šè¿‡æˆ‘ä»¬æä¾›çš„æ¥å£å¯¹IRBè¿›è¡Œæ“ä½œï¼š\n1 static IRingBuffer iring_buf; å¯¹IRBçš„æ“ä½œå¯åˆ†ä¸ºä¸‰ç§ï¼šå¯¹IRBçš„åˆå§‹åŒ–ã€å¯¹IRBçš„å•æ¬¡å†™å…¥ä¸IRBçš„å†…å®¹è¾“å‡ºã€‚ä¸ºæ­¤ï¼Œæˆ‘ä»¬å®šä¹‰äº†å¦‚ä¸‹ä¸‰ç§æ–¹æ³•ï¼š\n1 2 3 4 5 6 7 8 // initialize instruction ring buffer void IRingBuffer_init(); // write one log into instruction ring buffer int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst); // print contents of instruction ring buffer void IRingBuffer_print(); IRingBuffer_init()å‡½æ•°å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 void IRingBuffer_init() { for (int i = 0; i \u0026lt; NR_RB; i++) { iring_buf.i_buf[i].valid = 0; } iring_buf.end = 0; Log(\u0026#34;Instruction ring buffer initialization success. Buffer storage: %d insts.\u0026#34;, NR_RB); }; IRBçš„åˆå§‹åŒ–è¾ƒä¸ºç®€å•ï¼Œæˆ‘ä»¬ä»…éœ€å°†i_bufæ‰€æœ‰å…ƒç´ çš„æŒ‡ç¤ºä½ç½®é›¶ï¼Œå¹¶å°†ç´¢å¼•endæŒ‡å‘æ•°ç»„é¦–ä¸ªå…ƒç´ å³å¯ã€‚åŒæ—¶ï¼ŒIRBçš„åˆå§‹åŒ–å¯åœ¨NEMU monitorçš„åˆå§‹åŒ–å‡½æ•°init_monitor()ä¸­å®ç°ï¼š\n1 2 /* Initialize the instruction ring buffer. */ IFDEF(CONFIG_ITRACE, IRingBuffer_init()); IRingBuffer_write()å‡½æ•°çš„å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 int IRingBuffer_write(vaddr_t pc, vaddr_t snpc, uint8_t *inst) { // check illegal inst input if (inst == NULL) return -1; char *p = iring_buf.i_buf[iring_buf.end].logbuf; p += snprintf(p, sizeof(iring_buf.i_buf[iring_buf.end].logbuf), FMT_WORD \u0026#34;:\u0026#34;, pc); int i; int ilen = snpc - pc; #ifdef CONFIG_ISA_x86 for (i = 0; i \u0026lt; ilen; i++) { #else for (i = ilen - 1; i \u0026gt;= 0; i--) { #endif p += snprintf(p, 4, \u0026#34; %02x\u0026#34;, inst[i]); } int ilen_max = MUXDEF(CONFIG_ISA_x86, 8, 4); int space_len = ilen_max - ilen; if (space_len \u0026lt; 0) space_len = 0; space_len = space_len * 3 + 1; memset(p, \u0026#39; \u0026#39;, space_len); p += space_len; void disassemble(char *str, int size, uint64_t pc, uint8_t *code, int nbyte); disassemble(p, iring_buf.i_buf[iring_buf.end].logbuf + sizeof(iring_buf.i_buf[iring_buf.end].logbuf) - p, MUXDEF(CONFIG_ISA_x86, snpc, pc), inst, ilen); iring_buf.i_buf[iring_buf.end].valid = 1; // end pointer increment iring_buf.end = (iring_buf.end + 1) % NR_RB; return 0; }; è¯¥å‡½æ•°æ¥æ”¶å½“å‰å–å€¼çš„PCå€¼pcã€ä¸‹ä¸€é™æ€PCå€¼snpcä¸å½“å‰å–å‡ºçš„æŒ‡ä»¤instï¼Œå¹¶é€šè¿‡exec_once()å‡½æ•°ä¸­ç›¸åŒçš„è§£ç æ–¹å¼å°†å…¶è½¬æ¢ä¸ºåæ±‡ç¼–è¾“å‡ºå­˜å‚¨è‡³i_bufä¸­ï¼Œå¹¶å°†å¯¹åº”æŒ‡ç¤ºä½ç½®ä½ã€‚éšåï¼Œå°†æ•°ç»„ç´¢å¼•é€’å¢ï¼Œæ­¤å¤„é€šè¿‡æ¨¡è¿ç®—ä½¿æ•°ç»„ç´¢å¼•ä¸å‘ç”Ÿè¶Šç•Œï¼Œå¹¶å®ç°è¦†ç›–å†™å…¥çš„åŠŸèƒ½ã€‚\næˆ‘ä»¬å¯åœ¨isa_exec_once()å‡½æ•°ä¸­è°ƒç”¨è¯¥å‡½æ•°ï¼Œè¯¥å‡½æ•°åº”å½“åœ¨æŒ‡ä»¤å–æŒ‡åç«‹åˆ»è¢«è°ƒç”¨ï¼Œå› ä¸ºå¦‚æœå½“å‰æŒ‡ä»¤æ‰§è¡Œå‡ºé”™ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦åœ¨NEMUå¼‚å¸¸é€€å‡ºå‰å­˜å‚¨å½“å‰æŒ‡ä»¤çš„åæ±‡ç¼–è¾“å‡ºï¼š\n1 2 3 4 5 6 7 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); #ifdef CONFIG_ITRACE IRingBuffer_write(s-\u0026gt;pc, s-\u0026gt;snpc, (uint8_t *)\u0026amp;s-\u0026gt;isa.inst); #endif return decode_exec(s); } IRingBuffer_print()å‡½æ•°çš„å®ç°å¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 void IRingBuffer_print() { for (int i = 0; i \u0026lt; NR_RB; i++) { if (iring_buf.i_buf[i].valid == 1) { if (((i + 1) % NR_RB) == iring_buf.end) { printf(\u0026#34; --\u0026gt; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } else { printf(\u0026#34; %s\\n\u0026#34;, iring_buf.i_buf[i].logbuf); } } } }; æ­¤å¤„ï¼Œæˆ‘ä»¬åˆ†ä¸¤ç§æƒ…å†µæ‰“å°i_bufä¸­çš„åæ±‡ç¼–è¾“å‡ºï¼Œå½“((i + 1) % NR_RB) == iring_buf.endä¸ºçœŸæ—¶ï¼Œä»£è¡¨å½“å‰æŒ‡ä»¤ä¸ºç¨‹åºå‘ç”Ÿå¼‚å¸¸æ—¶æ‰§è¡Œçš„æŒ‡ä»¤ï¼ˆå› ä¸ºåœ¨å†™å…¥åæ±‡ç¼–è¾“å‡ºåä¼šå¯¹ç´¢å¼•é€’å¢ï¼Œæ•…æ­¤å¤„ä½¿ç”¨i+1ï¼‰ï¼Œä½¿ç”¨--\u0026gt;æ ‡è¯†è¯¥æŒ‡ä»¤ï¼Œå…¶ä½™æŒ‡ä»¤å‡æ­£å¸¸æ‰“å°å³å¯ã€‚\nè¯¥å‡½æ•°å¯æ’å…¥NEMUå¼‚å¸¸ç»ˆæ­¢çš„æ‰€æœ‰ç¨‹åºæ®µä¸­ï¼Œç›®å‰ä»…æ’å…¥assert_fail_msg()å‡½æ•°ä¸­ï¼Œåç»­å¯é€šè¿‡æ›´å¤šæµ‹è¯•ç»§ç»­å®Œå–„ã€‚\n","date":"2025-08-04T00:00:00Z","image":"https://posvirus.github.io/p/iringbuf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/iringbuf/","title":"æŒ‡ä»¤ç¯å½¢ç¼“å†²å™¨å®ç°"},{"content":"åœ¨PA2ä¸­ï¼Œç¬”è€…è¢«è¦æ±‚å®ç°ä¸€ä¸ªç®€å•çš„sprintf()å‡½æ•°ï¼Œå…¶ç›®å‰ä»…éœ€å®ç°å¯¹%sä¸%dæ ‡è¯†ç¬¦çš„æ”¯æŒå³å¯ã€‚æ­¤å¤„ï¼Œç¬”è€…å¯¹å…¶è¿›è¡Œäº†è¿›ä¸€æ­¥å¢å¼ºï¼Œä½¿å…¶å¯æ”¯æŒæ›´å¤šç§æ ‡è¯†ç¬¦ï¼Œå¹¶å…·æœ‰æ‰©å±•å®ç°æ›´å¤šæ ‡è¯†ç¬¦çš„èƒ½åŠ›ï¼Œå…¶ç›®å‰å¯æ”¯æŒçš„æ ‡è¯†ç¬¦åˆ—ä¸¾å¦‚ä¸‹ï¼š\næ ‡è¯†ç¬¦ å«ä¹‰ %d ä½å®½ä¸é™çš„åè¿›åˆ¶æœ‰ç¬¦å·æ•° %u ä½å®½ä¸é™çš„åè¿›åˆ¶æ— ç¬¦å·æ•° %o ä½å®½ä¸é™çš„å…«è¿›åˆ¶æ— ç¬¦å·æ•° %x ä½å®½ä¸é™çš„åå…­è¿›åˆ¶æ— ç¬¦å·æ•°ï¼ˆå­—æ¯å°å†™ï¼‰ %X ä½å®½ä¸é™çš„åå…­è¿›åˆ¶æ— ç¬¦å·æ•°ï¼ˆå­—æ¯å°å†™ï¼‰ %lu ä½å®½ä¸é™çš„æ— ç¬¦å·æ•´å‹ %llu ä½å®½ä¸é™çš„æ— ç¬¦å·é•¿æ•´å‹ %s å­—ç¬¦ä¸² %c å•ä¸ªå­—ç¬¦ %p æŒ‡é’ˆåœ°å€ %% å­—ç¬¦% æ­¤å¤„ï¼Œä¸ºä¿è¯sprintf()å‡½æ•°å…·æœ‰è¯†åˆ«æ›´å¤šæ ‡è¯†ç¬¦çš„æ‰©å±•æ€§ï¼Œåœ¨ç¼–å†™sprint()å‡½æ•°æ—¶é‡‡ç”¨äº†æ¨¡å—åŒ–è®¾è®¡ï¼Œå…¶è®¾è®¡åŸç†ç±»ä¼¼äºNEMUè¡¨è¾¾å¼æ±‚å€¼ä¸­å¯¹è¡¨è¾¾å¼ä¸­tokençš„æå–ï¼Œä»¥ä¸‹æ˜¯å…·ä½“å®ç°ï¼š\nsprintf()å‡½æ•°åˆ†ä¸‰ä¸ªé˜¶æ®µï¼Œç¬¬ä¸€é˜¶æ®µæ˜¯å¯¹å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²çš„è§£æï¼Œç¬¬äºŒé˜¶æ®µæ˜¯å¯¹æ ‡è¯†ç¬¦å¯¹åº”å‚æ•°çš„è½¬æ¢ï¼Œç¬¬ä¸‰é˜¶æ®µåˆ™æ˜¯ç›®æ ‡å­—ç¬¦ä¸²çš„ç”Ÿæˆã€‚\n1 2 3 4 5 6 7 8 9 10 11 12 /* sprintf arguments */ enum { SP_CHAR, SP_UDEC, SP_UUSG, SP_UOCT, SP_Uhex, SP_UHEX, SP_ULOU, SP_ULLU, SP_USTR, SP_USCH, SP_UPTR, }; /* sprintf tokens */ typedef struct sp_token { int type; char str[256]; } SP_Token; åœ¨ç¬¬ä¸€é˜¶æ®µï¼Œæˆ‘ä»¬é¦–å…ˆå®šä¹‰äº†è‹¥å¹²æšä¸¾å˜é‡ï¼Œç”¨äºä»£è¡¨å„ç§æ ‡è¯†ç¬¦ç±»å‹ï¼ˆä»¥åŠæ™®é€šå•å­—ç¬¦ï¼‰ï¼Œå…¶æ¬¡ï¼Œæˆ‘ä»¬å®šä¹‰ç»“æ„ä½“SP_Tokenï¼Œè¯¥ç»“æ„ä½“ç”¨äºå­˜å‚¨å¯¹å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²çš„è§£æç»“æœï¼Œæ¯ä¸ªç»“æ„ä½“ä»£è¡¨ä»å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²è§£æå‡ºçš„ä¸€ä¸ªtokenï¼ŒåŒ…å«è¯¥tokençš„ç±»å‹typeï¼ˆå±äºæšä¸¾å˜é‡ä¸­çš„ä¸€è€…ï¼‰ä¸tokenå¯¹åº”è½¬æ¢åçš„å­—ç¬¦ä¸²strã€‚\n1 2 static SP_Token sp_tokens[SP_NR_MAX] __attribute__((used)) = {}; static int nr_sp_token __attribute__((used)) = 0; åŒæ—¶ï¼Œæˆ‘ä»¬åœ¨stdio.cä¸­å®šä¹‰å…¨å±€é™æ€SP_Tokenæ•°ç»„sp_tokensï¼Œç”¨äºå­˜å‚¨æ¯æ¬¡å¯¹å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²çš„è§£æç»“æœï¼ŒåŒæ—¶å®šä¹‰nr_sp_tokenæŒ‡ç¤ºå½“å‰è§£æç»“æœçš„tokenæ•°é‡ã€‚\nä»¥ä¸‹ï¼Œæˆ‘ä»¬å®šä¹‰é™æ€å‡½æ•°sp_make_token()å®Œæˆå¯¹å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²çš„è§£æï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 static bool sp_make_token(const char *fmt) { int position = 0; nr_sp_token = 0; while (fmt[position] != \u0026#39;\\0\u0026#39;) { /* Try all types one by one */ if (fmt[position] != \u0026#39;%\u0026#39;) { // basic char sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } else { position = position + 1; // %d, unlimited length decimal if (fmt[position] == \u0026#39;d\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UDEC; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %u, unlimited length unsign if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UUSG; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %o, unlimited length octal if (fmt[position] == \u0026#39;o\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UOCT; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %x, unlimited length hexadecimal (lower) if (fmt[position] == \u0026#39;x\u0026#39;) { sp_tokens[nr_sp_token].type = SP_Uhex; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %X, unlimited length hexadecimal (upper) if (fmt[position] == \u0026#39;X\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UHEX; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if(fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %lu, unlimited length uint32_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULOU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } if (fmt[position] == \u0026#39;l\u0026#39;) { position = position + 1; // %llu, unlimited length uint64_t if (fmt[position] == \u0026#39;u\u0026#39;) { sp_tokens[nr_sp_token].type = SP_ULLU; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } return false; } // %s, unlimited length string if (fmt[position] == \u0026#39;s\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %c, single char if (fmt[position] == \u0026#39;c\u0026#39;) { sp_tokens[nr_sp_token].type = SP_USCH; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %p, value of a pointer if (fmt[position] == \u0026#39;p\u0026#39;) { sp_tokens[nr_sp_token].type = SP_UPTR; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } // %%, char \u0026#39;%\u0026#39; if (fmt[position] == \u0026#39;%\u0026#39;) { sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; nr_sp_token = nr_sp_token + 1; position = position + 1; continue; } return false; } } // EOL token (to make sure) sp_tokens[nr_sp_token].type = SP_CHAR; sp_tokens[nr_sp_token].str[0] = fmt[position]; sp_tokens[nr_sp_token].str[1] = \u0026#39;\\0\u0026#39;; return true; } æ­¤å¤„çš„è§£æé€»è¾‘ä¸è¡¨è¾¾å¼æ±‚å€¼ä¸­çš„tokenè§£æé€»è¾‘ç±»ä¼¼ï¼Œåªæ˜¯æ­¤å¤„æˆ‘ä»¬å®ç°çš„æ˜¯åŸºæœ¬çš„åº“å‡½æ•°ï¼Œå› æ­¤æ— æ³•ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è¿›è¡Œå¿«é€ŸåŒ¹é…ï¼Œéœ€è¦é€å­—ç¬¦è¿›è¡Œåˆ¤æ–­ã€‚åœ¨è¯¥å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬ä¼šå°†å«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²é¡ºåºè½¬æ¢ä¸ºtokenæ•°ç»„ï¼ŒåŒæ—¶æŒ‡æ˜å„tokenç±»å‹typeã€‚å¯¹æ™®é€šå­—ç¬¦ï¼Œæˆ‘ä»¬åœ¨è¯¥å‡½æ•°ä¸­è¿˜ä¼šæŒ‡æ˜å…¶tokenåœ¨æ ‡è¯†ç¬¦è½¬æ¢åçš„å­—ç¬¦ä¸²strï¼ˆå› å…¶æ— éœ€è½¬æ¢ï¼Œä½†æ˜¯éœ€è¦åœ¨æ™®é€šå­—ç¬¦åè¿½åŠ '\\0'ï¼‰ã€‚\nå®Œæˆtokenè§£æé€»è¾‘åï¼Œæˆ‘ä»¬å¯åœ¨sprintf()å‡½æ•°ä¸­è°ƒç”¨è¯¥å‡½æ•°ï¼Œå¹¶è¿›è¡Œç¬¬äºŒã€ä¸‰é˜¶æ®µçš„å®ç°ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 int sprintf(char *out, const char *fmt, ...) { // detect invalid behavior if (!sp_make_token(fmt)) { return -1; } // va-args initialization va_list args; va_start(args, fmt); // args-to-string convert for (int i = 0; i \u0026lt; nr_sp_token; i++) { switch (sp_tokens[i].type) { case SP_CHAR: // directly skip break; case SP_UDEC: // str-to-dec convert str2sig(va_arg(args, int), sp_tokens[i].str, 10, false); break; case SP_UUSG: // str-to-unsign convert str2u(va_arg(args, unsigned int), sp_tokens[i].str); break; case SP_UOCT: // str-to-oct convert str2sig(va_arg(args, int), sp_tokens[i].str, 8, false); break; case SP_Uhex: // str-to-hex convert (lower) str2sig(va_arg(args, int), sp_tokens[i].str, 16, false); break; case SP_UHEX: // str-to-hex convert (upper) str2sig(va_arg(args, int), sp_tokens[i].str, 16, true); break; case SP_ULOU: // str-to-long-unsign convert str2lu(va_arg(args, size_t), sp_tokens[i].str); break; case SP_ULLU: // str-to-long-long-unsign convert str2llu(va_arg(args, unsigned long long), sp_tokens[i].str); break; case SP_USTR: // str copy strcpy(sp_tokens[i].str, va_arg(args, char *)); break; case SP_USCH: // char copy sp_tokens[i].str[0] = (char) va_arg(args, int); sp_tokens[i].str[1] = \u0026#39;\\0\u0026#39;; break; case SP_UPTR: // pointer value str2ptr(va_arg(args, void *), sp_tokens[i].str); break; default: // do nothing break; } } // end of args extraction va_end(args); // str-cat to result str strcpy(out, sp_tokens[0].str); for (int i = 1; i \u0026lt; nr_sp_token; i++) { strcat(out, sp_tokens[i].str); } return strlen(out); } é¦–å…ˆï¼Œæˆ‘ä»¬ä¼šè¿›è¡Œå«æ ‡è¯†ç¬¦å­—ç¬¦ä¸²çš„è§£æï¼Œå¹¶åˆ¤æ–­è§£æç»“æœæ˜¯å¦æˆåŠŸï¼Œè‹¥ä¸æˆåŠŸï¼Œåˆ™è¿”å›ä¸€ä¸ªè´Ÿå€¼ï¼ˆsprintf()å‡½æ•°çš„é€»è¾‘æ˜¯ï¼Œå½“å‡½æ•°æ‰§è¡ŒæˆåŠŸï¼Œä¼šè¿”å›æ‰“å°å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œåä¹‹ä¼šè¿”å›ä¸€ä¸ªè´Ÿå€¼ï¼‰ã€‚\nå…¶æ¬¡ï¼Œæˆ‘ä»¬ä½¿ç”¨stdarg.håº“ä¸­çš„ç›¸å…³å‡½æ•°ï¼Œé€ä¸ªè§£ææ ‡è¯†ç¬¦å¯¹åº”çš„å‚æ•°å¹¶è½¬æ¢æˆå­—ç¬¦ä¸²ï¼Œèµ‹å€¼ç»™å¯¹åº”tokençš„strå˜é‡ã€‚æ­¤å¤„éœ€è¦å®ç°å¤šä¸ªæ•°æ®ç±»å‹å‘å­—ç¬¦ä¸²è½¬æ¢çš„å‡½æ•°ï¼Œç”±äºç¬”è€…å¹¶ä¸å¸Œæœ›å®ç°æ ‡å‡†åº“ä¸­åŠŸèƒ½è¾ƒå¤æ‚çš„è½¬æ¢å‡½æ•°ï¼Œå› æ­¤æ­¤å¤„çš„å‡½æ•°å‡è‡ªç”±å‘½åï¼Œå¹¶è¢«å£°æ˜ä¸ºé™æ€å‡½æ•°é˜²æ­¢å¤–éƒ¨è°ƒç”¨ã€‚\næˆ‘ä»¬å¯ä»¥ç®€å•ä»¥æŒ‡é’ˆå‘å­—ç¬¦ä¸²çš„è½¬æ¢å‡½æ•°ä¸ºä¾‹è¿›è¡Œè¯´æ˜ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 static char *str2ptr(void *num, char *re) { // avoid illegal input assert(re != NULL); char *pre = re; char num_buf[32] = {0}; // number buffer (fixed width) int ptr = 0; size_t unum = (size_t) num; size_t udiv; // NULL pointer if (num == NULL) { *pre = \u0026#39;(\u0026#39;; pre++; *pre = \u0026#39;n\u0026#39;; pre++; *pre = \u0026#39;i\u0026#39;; pre++; *pre = \u0026#39;l\u0026#39;; pre++; *pre = \u0026#39;)\u0026#39;; return re; } if (unum == 0) { re[0] = \u0026#39;0\u0026#39;; re[1] = \u0026#39;x\u0026#39;; re[2] = \u0026#39;0\u0026#39;; re[3] = \u0026#39;\\0\u0026#39;; return re; } *pre = \u0026#39;0\u0026#39;; pre++; *pre = \u0026#39;x\u0026#39;; pre++; // loop for conversion while (unum \u0026gt; 0) { udiv = unum % 16; if (udiv \u0026lt; 10) { num_buf[ptr++] = udiv + \u0026#39;0\u0026#39;; } else { num_buf[ptr++] = udiv - 10 + \u0026#39;a\u0026#39;; } unum = unum / 16; } // number order inversion for (int i = 0; i \u0026lt; ptr; i++) { *pre = num_buf[ptr-i-1]; pre++; } // add EOL *pre = \u0026#39;\\0\u0026#39;; return re; } è¯¥å‡½æ•°æ¥æ”¶æŒ‡é’ˆnumï¼Œå¹¶å°†å­—ç¬¦ä¸²è½¬æ¢ç»“æœèµ‹å€¼ç»™reï¼Œä¸ºæ­¤ï¼Œé¦–å…ˆæˆ‘ä»¬éœ€è¦åˆ¤æ–­æŒ‡é’ˆnumæ˜¯å¦ä¸ºNULLï¼Œå¦‚æ˜¯ï¼Œåˆ™æŒ‰æ ‡å‡†å½¢å¼ç›´æ¥è¿”å›å­—ç¬¦ä¸²(nil)ï¼›å…¶æ¬¡ï¼Œæˆ‘ä»¬å°†æŒ‡é’ˆnumå¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºuint32_tç±»å‹å˜é‡unumï¼ˆå› ä¸ºç›®å‰å®ç°çš„å¤„ç†å™¨æ˜¯32ä½åœ°å€ï¼‰ï¼›æœ€åï¼Œæˆ‘ä»¬ä»…éœ€å°†unumè½¬æ¢ä¸ºå­—ç¬¦ä¸²å³å¯ï¼Œè¿™åœ¨å®ç°ä¸Šæ˜¯ç®€å•çš„ã€‚åŒæ—¶éœ€æ³¨æ„ï¼ŒæŒ‡é’ˆåœ°å€ä¸º0x...çš„å½¢å¼ï¼Œä»¥åå…­è¿›åˆ¶ï¼ˆå°å†™ï¼‰æ‰“å°ï¼Œåœ¨å®ç°æ—¶éœ€è¦é¢å¤–å¢åŠ é€»è¾‘ã€‚\nåœ¨ç¬¬ä¸‰é˜¶æ®µï¼Œæˆ‘ä»¬ä»…éœ€é€šè¿‡å¾ªç¯ï¼Œä½¿ç”¨strcat()å‡½æ•°å°†æ‰€æœ‰çš„tokenå¯¹åº”çš„å­—ç¬¦ä¸²è¿›è¡Œæ‹¼æ¥å³å¯ï¼ˆå½“ç„¶ï¼Œå¯¹ç¬¬ä¸€ä¸ªtokenï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨strcpy()ï¼‰ã€‚\nå¦å¤–ï¼Œæˆ‘ä»¬é¢å¤–ç¼–å†™äº†ç”¨äºæµ‹è¯•sprintf()å‡½æ•°çš„å®¢æˆ·ç¨‹åºï¼Œå…¶åœ¨nativeä¸NEMUä¸‹å‡å¯é€šè¿‡æµ‹è¯•ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #include \u0026#34;trap.h\u0026#34; char buf[128]; int main() { // basic string sprintf(buf, \u0026#34;%s\u0026#34;, \u0026#34;Hello world!\u0026#34;); check(strcmp(buf, \u0026#34;Hello world!\u0026#34;) == 0); // decimal format sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, 12806, 12923); check(strcmp(buf, \u0026#34;117 + 12806 = 12923\u0026#34;) == 0); sprintf(buf, \u0026#34;%d + %d = %d\u0026#34;, 117, -12806, -12689); check(strcmp(buf, \u0026#34;117 + -12806 = -12689\u0026#34;) == 0); sprintf(buf, \u0026#34;0x%x in hex is %d\u0026#34;, 255, 255); check(strcmp(buf, \u0026#34;0xff in hex is 255\u0026#34;) == 0); // unsigned sprintf(buf, \u0026#34;%u\u0026#34;, 4294967295U); check(strcmp(buf, \u0026#34;4294967295\u0026#34;) == 0); // octal sprintf(buf, \u0026#34;Octal: %o\u0026#34;, 63); check(strcmp(buf, \u0026#34;Octal: 77\u0026#34;) == 0); // hexadecimal (case specify) sprintf(buf, \u0026#34;Hex lower: %x\u0026#34;, 255); check(strcmp(buf, \u0026#34;Hex lower: ff\u0026#34;) == 0); sprintf(buf, \u0026#34;Hex upper: %X\u0026#34;, 0xBCDAABCD); check(strcmp(buf, \u0026#34;Hex upper: BCDAABCD\u0026#34;) == 0); // unsigned long sprintf(buf, \u0026#34;Long: %lu\u0026#34;, 123456789UL); check(strcmp(buf, \u0026#34;Long: 123456789\u0026#34;) == 0); // unsigned long long sprintf(buf, \u0026#34;Long long: %llu\u0026#34;, 1234567890123456ULL); check(strcmp(buf, \u0026#34;Long long: 1234567890123456\u0026#34;) == 0); // char sprintf(buf, \u0026#34;Char: %c\u0026#34;, \u0026#39;A\u0026#39;); check(strcmp(buf, \u0026#34;Char: A\u0026#34;) == 0); // pointer volatile int *x = (volatile int *)0x0061fe1c; sprintf(buf, \u0026#34;Pointer: %p\u0026#34;, x); check(strcmp(buf, \u0026#34;Pointer: 0x61fe1c\u0026#34;) == 0); // NULL pointer sprintf(buf, \u0026#34;Null ptr: %p\u0026#34;, NULL); check(strcmp(buf, \u0026#34;Null ptr: (nil)\u0026#34;) == 0); // mixed format sprintf(buf, \u0026#34;Mixed: %d %s %c 0x%x\u0026#34;, 42, \u0026#34;test\u0026#34;, \u0026#39;Z\u0026#39;, 255); check(strcmp(buf, \u0026#34;Mixed: 42 test Z 0xff\u0026#34;) == 0); // boundary value sprintf(buf, \u0026#34;Min int: %d, Max uint: %u\u0026#34;, -2147483647-1, 4294967295U); check(strcmp(buf, \u0026#34;Min int: -2147483648, Max uint: 4294967295\u0026#34;) == 0); // special string sprintf(buf, \u0026#34;Newline: %s\u0026#34;, \u0026#34;a\\nb\u0026#34;); check(strcmp(buf, \u0026#34;Newline: a\\nb\u0026#34;) == 0); // char \u0026#39;%\u0026#39; sprintf(buf, \u0026#34;100%% guaranteed\u0026#34;); check(strcmp(buf, \u0026#34;100% guaranteed\u0026#34;) == 0); return 0; } åœ¨æµ‹è¯•æŒ‡é’ˆçš„ç¨‹åºæ®µä¸­ï¼Œæˆ‘ä»¬å¯¹æŒ‡é’ˆè¿›è¡Œç›´æ¥èµ‹å€¼ï¼Œå¹¶é€šè¿‡volatileå…³é”®å­—é˜²æ­¢ç¼–è¯‘å™¨ä¼˜åŒ–ã€‚\n","date":"2025-07-27T00:00:00Z","image":"https://posvirus.github.io/p/sprintf/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/sprintf/","title":"åŠŸèƒ½æ›´å¼ºå¤§çš„sprintf()å‡½æ•°"},{"content":"é¦–å…ˆï¼Œé€šè¿‡RTFSCï¼Œæˆ‘ä»¬å‘ç°NEMUçš„æ‰¹å¤„ç†æ¨¡å¼æ˜¯é€šè¿‡sdb.cä¸­çš„ä¸€ä¸ªå˜é‡is_batch_modeæ§åˆ¶çš„ï¼š\n1 2 3 4 5 6 7 void sdb_mainloop() { if (is_batch_mode) { cmd_c(NULL); return; } /* other logic */ } åœ¨sdbçš„ä¸»å¾ªç¯ä¸­ï¼Œå½“è¿™ä¸ªå˜é‡ä¸ºtrueæ—¶ï¼Œä¼šç›´æ¥é€šè¿‡è°ƒç”¨cmd_c()æ‰§è¡Œç”¨æˆ·ç¨‹åºå¹¶è¿”å›ï¼Œä¸å†å¯åŠ¨sdbã€‚ä½†æ˜¯è¿™ä¸ªå˜é‡åœ¨å½“å‰æ–‡ä»¶å£°æ˜çš„é»˜è®¤å€¼ä¸ºfalseï¼Œå¦‚ä½•å°†å…¶å˜ä¸ºtrueå‘¢ï¼Ÿæˆ‘ä»¬å¾ˆå¿«åˆä¼šå‘ç°sdb_set_batch_mode()è¿™ä¸ªå‡½æ•°ï¼š\n1 2 3 void sdb_set_batch_mode() { is_batch_mode = true; } ä¸éš¾å‘ç°ï¼Œé€šè¿‡è°ƒç”¨è¿™ä¸ªå‡½æ•°å°±å¯ä»¥è®©NEMUè¿›å…¥æ‰¹å¤„ç†æ¨¡å¼ï¼æ­¤æ—¶æˆ‘ä»¬åªéœ€è¦å¯»æ‰¾NEMUåœ¨ä»€ä¹ˆä½ç½®è°ƒç”¨äº†è¿™ä¸ªå‡½æ•°ï¼Œä¸éš¾å‘ç°å®ƒçš„è°ƒç”¨ä½ç½®åœ¨monitor.cçš„parse_args()å‡½æ•°ä¸­ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 static int parse_args(int argc, char *argv[]) { const struct option table[] = { {\u0026#34;batch\u0026#34; , no_argument , NULL, \u0026#39;b\u0026#39;}, {\u0026#34;log\u0026#34; , required_argument, NULL, \u0026#39;l\u0026#39;}, {\u0026#34;diff\u0026#34; , required_argument, NULL, \u0026#39;d\u0026#39;}, {\u0026#34;port\u0026#34; , required_argument, NULL, \u0026#39;p\u0026#39;}, {\u0026#34;help\u0026#34; , no_argument , NULL, \u0026#39;h\u0026#39;}, {0 , 0 , NULL, 0 }, }; int o; while ( (o = getopt_long(argc, argv, \u0026#34;-bhl:d:p:\u0026#34;, table, NULL)) != -1) { switch (o) { case \u0026#39;b\u0026#39;: sdb_set_batch_mode(); break; case \u0026#39;p\u0026#39;: sscanf(optarg, \u0026#34;%d\u0026#34;, \u0026amp;difftest_port); break; case \u0026#39;l\u0026#39;: log_file = optarg; break; case \u0026#39;d\u0026#39;: diff_so_file = optarg; break; case 1: img_file = optarg; return 0; default: printf(\u0026#34;Usage: %s [OPTION...] IMAGE [args]\\n\\n\u0026#34;, argv[0]); printf(\u0026#34;\\t-b,--batch run with batch mode\\n\u0026#34;); printf(\u0026#34;\\t-l,--log=FILE output log to FILE\\n\u0026#34;); printf(\u0026#34;\\t-d,--diff=REF_SO run DiffTest with reference REF_SO\\n\u0026#34;); printf(\u0026#34;\\t-p,--port=PORT run DiffTest with port PORT\\n\u0026#34;); printf(\u0026#34;\\n\u0026#34;); exit(0); } } return 0; } è¿™æ®µä»£ç æ˜¯ç”¨äºè§£æinit_monitor()å‡½æ•°ä¼ å…¥çš„argcä¸argvå‚æ•°çš„ï¼Œè€Œinit_monitor()çš„argcä¸argvå‚æ•°åˆæ˜¯é€šè¿‡main()å‡½æ•°ä¼ é€’çš„ï¼Œä¸éš¾å‘ç°ï¼Œå½“å‚æ•°ä¸­åŒ…æ‹¬-bä¸€é¡¹æ—¶ï¼Œå°±ä¼šä½¿å¾—NEMUè¿›å…¥æ‰¹å¤„ç†æ¨¡å¼ã€‚\né‚£ä¹ˆï¼Œæˆ‘ä»¬å¯ä»¥å›å¿†ä¸€ä¸‹ï¼Œæˆ‘ä»¬æ˜¯å¦‚ä½•è¿è¡ŒNEMUçš„ï¼Ÿä¼¼ä¹æ˜¯é€šè¿‡Makefileæ„å»ºä¸€ä¸ªrunçš„ç›®æ ‡å®ç°çš„ï¼Œå› æ­¤ï¼Œæˆ‘ä»¬éœ€è¦è¿›ä¸€æ­¥å»å¯»æ‰¾runå¯¹åº”çš„æ„å»ºè§„åˆ™ï¼Œå®ƒåœ¨nemu/scripts/native.mkä¸‹ï¼š\n1 2 3 4 5 6 7 8 IMG ?= NEMU_EXEC := $(BINARY) $(ARGS) $(IMG) run-env: $(BINARY) $(DIFF_REF_SO) run: run-env $(call git_commit, \u0026#34;run NEMU\u0026#34;) $(NEMU_EXEC) ä¸éš¾å‘ç°ï¼Œå½“æ„å»ºrunè¿™ä¸ªç›®æ ‡æ—¶ï¼Œä¼šä½¿ç”¨NEMU_EXECæ„å»ºNEMUï¼Œè€Œå‚æ•°åˆæ˜¯é€šè¿‡ARGSæ¥ä¼ é€’çš„ï¼Œé‚£ä¹ˆï¼Œå½“æˆ‘ä»¬è¿è¡ŒAMæ—¶ï¼Œæ˜¯é€šè¿‡ä»€ä¹ˆæ–¹å¼ä¼ é€’ARGSå‚æ•°çš„å‘¢ï¼Ÿåœ¨AMçš„scripts/platform/nemu.mkä¸­ï¼Œæˆ‘ä»¬ä¸éš¾å‘ç°ï¼š\n1 2 3 4 5 6 NEMUFLAGS += -l $(shell dirname $(IMAGE).elf)/nemu-log.txt /* other logic */ run: insert-arg $(MAKE) -C $(NEMU_HOME) ISA=$(ISA) run ARGS=\u0026#34;$(NEMUFLAGS)\u0026#34; IMG=$(IMAGE).bin å› æ­¤ï¼Œå½“AMè¿è¡ŒNEMUæ—¶ï¼Œä¼šé€šè¿‡å‘½ä»¤è¡Œç›´æ¥ä¼ é€’ARGSå‚æ•°ï¼Œè€Œå¯¹åº”éœ€è¦ä¼ é€’çš„å‚æ•°ç”±NEMUFLAGSæŒ‡å®šï¼Œå› æ­¤ï¼Œæˆ‘ä»¬æœ€ç»ˆåªéœ€æ·»åŠ ï¼š\n1 NEMUFLAGS += -b å³å¯å®ç°é»˜è®¤ä»¥æ‰¹å¤„ç†æ¨¡å¼è¿è¡ŒNEMUã€‚åœ¨cpu-testsè·¯å¾„ä¸‹é‡æ–°è¿è¡Œä¸€éå…¨éƒ¨æµ‹è¯•ï¼š\n1 make ARCH=riscv32-nemu run å‘ç°ç¡®å®åœ¨è¿è¡ŒNEMUæ—¶ä¸ä¼šå†å¯ç”¨sdbäº†ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 # Building recursion-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/recursion.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/recursion-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/recursion-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/recursion-riscv32-nemu.bin, size = 728 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x8000026c [src/cpu/cpu-exec.c:92 statistic] host time spent = 4,025 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 4,545 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 1,129,192 inst/s # Building div-run [riscv32-nemu] # Building am-archive [riscv32-nemu] # Building klib-archive [riscv32-nemu] + CC tests/div.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/div-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/div-riscv32-nemu.bin mainargs= [src/utils/log.c:30 init_log] Log is written to /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/nemu-log.txt [src/memory/paddr.c:50 init_mem] physical memory area [0x80000000, 0x87ffffff] [src/monitor/monitor.c:61 load_img] The image is /home/chenwy/ysyx-workbench/am-kernels/tests/cpu-tests/build/div-riscv32-nemu.bin, size = 404 [src/monitor/monitor.c:28 welcome] Trace: ON [src/monitor/monitor.c:29 welcome] If trace is enabled, a log file will be generated to record the trace. This may lead to a large log file. If it is not necessary, you can disable it in menuconfig [src/monitor/monitor.c:32 welcome] Build time: 20:17:19, Jul 24 2025 Welcome to riscv32-NEMU! For help, type \u0026#34;help\u0026#34; [src/cpu/cpu-exec.c:124 cpu_exec] nemu: HIT GOOD TRAP at pc = 0x80000124 [src/cpu/cpu-exec.c:92 statistic] host time spent = 877 us [src/cpu/cpu-exec.c:93 statistic] total guest instructions = 868 [src/cpu/cpu-exec.c:94 statistic] simulation frequency = 989,737 inst/s ","date":"2025-07-24T00:00:00Z","image":"https://posvirus.github.io/p/batch/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/batch/","title":"å¦‚ä½•è®©NEMUä»¥æ‰¹å¤„ç†æ¨¡å¼è¿è¡Œï¼Ÿ"},{"content":"æä¾›å¯è¯»æ€§æ›´å¼ºçš„Makefileç‰ˆæœ¬ 1 2 3 html: cat Makefile | sed \u0026#39;s/^\\([^#]\\)/ \\1/g\u0026#39; | markdown_py \u0026gt; Makefile.html .PHONY: html é¦–å…ˆï¼Œè¯¥Makefileç»™å‡ºäº†ä¸€ä¸ªhtmlç›®æ ‡ï¼Œç”¨äºç”Ÿæˆå¯è¯»æ€§æ›´å¼ºçš„Makefileï¼Œå…¶å…·ä½“å®ç°åŸç†æ˜¯ï¼Œé¦–å…ˆé€šè¿‡catä»¥è¾“å‡ºMakefileçš„æ‰€æœ‰å†…å®¹è‡³æ ‡å‡†è¾“å‡ºï¼Œå¹¶é€šè¿‡ç®¡é“å°†å…¶ä¼ é€’è‡³sedæŒ‡ä»¤ï¼Œsedä¼šé€šè¿‡æ­£åˆ™è¡¨è¾¾å¼åŒ¹é…æ‰€æœ‰éæ³¨é‡Šè¡Œï¼Œå¹¶å°†æ‰€æœ‰éæ³¨é‡Šè¡Œçš„ç¬¬ä¸€ä¸ªé#å­—ç¬¦å‰åŠ å…¥å››ä¸ªç©ºæ ¼ã€‚è¿™æ—¶ï¼Œè¯¥Makefileçš„æ‰€æœ‰æ³¨é‡Šè¡Œåœ¨Markdownè¯­æ³•ä¸­ä¼šè¢«è¯†åˆ«ä¸ºæ ‡é¢˜ï¼›æ‰€æœ‰éæ³¨é‡Šè¡Œåˆ™ä¼šè¢«è¯†åˆ«ä¸ºä»£ç å—ï¼ˆå› ä¸ºæ’å…¥äº†å››ä¸ªç©ºæ ¼ï¼‰1ã€‚\næœ€åï¼Œå†è°ƒç”¨markdown_pyå°†å…¶è½¬æ¢ä¸ºHTMLæ ¼å¼ï¼Œå¹¶é‡å®šå‘è‡³Makefile.htmlä¸­ã€‚\nåŸºæœ¬é…ç½®ä¸è¿è¡Œæ£€æŸ¥ 1 2 3 4 ifeq ($(MAKECMDGOALS),) MAKECMDGOALS = image .DEFAULT_GOAL = image endif é¦–å…ˆï¼Œæˆ‘ä»¬ä¼šæ£€æŸ¥Makefileæ‰§è¡Œçš„ç›®æ ‡ï¼Œè¿™é‡Œé€šè¿‡ä¸€ä¸ªç¯å¢ƒå˜é‡MAKECMDGOALSå¼•ç”¨ï¼Œå½“è¯¥å€¼ä¸ºç©ºæ—¶ï¼Œè¯´æ˜æˆ‘ä»¬ä»…è¾“å…¥äº†makeï¼Œæ­¤æ—¶å°†MAKECMDGOALSè®¾ç½®ä¸ºimageï¼Œä»£è¡¨é»˜è®¤åˆ›å»ºä¸€ä¸ªè£¸æœºé•œåƒã€‚åŒæ—¶å°†å¦ä¸€ä¸ªç¯å¢ƒå˜é‡.DEFAULT_GOALä¹Ÿè®¾ç½®ä¸ºimageï¼Œè¯·æ³¨æ„ï¼Œ.DEFAULT_GOALSä¼šçœŸæ­£åœ°å°†Makefileçš„æ‰§è¡Œç›®æ ‡è®¾å®šä¸ºimageï¼Œè€Œæˆ‘ä»¬æ­¤å¤„å°†MAKECMDGOALSè®¾ç½®ä¸ºimageçš„ç›®çš„æ˜¯ä¸ºäº†åç»­çš„é…ç½®ä¸è¿è¡Œæ£€æŸ¥ã€‚\n1 2 3 4 ifeq ($(findstring $(MAKECMDGOALS),clean|clean-all|html),) ... ### Checks end here endif å…¶æ¬¡ï¼Œæˆ‘ä»¬ä¼šä½¿ç”¨findstringæ£€æŸ¥MAKECMDGOALSæ˜¯å¦æ˜¯cleanã€clean-allã€htmlä¸­çš„ä¸€è€…ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™è¯¥åˆ¤æ–­ä¸ºfalseï¼Œæˆ‘ä»¬ä¼šè·³è¿‡è¯¥æ®µè¿è¡Œç¯å¢ƒæ£€æŸ¥ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œifeqä¸å¯¹åº”çš„endifç¦»å¾—å¾ˆè¿œï¼Œéœ€è¦æ˜ç¡®ä¸­é—´çš„è¯­å¥å‡åªæœ‰åœ¨åˆ¤æ–­ä¸ºçœŸçš„æ—¶å€™æ‰æ‰§è¡Œã€‚\n1 $(info # Building $(NAME)-$(MAKECMDGOALS) [$(ARCH)]) åœ¨å‘½ä»¤è¡Œä¸­è¾“å‡ºå¯¹åº”çš„æ„å»ºæ¨¡æ¿ï¼Œå…¶ä¸­MAKECMDGOALSæ˜¯è¯¥Makefileå¯¹åº”çš„æ„å»ºç›®æ ‡ï¼ŒNAMEæ˜¯AMå…¶ä»–å­ç›®å½•ä¸‹çš„Makefileå®šä¹‰çš„å˜é‡ï¼Œæ¯”å¦‚åœ¨srcä¸‹çš„Makefileå¯¹åº”çš„NAMEä¸ºamï¼Œè€ŒARCHåˆ™ä¸ºåœ¨è¾“å…¥makeæ—¶æŒ‡ä»¤çš„æ¶æ„å˜é‡ï¼Œå›å¿†PA2çš„å‰ä¸€èŠ‚ï¼Œæˆ‘ä»¬åœ¨è¿è¡Œcpu-testsæ—¶ä½¿ç”¨è¿‡å¦‚ä¸‹å½¢å¼çš„makeæŒ‡ä»¤è¿›è¡Œæ„å»ºï¼š\n1 make ARCH=$ISA-nemu ALL=dummy run æ­¤å¤„æˆ‘ä»¬å³æŒ‡å®šäº†ARCHå˜é‡å¯¹åº”çš„å€¼ã€‚\n1 2 3 ifeq ($(wildcard $(AM_HOME)/am/include/am.h),) $(error $$AM_HOME must be an AbstractMachine repo) endif æ¥ç€ï¼ŒMakefileä¼šæ£€æŸ¥ç¯å¢ƒå˜é‡AM_HOMEæ˜¯å¦è®¾ç½®æ­£ç¡®ï¼Œæ­¤å¤„ä¸»è¦ä½¿ç”¨wildcardæŸ¥æ‰¾am.hæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™è¯´æ˜æ­£ç¡®ã€‚\n1 2 3 4 ARCHS = $(basename $(notdir $(shell ls $(AM_HOME)/scripts/*.mk))) ifeq ($(filter $(ARCHS), $(ARCH)), ) $(error Expected $$ARCH in {$(ARCHS)}, Got \u0026#34;$(ARCH)\u0026#34;) endif éšåï¼Œæˆ‘ä»¬ä¼šæ£€æŸ¥é€šè¿‡å‘½ä»¤è¡Œä¼ è¾“çš„æ¶æ„ä¿¡æ¯ARCHæ˜¯å¦åœ¨é¡¹ç›®ä¸­å­˜åœ¨å¯¹åº”çš„Makefileï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬ä½¿ç”¨lsæŒ‡ä»¤åˆ—ä¸¾scriptså­ç›®å½•ä¸‹çš„æ‰€æœ‰.mkæ–‡ä»¶ï¼Œç›´æ¥è¿è¡Œè¯¥æŒ‡ä»¤çš„è¾“å‡ºä¸ºï¼š\n1 2 3 4 5 6 /home/chenwy/ysyx-workbench/abstract-machine/scripts/loongarch32r-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/mips32-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv64-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/native.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/spike.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86_64-qemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32e-npc.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/riscv32mini-nemu.mk /home/chenwy/ysyx-workbench/abstract-machine/scripts/x86-qemu.mk æˆ‘ä»¬ä½¿ç”¨notdirå‡½æ•°è¿‡æ»¤æ–‡ä»¶å‰çš„æ–‡ä»¶å¤¹è·¯å¾„ï¼Œéœ€è¦æŒ‡å‡ºï¼Œnotdiræ˜¯ä¸€ä¸ªMakfileå‡½æ•°è€ŒébashæŒ‡ä»¤ã€‚\næ¥ç€ï¼Œæˆ‘ä»¬ä½¿ç”¨basenameæŒ‡ä»¤ï¼ˆè¿™æ˜¯ä¸€æ¡æŒ‡ä»¤ï¼‰è·å–è¿™äº›æ–‡ä»¶çš„æ–‡ä»¶åï¼Œå¹¶å°†å…¶èµ‹å€¼ç»™ARCHSï¼Œä»£è¡¨AMç›®å‰æ”¯æŒçš„æ¶æ„é›†åˆã€‚è¿›è€Œï¼Œæˆ‘ä»¬å³å¯ä½¿ç”¨filterå‡½æ•°ï¼ˆè¿™åŒæ ·æ˜¯ä¸€ä¸ªMakefileå‡½æ•°ï¼‰åˆ¤æ–­ARCHå¯¹åº”çš„æ¶æ„æ˜¯å¦å­˜åœ¨äºARCHSä¸­ï¼Œå¦‚ä¸å­˜åœ¨åˆ™æŠ¥é”™ã€‚\n1 2 3 ARCH_SPLIT = $(subst -, ,$(ARCH)) ISA = $(word 1,$(ARCH_SPLIT)) PLATFORM = $(word 2,$(ARCH_SPLIT)) ä»¥ä¸‹ï¼Œç¡®å®šæ¶æ„æœ‰æ•ˆåï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨substå‡½æ•°å°†ARCHè¿æ¥å¹³å°ä¸ISAçš„è¿å­—ç¬¦-æ›¿æ¢ä¸ºç©ºæ ¼ï¼Œå†ä½¿ç”¨wordå‡½æ•°åˆ†åˆ«æå–å¯¹åº”çš„ISAï¼ˆå¦‚riscv32ç­‰ï¼‰ä¸å¹³å°ï¼ˆnemuã€qemuä¸npcç­‰ï¼‰ã€‚\n1 2 3 ifeq ($(flavor SRCS), undefined) $(error Nothing to build) endif æœ€åï¼Œæˆ‘ä»¬ä½¿ç”¨flavorå‡½æ•°æ£€æŸ¥SRCï¼Œå³éœ€è¦æ„å»ºçš„æºæ–‡ä»¶æ˜¯å¦è¢«å®šä¹‰ï¼Œè‹¥æœªå®šä¹‰åˆ™åŒæ ·æŠ¥é”™ã€‚\næ­¤å¤„éœ€è¦æŒ‡å‡ºï¼ŒSRCSä¸ä¹‹å‰çš„NAMEç±»ä¼¼ï¼Œéƒ½æ˜¯é€šè¿‡å…¶ä»–Makefileå®šä¹‰ï¼Œå†åŒ…å«è¯¥Makefileç»™å‡ºçš„ï¼Œå› æ­¤æˆ‘ä»¬äº‹å®ä¸Šæ— æ³•é€šè¿‡è¿™ä¸ªMakefileæ„å»ºæŸä¸ªç›®æ ‡ï¼ˆå½“ç„¶htmlé™¤å¤–ï¼‰ï¼Œè€Œåº”å½“æ˜¯å…¶å®ƒMakefileè°ƒç”¨è¯¥Makefileè¿›è¡Œæ„å»ºã€‚\nè‡³æ­¤ï¼ŒåŸºæœ¬é…ç½®ä¸è¿è¡Œæ£€æŸ¥å®Œæ¯•ã€‚\nç¼–è¯‘ç›®æ ‡å®šä¹‰ 1 2 3 WORK_DIR = $(shell pwd) DST_DIR = $(WORK_DIR)/build/$(ARCH) $(shell mkdir -p $(DST_DIR)) é¦–å…ˆï¼Œæˆ‘ä»¬å®šä¹‰å·¥ä½œç›®å½•WORK_DIRä¸ºå½“å‰ç›®å½•ï¼ŒåŒæ—¶å®šä¹‰ç¼–è¯‘è¾“å‡ºç›®å½•DST_DIRä¸ºå·¥ä½œç›®å½•ä¸‹buildç›®å½•ä¸­å¯¹åº”çš„$(ARCH)å­ç›®å½•ï¼Œå¹¶ä½¿ç”¨mkdir -påˆ›å»ºè¯¥ç›®å½•ã€‚\n1 2 3 IMAGE_REL = build/$(NAME)-$(ARCH) IMAGE = $(abspath $(IMAGE_REL)) ARCHIVE = $(WORK_DIR)/build/$(NAME)-$(ARCH).a å…¶æ¬¡ï¼ŒIMAGE_RELå®šä¹‰äº†æœ€ç»ˆçš„å¯æ‰§è¡Œæ–‡ä»¶$(NAME)-$(ARCH)çš„ç›¸å¯¹è·¯å¾„ï¼ŒåŒæ—¶ä½¿ç”¨IMAGEè°ƒç”¨abspathå‡½æ•°å®šä¹‰å…¶ç»å¯¹è·¯å¾„ï¼ŒARCHIVEåˆ™å®šä¹‰äº†å½’æ¡£æ–‡ä»¶$(NAME)-$(ARCH).aå¯¹åº”çš„ç»å¯¹è·¯å¾„ã€‚\n1 2 3 4 5 6 OBJS = $(addprefix $(DST_DIR)/, $(addsuffix .o, $(basename $(SRCS)))) LIBS := $(sort $(LIBS) am klib) # lazy evaluation (\u0026#34;=\u0026#34;) causes infinite recursions LINKAGE = $(OBJS) \\ $(addsuffix -$(ARCH).a, $(join \\ $(addsuffix /build/, $(addprefix $(AM_HOME)/, $(LIBS))), \\ $(LIBS) )) æ¥ç€ï¼Œæˆ‘ä»¬å®šä¹‰äº†ç¼–è¯‘çš„è¾“å‡ºä¸­é—´æ–‡ä»¶æ–‡ä»¶è·¯å¾„OBJSï¼Œè¯¥å®šä¹‰é¦–å…ˆé€šè¿‡basenameæŒ‡ä»¤è·å–SRCSçš„æ–‡ä»¶åï¼Œå¹¶ä½¿ç”¨addsuffixå‡½æ•°å°†æ–‡ä»¶åç¼€ç½®ä¸º.oï¼Œéšåä½¿ç”¨addprefixå°†ä¸­é—´æ–‡ä»¶è·¯å¾„ç»Ÿä¸€æŒ‡å®šä¸ºè¾“å‡ºç›®å½•DST_DIRä¸‹ã€‚\nè€Œæˆ‘ä»¬ç»§ç»­å¯ä»¥å®šä¹‰åº“æ–‡ä»¶æ‰€åœ¨è·¯å¾„LIBSï¼Œé€šè¿‡ç«‹å³èµ‹å€¼:=å¯ä»¥é¿å…è¯¥å®šä¹‰è¢«é€’å½’å±•å¼€2ï¼ŒåŒæ—¶ä½¿ç”¨sorté¿å…é‡å¤å®šä¹‰ï¼Œè¿™æ˜¯å› ä¸ºLIBSå¯èƒ½åœ¨å…¶å®ƒMakefileä¸­ä¹Ÿè¢«å®šä¹‰ï¼Œå› æ­¤å¯èƒ½æœ¬èº«å°±åŒ…å«amæˆ–klibï¼Œæ•…æ­¤å¤„éœ€è¦å»é‡å¤„ç†ã€‚\næœ€åï¼Œæˆ‘ä»¬æ”¶é›†æ‰€æœ‰éœ€è¦è¢«é“¾æ¥çš„æ–‡ä»¶ï¼ŒåŒ…æ‹¬OBJSä»¥åŠå½’æ¡£æ–‡ä»¶ï¼ˆå¦‚am-$(ARCH).aã€klib-$(ARCH).aï¼‰ã€‚\nè¿™é‡Œéœ€è¦å¯¹LINKAGEä¸ARCHIVEè¿›è¡Œä¸€ä¸ªå¯¹æ¯”ï¼ŒLINKAGEæ˜¯æˆ‘ä»¬åœ¨ç”Ÿæˆè£¸æœºé•œåƒæ—¶éœ€è¦ä½¿ç”¨çš„ï¼Œæ‰€æœ‰éœ€è¦é“¾æ¥çš„æ–‡ä»¶ï¼Œå®ƒåŒ…å«äº†ç¼–è¯‘è¾“å‡ºçš„æ‰€æœ‰ä¸­é—´æ–‡ä»¶OBJSä»¥åŠLIBSå¯¹åº”çš„æ‰€æœ‰å½’æ¡£æ–‡ä»¶ã€‚è€ŒARCHIVEå¯¹åº”çš„æ˜¯ä¸€ä¸ªå±€éƒ¨æ€§çš„æ¦‚å¿µï¼Œæ˜¯æŒ‡æŸä¸€ä¸ªæ–‡ä»¶å¤¹è°ƒç”¨è¯¥Makefileæ—¶ï¼Œç”Ÿæˆçš„å½’æ¡£æ–‡ä»¶ï¼ˆåœ¨è¯¥Makefileåç»­é€»è¾‘ä¸­æˆ‘ä»¬ä¼šçŸ¥é“ï¼Œç”Ÿæˆè£¸æœºé•œåƒimageä¸ç”Ÿæˆå½’æ¡£æ–‡ä»¶archiveæ˜¯ä¸¤ä¸ªç›¸å¯¹ç‹¬ç«‹çš„ç›®æ ‡ï¼‰ã€‚å› æ­¤ï¼Œåœ¨PA2å‰ä¸€èŠ‚æˆ‘ä»¬è¿è¡Œcpu-testsæ—¶ï¼Œå¯¹åº”çš„makeè¾“å‡ºå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Building am-archive [riscv32-nemu] + CC src/platform/nemu/trm.c + CC src/platform/nemu/ioe/ioe.c + CC src/platform/nemu/ioe/timer.c + CC src/platform/nemu/ioe/input.c + CC src/platform/nemu/ioe/gpu.c + CC src/platform/nemu/ioe/audio.c + CC src/platform/nemu/ioe/disk.c + CC src/platform/nemu/mpe.c + AS src/riscv/nemu/start.S + CC src/riscv/nemu/cte.c + AS src/riscv/nemu/trap.S + CC src/riscv/nemu/vme.c + AR -\u0026gt; build/am-riscv32-nemu.a # Building klib-archive [riscv32-nemu] + CC src/stdio.c + CC src/int64.c + CC src/cpp.c + CC src/stdlib.c + CC src/string.c + AR -\u0026gt; build/klib-riscv32-nemu.a + CC tests/dummy.c # Creating image [riscv32-nemu] + LD -\u0026gt; build/dummy-riscv32-nemu.elf + OBJCOPY -\u0026gt; build/dummy-riscv32-nemu.bin æˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œè¿™ä¸ªmakeå…¶å®åŒ…å«ä¸‰ä¸ªæ­¥éª¤ï¼š\nç¬¬ä¸€æ­¥ï¼š å°†amç›®å½•ä¸‹çš„æºæ–‡ä»¶ç¼–è¯‘ï¼Œå¹¶æ‰“åŒ…ä¸ºå½’æ¡£æ–‡ä»¶am-riscv32-nemu.aï¼ˆå³ä¸ºARCHIVEï¼‰ã€‚ ç¬¬äºŒæ­¥ï¼š å°†klibç›®å½•ä¸‹çš„æºæ–‡ä»¶ç¼–è¯‘ï¼Œå¹¶æ‰“åŒ…ä¸ºå½’æ¡£æ–‡ä»¶klib-riscv32-nemu.aï¼ˆå³ä¸ºARCHIVEï¼‰ã€‚ ç¬¬ä¸‰æ­¥ï¼š ç¼–è¯‘å®¢æˆ·ç¨‹åºdummy.cï¼Œå¹¶å°†å…¶ä¸ä¹‹å‰ç”Ÿæˆçš„å½’æ¡£æ–‡ä»¶ä¸€èµ·é“¾æ¥ä¸ºå¯æ‰§è¡Œæ–‡ä»¶ï¼ˆå³ä¸ºLINKAGEï¼‰ã€‚ ç¼–è¯‘é€‰é¡¹è®¾ç½® 1 2 3 4 5 6 7 8 AS = $(CROSS_COMPILE)gcc CC = $(CROSS_COMPILE)gcc CXX = $(CROSS_COMPILE)g++ LD = $(CROSS_COMPILE)ld AR = $(CROSS_COMPILE)ar OBJDUMP = $(CROSS_COMPILE)objdump OBJCOPY = $(CROSS_COMPILE)objcopy READELF = $(CROSS_COMPILE)readelf é¦–å…ˆå®šä¹‰äº¤å‰ç¼–è¯‘æ‰€éœ€çš„å·¥å…·åï¼Œè¿™é‡Œçš„CROSS_COMPILEåœ¨$(AM_HOME)/scripts/isaä¸­çš„Makefileè¢«å®šä¹‰ã€‚\n1 2 INC_PATH += $(WORK_DIR)/include $(addsuffix /include/, $(addprefix $(AM_HOME)/, $(LIBS))) INCFLAGS += $(addprefix -I, $(INC_PATH)) éšåå®šä¹‰åŒ…å«çš„è·¯å¾„ï¼ŒåŒ…æ‹¬å½“å‰è·¯å¾„ä¸‹çš„includeä¸AMåº“æ–‡ä»¶LIBSä¸‹çš„includeï¼Œå¹¶åœ¨å…¶å‰åŠ å…¥-Iä½œä¸ºINCFLAGSä¾›ç¼–è¯‘å™¨ä½¿ç”¨ã€‚\n1 2 3 4 5 6 7 8 9 10 11 ARCH_H := arch/$(ARCH).h CFLAGS += -O2 -MMD -Wall -Werror $(INCFLAGS) \\ -D__ISA__=\\\u0026#34;$(ISA)\\\u0026#34; -D__ISA_$(shell echo $(ISA) | tr a-z A-Z)__ \\ -D__ARCH__=$(ARCH) -D__ARCH_$(shell echo $(ARCH) | tr a-z A-Z | tr - _) \\ -D__PLATFORM__=$(PLATFORM) -D__PLATFORM_$(shell echo $(PLATFORM) | tr a-z A-Z | tr - _) \\ -DARCH_H=\\\u0026#34;$(ARCH_H)\\\u0026#34; \\ -fno-asynchronous-unwind-tables -fno-builtin -fno-stack-protector \\ -Wno-main -U_FORTIFY_SOURCE -fvisibility=hidden CXXFLAGS += $(CFLAGS) -ffreestanding -fno-rtti -fno-exceptions ASFLAGS += -MMD $(INCFLAGS) LDFLAGS += -z noexecstack $(addprefix -T, $(LDSCRIPTS)) è¿™é‡Œå®šä¹‰å…·ä½“çš„ç¼–è¯‘/é“¾æ¥é€‰é¡¹ï¼Œæ­¤å¤„ä¸ä½œè¯´æ˜ã€‚\n1 -include $(AM_HOME)/scripts/$(ARCH).mk åŒæ—¶ï¼Œæˆ‘ä»¬åŒ…å«ARCHæ¶æ„çš„Makefileï¼Œå¯¹å‰é¢çš„é€‰é¡¹è¿›è¡Œè¿›ä¸€æ­¥é…ç½®ã€‚\nç›®æ ‡æ„å»ºè§„åˆ™ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 ### Rule (compile): a single `.c` -\u0026gt; `.o` (gcc) $(DST_DIR)/%.o: %.c @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CC $\u0026lt; @$(CC) -std=gnu11 $(CFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cc` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cc @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.cpp` -\u0026gt; `.o` (g++) $(DST_DIR)/%.o: %.cpp @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + CXX $\u0026lt; @$(CXX) -std=c++17 $(CXXFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (compile): a single `.S` -\u0026gt; `.o` (gcc, which preprocesses and calls as) $(DST_DIR)/%.o: %.S @mkdir -p $(dir $@) \u0026amp;\u0026amp; echo + AS $\u0026lt; @$(AS) $(ASFLAGS) -c -o $@ $(realpath $\u0026lt;) ### Rule (recursive make): build a dependent library (am, klib, ...) $(LIBS): %: @$(MAKE) -s -C $(AM_HOME)/$* archive ### Rule (link): objects (`*.o`) and libraries (`*.a`) -\u0026gt; `IMAGE.elf`, the final ELF binary to be packed into image (ld) $(IMAGE).elf: $(LINKAGE) $(LDSCRIPTS) @echo \\# Creating image [$(ARCH)] @echo + LD \u0026#34;-\u0026gt;\u0026#34; $(IMAGE_REL).elf ifneq ($(filter $(ARCH),native),) @$(CXX) -o $@ -Wl,--whole-archive $(LINKAGE) -Wl,-no-whole-archive $(LDFLAGS_CXX) else @$(LD) $(LDFLAGS) -o $@ --start-group $(LINKAGE) --end-group endif ### Rule (archive): objects (`*.o`) -\u0026gt; `ARCHIVE.a` (ar) $(ARCHIVE): $(OBJS) @echo + AR \u0026#34;-\u0026gt;\u0026#34; $(shell realpath $@ --relative-to .) @$(AR) rcs $@ $^ ### Rule (`#include` dependencies): paste in `.d` files generated by gcc on `-MMD` -include $(addprefix $(DST_DIR)/, $(addsuffix .d, $(basename $(SRCS)))) è¿™éƒ¨åˆ†æ˜¯å…·ä½“çš„ç›®æ ‡æ„å»ºè§„åˆ™ï¼Œä¸ä½œèµ˜è¿°ã€‚\næ„å»ºé¡ºåºå®šä¹‰ 1 2 3 4 5 image: image-dep archive: $(ARCHIVE) image-dep: $(LIBS) $(IMAGE).elf .NOTPARALLEL: image-dep .PHONY: image image-dep archive run $(LIBS) è¿™éƒ¨åˆ†å®šä¹‰äº†å„ä¸ªç›®æ ‡çš„ä¾èµ–å…³ç³»ï¼Œå½“æˆ‘ä»¬æ„å»ºè£¸æœºé•œåƒimageæ—¶ï¼Œéœ€è¦é¦–å…ˆæ„å»º$(LIBS)åŠ$(IMAGE).elfï¼Œ$(IMAGE).elfçš„æ„å»ºä¾èµ–äºLINKAGEï¼Œè¿™åŒ…å«äº†OBJSä¸LIBSå¯¹åº”çš„å½’æ¡£æ–‡ä»¶ä¸¤éƒ¨åˆ†ï¼Œæ„å»º$(LIBS)æ—¶ï¼Œæˆ‘ä»¬ä¾¿ä¼šä½¿ç”¨make archiveåˆ›å»ºå…¶å¯¹åº”çš„å½’æ¡£æ–‡ä»¶ã€‚è€ŒOBJSçš„æ„å»ºåˆ™ä¾èµ–äºç›®æ ‡æ„å»ºè§„åˆ™ä¸­çš„å•æ–‡ä»¶ç¼–è¯‘ã€‚\nè‡³æ­¤ï¼Œæˆ‘ä»¬å¤§è‡´æ¢³ç†äº†AMçš„Makefileæ¶æ„åŠå®ç°åŸç†ã€‚\nç®€ä¹¦Markdownç”¨æ³•ï¼š4ä¸ªç©ºæ ¼æ ‡è®°ä»£ç å—çš„è¯´æ˜\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nMakefileä¸­:=, =, ?=å’Œ+=çš„å«ä¹‰\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-07-23T00:00:00Z","image":"https://posvirus.github.io/p/am-makefile-1/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/am-makefile-1/","title":"AM Makefileè§£è¯»ï¼ˆ1ï¼‰"},{"content":"é¦–å…ˆï¼Œexec_once()ä¼šæ¥æ”¶Decodeç»“æ„ä½“æŒ‡é’ˆ sï¼Œä»¥åŠå½“å‰çš„PCå€¼pcï¼Œpcæ¯”è¾ƒå¥½ç†è§£ï¼Œå®ƒé€šå¸¸æ˜¯é€šè¿‡CPU_stateç»“æ„ä½“cpuä¸­çš„pcæˆå‘˜ä¼ é€’çš„ï¼ŒRV32 ISAçš„CPU_stateç»“æ„ä½“å®šä¹‰åœ¨isa-def.hä¸­ï¼š\n1 2 3 4 typedef struct { word_t gpr[MUXDEF(CONFIG_RVE, 16, 32)]; vaddr_t pc; } MUXDEF(CONFIG_RV64, riscv64_CPU_state, riscv32_CPU_state); åŒ…å«ä¸€ä¸ªå¯„å­˜å™¨å †ä¸PCå¯„å­˜å™¨ï¼Œå¯ä»¥è¿™æ ·è¯´ï¼ŒCPU_stateç»“æ„ä½“å®šä¹‰äº†å¤„ç†å™¨æ ¸çš„çŠ¶æ€ã€‚\nDecodeç»“æ„ä½“è¢«å®šä¹‰åœ¨decode.hä¸­ï¼š\n1 2 3 4 5 6 7 typedef struct Decode { vaddr_t pc; vaddr_t snpc; // static next pc vaddr_t dnpc; // dynamic next pc ISADecodeInfo isa; IFDEF(CONFIG_ITRACE, char logbuf[128]); } Decode; å…¶å®šä¹‰äº†å½“å‰PCå€¼ï¼Œä»¥åŠè¯¥æŒ‡ä»¤æ‰§è¡Œåçš„ä¸‹ä¸€PCå€¼ï¼ˆè¿™é‡Œæš‚æ—¶ä¸è¯´æ˜é™æ€/åŠ¨æ€æœ‰ä»€ä¹ˆåŒºåˆ«ï¼‰ï¼Œå…¶æ¬¡ï¼Œå®ƒè¿˜å®šä¹‰äº†ä¸€ä¸ªISADecodeInfoç»“æ„ä½“æˆå‘˜isaï¼Œå…¶å®šä¹‰åœ¨isa-def.hä¸­ï¼š\n1 2 3 typedef struct { uint32_t inst; } MUXDEF(CONFIG_RV64, riscv64_ISADecodeInfo, riscv32_ISADecodeInfo); ä¸éš¾çœ‹å‡ºï¼Œè¿™å…¶å®å°±æ˜¯å½“å‰çš„æŒ‡ä»¤ã€‚\nexec_once()æ¥æ”¶è¿™ä¸¤ä¸ªå‚æ•°åï¼Œä¼šé¦–å…ˆå°†CPUçš„å½“å‰PCå€¼pcä¼ é€’è‡³sä¸­ï¼Œå¹¶å°†sä¸­çš„å½“å‰PCå€¼ä¸ä¸‹ä¸€é™æ€PCå€¼å‡è®¾ä¸ºCPUçš„å½“å‰PCå€¼pcã€‚\néšåï¼Œexec_once()ä¼šè°ƒç”¨isa_exec_once()å‡½æ•°ï¼Œå¹¶å°†sä¼ é€’è¿›å…¥è¯¥å‡½æ•°ï¼Œè¯¥å‡½æ•°æ‰§è¡Œå®Œæˆåï¼Œä»£è¡¨å½“å‰æŒ‡ä»¤æ‰§è¡Œå®Œæˆï¼Œéšåexec_once()ä¼šå°†sä¸­çš„ä¸‹ä¸€åŠ¨æ€PCå€¼dnpcç½®ä¸ºCPUçš„å½“å‰PCå€¼pcï¼Œä»£è¡¨æ‰§è¡Œå®Œæˆã€‚\nå› æ­¤ï¼Œå®ŒæˆæŒ‡ä»¤æ‰§è¡Œçš„æ ¸å¿ƒå‡½æ•°æ˜¯isa_exec_once()ï¼Œå®ƒè¢«å®šä¹‰åœ¨inst.cä¸­ï¼š\n1 2 3 4 int isa_exec_once(Decode *s) { s-\u0026gt;isa.inst = inst_fetch(\u0026amp;s-\u0026gt;snpc, 4); return decode_exec(s); } å…¶ä½¿ç”¨inst_fetch()è·å–å½“å‰æŒ‡ä»¤ï¼ˆIFï¼‰ï¼Œå¹¶ä½¿ç”¨decode_exec()è¿›è¡ŒæŒ‡ä»¤è¯‘ç ï¼ˆIDï¼‰ä¸æ‰§è¡Œï¼ˆEXï¼‰ã€‚\ninst_fetch()å®šä¹‰åœ¨ifetch.hä¸­ï¼š\n1 2 3 4 5 static inline uint32_t inst_fetch(vaddr_t *pc, int len) { uint32_t inst = vaddr_ifetch(*pc, len); (*pc) += len; return inst; } å®ƒå®é™…ä¸Šé¦–å…ˆè¯»å–äº†å½“å‰PCå€¼å¯¹åº”çš„æŒ‡ä»¤ï¼ˆå¹¶è¿”å›ï¼‰ï¼Œå¹¶å°†sçš„ä¸‹ä¸€é™æ€PCå€¼åŠ 4ã€‚å…¶ä¸­vaddr_ifetch()å®šä¹‰åœ¨vaddr.cä¸­ï¼Œå®ƒç›®å‰å°±æ˜¯ä¸€æ¡ç®€å•çš„è¯»å–å†…å­˜çš„æŒ‡ä»¤ã€‚\nè¿™é‡Œï¼Œæˆ‘ä»¬å°±å¯ä»¥ç†è§£ä¸‹ä¸€é™æ€PCå€¼ä¸ä¸‹ä¸€åŠ¨æ€PCå€¼çš„åŒºåˆ«ï¼Œä¸‹ä¸€é™æ€PCå€¼æ˜¯æŒ‡åœ¨ç‰©ç†å­˜å‚¨ä¸Šï¼Œå­˜å‚¨äºå½“å‰æŒ‡ä»¤åçš„ä¸‹ä¸€æ¡æŒ‡ä»¤çš„åœ°å€ï¼Œåœ¨ä»¥å­—èŠ‚ç¼–å€çš„32ä½CPUä¸Šï¼Œæˆç«‹snpc = pc + 4ï¼Œä¸‹ä¸€åŠ¨æ€PCå€¼åˆ™æ˜¯åœ¨å½“å‰æŒ‡ä»¤çœŸæ­£æ‰§è¡Œå®Œæˆåï¼Œå¯¹åº”çš„ä¸‹ä¸€PCå€¼ï¼Œç”±äºè·³è½¬æŒ‡ä»¤çš„å­˜åœ¨ï¼Œå…¶ä¸ä¸‹ä¸€é™æ€PCå€¼å¹¶ä¸ä¸€å®šä¸€è‡´ã€‚\ndecode_exec()ä¸­æœ‰è¾ƒå¤šçš„å®å®šä¹‰ï¼Œæ­¤å¤„æˆ‘ä»¬ä¿®æ”¹NEMUçš„Makefileï¼Œä½¿å…¶å¯ä»¥é€šè¿‡ï¼š\n1 make raw è¾“å‡ºNEMUå„æ–‡ä»¶å¯¹åº”çš„é¢„å¤„ç†æ–‡ä»¶ï¼Œåœ¨inst.iä¸­ï¼Œå³å¯è·å¾—å¯¹åº”å®å±•å¼€çš„ç»“æœã€‚\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/exec-once/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/exec-once/","title":"exec_once()å‡½æ•°æ‰§è¡Œé€»è¾‘"},{"content":"divæŒ‡ä»¤ 1 2 3 4 5 6 7 8 9 10 11 12 XReg src1 = X[rs1]; XReg src2 = X[rs2]; XReg signed_min = (xlen() == 32) ? $signed({1\u0026#39;b1, {31{1\u0026#39;b0}}}) : {1\u0026#39;b1, {63{1\u0026#39;b0}}}; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else if ((src1 == signed_min) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG / -1) X[rd] = signed_min; } else { X[rd] = $signed(src1) / $signed(src2); } å¯¹åº”çš„æ¨¡å¼åŒ¹é…ï¼š\n1 INSTPAT(\u0026#34;0000001 ????? ????? 100 ????? 01100 11\u0026#34;, div , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (~(word_t)0) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (min_val) : ((sword_t)(src1) / (sword_t)(src2)))); divuæŒ‡ä»¤ 1 2 3 4 5 6 7 8 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = {MXLEN{1\u0026#39;b1}}; } else { X[rd] = src1 / src2; } å¯¹åº”çš„æ¨¡å¼åŒ¹é…ï¼š\n1 INSTPAT(\u0026#34;0000001 ????? ????? 101 ????? 01100 11\u0026#34;, divu , R, R(rd) = (src2 == 0) ? (~(word_t)0) : (src1 / src2)); remæŒ‡ä»¤ 1 2 3 4 5 6 7 8 9 10 11 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { // division by zero X[rd] = src1; } else if ((src1 == {1\u0026#39;b1, {MXLEN - 1{1\u0026#39;b0}}}) \u0026amp;\u0026amp; (src2 == {MXLEN{1\u0026#39;b1}})) { // overflow (MAX_NEG % -1) X[rd] = 0; } else { X[rd] = $signed(src1) % $signed(src2); } å¯¹åº”çš„æ¨¡å¼åŒ¹é…ï¼š\n1 INSTPAT(\u0026#34;0000001 ????? ????? 110 ????? 01100 11\u0026#34;, rem , R, word_t min_val = 1u \u0026lt;\u0026lt; 31; R(rd) = (src2 == 0) ? (src1) : (((src1 == min_val) \u0026amp;\u0026amp; (src2 == (~(word_t)0))) ? (0) : ((sword_t)(src1) % (sword_t)(src2)))); remuæŒ‡ä»¤ 1 2 3 4 5 6 7 XReg src1 = X[rs1]; XReg src2 = X[rs2]; if (src2 == 0) { X[rd] = src1; } else { X[rd] = src1 % src2; } å¯¹åº”çš„æ¨¡å¼åŒ¹é…ï¼š\n1 INSTPAT(\u0026#34;0000001 ????? ????? 111 ????? 01100 11\u0026#34;, remu , R, R(rd) = (src2 == 0) ? (src1) : (src1 % src2)); ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/riscv32m/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/riscv32m/","title":"RV32Mæ‰©å±•æŒ‡ä»¤çš„æ‰§è¡Œé€»è¾‘"},{"content":"åœ¨ä½¿ç”¨-march=rv32im_zicsrå¯¹æµ‹è¯•ç¨‹åºè¿›è¡Œç¼–è¯‘æ—¶ï¼Œä¼šå‘ç°æµ‹è¯•å¯¹åº”çš„é™¤æ³•ä¸å–ä½™æ“ä½œï¼ˆæœ‰ç¬¦å·/æ— ç¬¦å·ï¼‰ä¸èƒ½è¢«æ­£ç¡®ç¼–è¯‘è‡³divç­‰RV32Mæ‰©å±•æŒ‡ä»¤ï¼ŒåŸä»¥ä¸ºæ˜¯æŒ‡ä»¤é›†æ¶æ„é€‰æ‹©é”™è¯¯ï¼Œåç»­å‘ç°æ˜¯å› ä¸ºå½“é™¤æ•°æ˜¯å¸¸é‡æ—¶ï¼Œï¼ˆå¦‚a / 10ï¼‰ï¼Œç¼–è¯‘å™¨å¯èƒ½ç”¨æ›´é«˜æ•ˆçš„ç§»ä½/ä¹˜æ³•åºåˆ—æ›¿ä»£é™¤æ³•æŒ‡ä»¤æˆ–å–ä½™æŒ‡ä»¤ï¼Œä¸ºé˜²æ­¢è¯¥ä¼˜åŒ–ï¼Œå¯ä»¥åœ¨å˜é‡å£°æ˜å‰åŠ å…¥volatileå…³é”®å­—ï¼ŒæŒ‡ç¤ºè¯¥å˜é‡éšæ—¶å¯å˜ï¼Œä»è€Œé™åˆ¶å…¶ä¼˜åŒ–ã€‚\nä»¥ä¸‹ç»™å‡ºä¸€ä¸ªå¯ä»¥æ­£ç¡®ç¼–è¯‘å‡ºRV32Mæ‰©å±•æŒ‡ä»¤çš„æµ‹è¯•ç¨‹åºï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 #include \u0026#34;trap.h\u0026#34; #define N 10 int signed_arr[N] = {-128, -486, -312, -211, -154, 0, 11113, 26785, 3232, 488976}; unsigned unsigned_arr[N] = {0, 1112, 25678, 33425, 43455, 543421, 634567, 778789, 845653, 92442}; int main() { for (int i = 0; i \u0026lt; N; i++) { for (volatile int j = -N; j \u0026lt;= N; j++) { if (j == 0) { continue; } int quotient, remainder; quotient = signed_arr[i] / j; remainder = signed_arr[i] % j; check(signed_arr[i] == j * quotient + remainder); if (signed_arr[i] \u0026gt;= 0) { check(remainder \u0026gt;= 0 \u0026amp;\u0026amp; remainder \u0026lt; (j \u0026gt; 0 ? j : -j)); } else { check(remainder \u0026lt;= 0 \u0026amp;\u0026amp; remainder \u0026gt; (j \u0026gt; 0 ? -j : j)); } } } for (int i = 0; i \u0026lt; N; i++) { for (volatile unsigned j = 1; j \u0026lt;= N; j++) { unsigned quotient, remainder; quotient = unsigned_arr[i] / j; remainder = unsigned_arr[i] % j; check(unsigned_arr[i] == j * quotient + remainder); check(remainder \u0026lt; j); } } // overflow test volatile int dividend = 1 \u0026lt;\u0026lt; 31; volatile int divisor = -1; int quotient = dividend / divisor; int remainder = dividend % divisor; check(quotient == dividend); check(remainder == 0); return 0; } å¯¹åº”ç¼–è¯‘ç»“æœå¦‚ä¸‹ï¼š\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 80000000 \u0026lt;_start\u0026gt;: 80000000:\t00000413 li\ts0,0 80000004:\t00009117 auipc\tsp,0x9 80000008:\tffc10113 addi\tsp,sp,-4 # 80009000 \u0026lt;_end\u0026gt; 8000000c:\t1e0000ef jal\tra,800001ec \u0026lt;_trm_init\u0026gt; 80000010 \u0026lt;check\u0026gt;: 80000010:\t00050463 beqz\ta0,80000018 \u0026lt;check+0x8\u0026gt; 80000014:\t00008067 ret 80000018:\tff010113 addi\tsp,sp,-16 8000001c:\t00100513 li\ta0,1 80000020:\t00112623 sw\tra,12(sp) 80000024:\t1bc000ef jal\tra,800001e0 \u0026lt;halt\u0026gt; 80000028 \u0026lt;main\u0026gt;: 80000028:\tfd010113 addi\tsp,sp,-48 8000002c:\t02912223 sw\ts1,36(sp) 80000030:\t03212023 sw\ts2,32(sp) 80000034:\t01312e23 sw\ts3,28(sp) 80000038:\t01412c23 sw\ts4,24(sp) 8000003c:\t02112623 sw\tra,44(sp) 80000040:\t02812423 sw\ts0,40(sp) 80000044:\t01512a23 sw\ts5,20(sp) 80000048:\t00000917 auipc\ts2,0x0 8000004c:\t20490913 addi\ts2,s2,516 # 8000024c \u0026lt;signed_arr\u0026gt; 80000050:\t00000a17 auipc\ts4,0x0 80000054:\t224a0a13 addi\ts4,s4,548 # 80000274 \u0026lt;unsigned_arr\u0026gt; 80000058:\tff600993 li\ts3,-10 8000005c:\t00a00493 li\ts1,10 80000060:\t01312023 sw\ts3,0(sp) 80000064:\t00012783 lw\ta5,0(sp) 80000068:\t06f4c663 blt\ts1,a5,800000d4 \u0026lt;main+0xac\u0026gt; 8000006c:\t00012783 lw\ta5,0(sp) 80000070:\t04078863 beqz\ta5,800000c0 \u0026lt;main+0x98\u0026gt; 80000074:\t00092a83 lw\ts5,0(s2) 80000078:\t00012503 lw\ta0,0(sp) 8000007c:\t00012403 lw\ts0,0(sp) 80000080:\t00012783 lw\ta5,0(sp) 80000084:\t02aac533 div\ta0,s5,a0 80000088:\t028ae433 rem\ts0,s5,s0 8000008c:\t02f50533 mul\ta0,a0,a5 80000090:\t00850533 add\ta0,a0,s0 80000094:\t41550533 sub\ta0,a0,s5 80000098:\t00153513 seqz\ta0,a0 8000009c:\tf75ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000a0:\t00000513 li\ta0,0 800000a4:\t120ac063 bltz\ts5,800001c4 \u0026lt;main+0x19c\u0026gt; 800000a8:\t00044a63 bltz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800000ac:\t00012783 lw\ta5,0(sp) 800000b0:\t00012503 lw\ta0,0(sp) 800000b4:\t10f05463 blez\ta5,800001bc \u0026lt;main+0x194\u0026gt; 800000b8:\t00a42533 slt\ta0,s0,a0 800000bc:\tf55ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 800000c0:\t00012783 lw\ta5,0(sp) 800000c4:\t00178793 addi\ta5,a5,1 800000c8:\t00f12023 sw\ta5,0(sp) 800000cc:\t00012783 lw\ta5,0(sp) 800000d0:\tf8f4dee3 bge\ts1,a5,8000006c \u0026lt;main+0x44\u0026gt; 800000d4:\t00490913 addi\ts2,s2,4 800000d8:\tf94914e3 bne\ts2,s4,80000060 \u0026lt;main+0x38\u0026gt; 800000dc:\t00000917 auipc\ts2,0x0 800000e0:\t19890913 addi\ts2,s2,408 # 80000274 \u0026lt;unsigned_arr\u0026gt; 800000e4:\t00000a17 auipc\ts4,0x0 800000e8:\t1b8a0a13 addi\ts4,s4,440 # 8000029c \u0026lt;_bss_start\u0026gt; 800000ec:\t00100993 li\ts3,1 800000f0:\t00a00493 li\ts1,10 800000f4:\t01312223 sw\ts3,4(sp) 800000f8:\t00412783 lw\ta5,4(sp) 800000fc:\t04f4e863 bltu\ts1,a5,8000014c \u0026lt;main+0x124\u0026gt; 80000100:\t00092a83 lw\ts5,0(s2) 80000104:\t00412503 lw\ta0,4(sp) 80000108:\t00412403 lw\ts0,4(sp) 8000010c:\t00412783 lw\ta5,4(sp) 80000110:\t02aad533 divu\ta0,s5,a0 80000114:\t028af433 remu\ts0,s5,s0 80000118:\t02f50533 mul\ta0,a0,a5 8000011c:\t00850533 add\ta0,a0,s0 80000120:\t41550533 sub\ta0,a0,s5 80000124:\t00153513 seqz\ta0,a0 80000128:\tee9ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000012c:\t00412503 lw\ta0,4(sp) 80000130:\t00a43533 sltu\ta0,s0,a0 80000134:\teddff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000138:\t00412783 lw\ta5,4(sp) 8000013c:\t00178793 addi\ta5,a5,1 80000140:\t00f12223 sw\ta5,4(sp) 80000144:\t00412783 lw\ta5,4(sp) 80000148:\tfaf4fee3 bgeu\ts1,a5,80000104 \u0026lt;main+0xdc\u0026gt; 8000014c:\t00490913 addi\ts2,s2,4 80000150:\tfb4912e3 bne\ts2,s4,800000f4 \u0026lt;main+0xcc\u0026gt; 80000154:\t800007b7 lui\ta5,0x80000 80000158:\t00f12423 sw\ta5,8(sp) 8000015c:\tfff00793 li\ta5,-1 80000160:\t00f12623 sw\ta5,12(sp) 80000164:\t00812503 lw\ta0,8(sp) 80000168:\t00c12783 lw\ta5,12(sp) 8000016c:\t00812403 lw\ts0,8(sp) 80000170:\t00c12703 lw\ta4,12(sp) 80000174:\t02f54533 div\ta0,a0,a5 80000178:\t00812783 lw\ta5,8(sp) 8000017c:\t02e46433 rem\ts0,s0,a4 80000180:\t40f50533 sub\ta0,a0,a5 80000184:\t00153513 seqz\ta0,a0 80000188:\te89ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 8000018c:\t00143513 seqz\ta0,s0 80000190:\te81ff0ef jal\tra,80000010 \u0026lt;check\u0026gt; 80000194:\t02c12083 lw\tra,44(sp) 80000198:\t02812403 lw\ts0,40(sp) 8000019c:\t02412483 lw\ts1,36(sp) 800001a0:\t02012903 lw\ts2,32(sp) 800001a4:\t01c12983 lw\ts3,28(sp) 800001a8:\t01812a03 lw\ts4,24(sp) 800001ac:\t01412a83 lw\ts5,20(sp) 800001b0:\t00000513 li\ta0,0 800001b4:\t03010113 addi\tsp,sp,48 800001b8:\t00008067 ret 800001bc:\t40a00533 neg\ta0,a0 800001c0:\tef9ff06f j\t800000b8 \u0026lt;main+0x90\u0026gt; 800001c4:\tee804ce3 bgtz\ts0,800000bc \u0026lt;main+0x94\u0026gt; 800001c8:\t00012783 lw\ta5,0(sp) 800001cc:\t00012503 lw\ta0,0(sp) 800001d0:\t00f05463 blez\ta5,800001d8 \u0026lt;main+0x1b0\u0026gt; 800001d4:\t40a00533 neg\ta0,a0 800001d8:\t00852533 slt\ta0,a0,s0 800001dc:\tee1ff06f j\t800000bc \u0026lt;main+0x94\u0026gt; 800001e0 \u0026lt;halt\u0026gt;: 800001e0:\t00050513 mv\ta0,a0 800001e4:\t00100073 ebreak 800001e8:\t0000006f j\t800001e8 \u0026lt;halt+0x8\u0026gt; 800001ec \u0026lt;_trm_init\u0026gt;: 800001ec:\tff010113 addi\tsp,sp,-16 800001f0:\t00000517 auipc\ta0,0x0 800001f4:\t01c50513 addi\ta0,a0,28 # 8000020c \u0026lt;_etext\u0026gt; 800001f8:\t00112623 sw\tra,12(sp) 800001fc:\te2dff0ef jal\tra,80000028 \u0026lt;main\u0026gt; 80000200:\t00050513 mv\ta0,a0 80000204:\t00100073 ebreak 80000208:\t0000006f j\t80000208 \u0026lt;_trm_init+0x1c\u0026gt; ","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/div/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/div/","title":"å…³äºdivç­‰RV32MæŒ‡ä»¤æ— æ³•ç¼–è¯‘çš„é—®é¢˜"},{"content":"åœ¨NPCä¸­ä½¿ç”¨C++å®ç°å­˜å‚¨å™¨æ—¶ï¼Œå¯¹NEMUä¸­çš„å­˜å‚¨å™¨å†™å…¥/è¯»å‡ºå‡½æ•°æœ‰äº†ä¸€äº›æ–°çš„è®¤è¯†ï¼Œç°æ€»ç»“å¦‚ä¸‹ï¼š\næ­¤å¤„æˆ‘ä»¬ä¸ºæ–¹ä¾¿è¯´æ˜ï¼Œä»…è€ƒæŸ¥ä¸ç‰©ç†å­˜å‚¨å™¨ç›´æ¥äº¤äº’çš„å‡½æ•°ï¼Œå³pmemï¼ŒNEMUé¦–å…ˆåœ¨paddr.cä¸­å®šä¹‰äº†ä¸¤ä¸ªstaticå‡½æ•°ï¼Œåˆ†åˆ«ä¸ºpmem_read()ä¸pmem_write()ï¼Œç”¨äºå¯¹pmemè¿›è¡Œç›´æ¥è¯»å†™ã€‚\nåŒæ—¶ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå‡½æ•°è¢«å£°æ˜ä¸ºstaticï¼Œå…¶æ— æ³•é€šè¿‡å…¶ä»–æ–‡ä»¶è®¿é—®/è°ƒç”¨ï¼Œå› æ­¤paddr.cä¸­è¿˜å®šä¹‰äº†å¤–éƒ¨è®¿é—®çš„æ¥å£paddr_read()ä¸paddr_write()ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°ä¼šå¯¹è¾“å…¥çš„åœ°å€è¿›è¡Œæœ‰æ•ˆæ€§æ£€æµ‹ï¼Œéšåå†é€šè¿‡è°ƒç”¨pmem_read()ä¸pmem_write()å®ç°å­˜å‚¨å™¨è®¿é—®ã€‚\næˆ‘ä»¬å†çœ‹pmem_read()ä¸pmem_write()çš„å…·ä½“å®ç°ï¼š\nå¯¹pmem_read()ï¼š\n1 2 3 4 static word_t pmem_read(paddr_t addr, int len) { word_t ret = host_read(guest_to_host(addr), len); return ret; } è¯¥å‡½æ•°å†…éƒ¨ä¼šåµŒå¥—è°ƒç”¨ä¸¤ä¸ªå‡½æ•°ï¼Œguest_to_host()ä¸host_read()ï¼Œå…¶ä¸­guest_to_host()ç”¨äºå°†è¾“å…¥çš„pmemçš„ç‰©ç†åœ°å€addrè½¬æ¢æˆå®é™…PCå­˜å‚¨å™¨ä¸­çš„åœ°å€ï¼Œå®ç°å¦‚ä¸‹ï¼š\n1 uint8_t* guest_to_host(paddr_t paddr) { return pmem + paddr - CONFIG_MBASE; } å…·ä½“å®ç°åŸç†å³ä¸ºé€šè¿‡pmemæ‰€åœ¨çš„åŸºå€ï¼ŒåŠ ä¸Špaddr - CONFIG_MBASEçš„åç§»é‡ï¼Œå³è·å¾—äº†å¯¹åº”çš„PCå­˜å‚¨å™¨åœ°å€ï¼Œå…¶ä¸­CONFIG_BASEä»£è¡¨pmemçš„æœ€ä½åœ°å€ã€‚\nåŒæ—¶æ³¨æ„ï¼Œç”±äºè¯¥å‡½æ•°è¾“å‡ºçš„æ˜¯å­—èŠ‚ç¼–å€çš„å®é™…PCå­˜å‚¨å™¨åœ°å€ï¼Œå› æ­¤å¯¹åº”çš„è¿”å›ç±»å‹æ˜¯uint8_t*ï¼Œä¸ºä¸€ä¸ªæ— ç¬¦å·å­—èŠ‚ç±»å‹çš„æŒ‡é’ˆã€‚\nå†çœ‹host_read()çš„å®ç°ï¼Œåœ¨host.hä¸­ï¼š\n1 2 3 4 5 6 7 8 9 static inline word_t host_read(void *addr, int len) { switch (len) { case 1: return *(uint8_t *)addr; case 2: return *(uint16_t *)addr; case 4: return *(uint32_t *)addr; IFDEF(CONFIG_ISA64, case 8: return *(uint64_t *)addr); default: MUXDEF(CONFIG_RT_CHECK, assert(0), return 0); } } è¿™é‡Œå…¶å®æ˜¯ä¾æ®è¯»å‡ºå­—èŠ‚æ•°lençš„å–å€¼ï¼Œå¯¹å®é™…PCå­˜å‚¨å™¨åœ°å€è¿›è¡Œå¼ºåˆ¶ç±»å‹è½¬æ¢ï¼Œå¹¶é€šè¿‡è§£å¼•ç”¨*è·å–å¯¹åº”çš„å€¼ï¼Œæ¯”å¦‚å½“len = 2æ—¶ï¼Œä»£è¡¨éœ€è¦è¯»å–2å­—èŠ‚æ•°æ®ï¼Œå› æ­¤æˆ‘ä»¬å°†addrå¼ºåˆ¶ç±»å‹è½¬æ¢ä¸ºuint16_t*ç±»å‹ï¼Œä½¿å…¶æŒ‡å‘ä¸€ä¸ªåŒå­—èŠ‚å­˜å‚¨ç©ºé—´ï¼Œå†é€šè¿‡è§£å¼•ç”¨è·å¾—è¯¥å­˜å‚¨ç©ºé—´å¯¹åº”çš„å€¼ã€‚\npaddr_write()çš„å®ç°åŸç†ç±»ä¼¼ï¼Œæ­¤å¤„ä¸ä½œèµ˜è¿°ã€‚\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/nemu-memory/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/nemu-memory/","title":"å…³äºNEMUå­˜å‚¨å™¨è®¿é—®çš„ç»†èŠ‚"},{"content":"åœ¨ä½¿ç”¨Verilatorå¯¹RTLä»£ç è¿›è¡Œä»¿çœŸæ—¶ï¼Œå…¶ä»¿çœŸåŸç†ä¸æ™®é€šRTLä»£ç ç¼–å†™çš„Testbenchå­˜åœ¨å·®å¼‚ï¼Œå…·ä½“è€Œè¨€ï¼Œåœ¨Verilatorä¸­ï¼Œä»¿çœŸæ­¥é•¿è¿™ä¸€æ¦‚å¿µæ˜¯éœ€è¦é€šè¿‡wrapperæ–‡ä»¶è‡ªè¡Œæ§åˆ¶çš„ï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®ä»¿çœŸåœ¨å“ªäº›æ—¶é—´ç‚¹éœ€è¦é‡‡æ ·å¹¶eval()ï¼Œè€Œåœ¨ä¼ ç»ŸRTLä»£ç ç¼–å†™çš„Testbenchä¸­ï¼Œä»¿çœŸæ­¥é•¿é€šå¸¸æ˜¯é€šè¿‡timescaleå£°æ˜çš„ï¼ŒEDAä¼šè¯†åˆ«å¹¶è‡ªåŠ¨è®¾ç½®ä»¿çœŸæ­¥é•¿ã€‚\nè¿™ç§åŸç†ä¸Šçš„å·®å¼‚ä¼šé€ æˆVerilatorä¸ä¼ ç»ŸEDAåœ¨ä»¿çœŸæ—¶å­˜åœ¨ä¸¤æ–¹é¢çš„åŒºåˆ«ï¼š\næ€§èƒ½ä¸Šçš„å·®å¼‚ï¼š Verilatorçš„ä»¿çœŸåŸç†å…¶å®å¯æ¦‚æ‹¬ä¸ºâ€œå½“ç”¨æˆ·éœ€è¦æ—¶ï¼Œæ‰å¯¹æŸä¸ªæ—¶é—´ç‚¹é‡‡æ ·ä¸eval()â€ï¼Œè€Œä¼ ç»ŸEDAçš„ä»¿çœŸåŸç†åˆ™å¯ç®€å•ç†è§£ä¸ºâ€œå®šæ­¥é•¿å¯¹æ¯ä¸ªæ—¶é—´ç‚¹éƒ½è¿›è¡Œé‡‡æ ·ä¸eval()â€œã€‚å› æ­¤ï¼ŒVerilatorç›¸å¯¹è€Œè¨€å¯ä»¥è¾ƒæ•æ·åœ°å®Œæˆä»¿çœŸï¼Œå› ä¸ºåœ¨ä»¿çœŸè¿‡ç¨‹ä¸­ï¼Œå…¶å®å¹¶æ²¡æœ‰å¯¹æ‰€æœ‰æ—¶é—´ç‚¹å‡è¿›è¡Œé‡‡æ ·ä¸eval()ã€‚ æ³¢å½¢è´¨é‡ä¸Šçš„å·®å¼‚ï¼š ä¼ ç»ŸEDAçš„å®šæ­¥é•¿ä»¿çœŸä½¿å¾—å…¶ä»¿çœŸè·å¾—çš„æ³¢å½¢å…·æœ‰ç›¸å½“é«˜çš„å¯ä¿¡åº¦ï¼ŒåŸºæœ¬å¯ä»¥ä¸å®æµ‹æ³¢å½¢ç­‰åŒã€‚ä½†Verilatorçš„æ³¢å½¢è´¨é‡é«˜åº¦ä¾èµ–äºwrapperæ–‡ä»¶çš„å†™æ³•ï¼Œä¸€ä¸ªä½è´¨é‡æˆ–å†™æ³•é”™è¯¯çš„wrapperæ–‡ä»¶å®Œå…¨æœ‰å¯èƒ½ç”Ÿæˆä¸å®é™…æƒ…å†µå®Œå…¨ä¸åŒçš„æ³¢å½¢ï¼Œä¸¾ä¸€ä¸ªç®€å•çš„ä¾‹å­ï¼Œå‡è®¾æˆ‘ä»¬ä¸€ç›´ä»…å¯¹æ¨¡å—è¿›è¡Œæ¿€åŠ±è€Œä¸è°ƒç”¨eval()ï¼Œé‚£ä¹ˆæ³¢å½¢ä¸ä¼šæœ‰ä»»ä½•æœ‰æ•ˆä¿¡æ¯ï¼Œæ›´å…·ä½“ä¸€äº›ï¼Œå¦‚æœæˆ‘ä»¬æ”¹å˜æŸä¸ªç«¯å£çš„æ¿€åŠ±å€¼è€ŒæœªåŠæ—¶è¿›è¡Œeval()ï¼Œå¯èƒ½å¯¼è‡´æŸä¸ªä¿¡å·å€¼åœ¨æ³¢å½¢ä¸­è¢«é”™è¯¯åœ°å»¶è¿Ÿä¸€ä¸ªæˆ–å¤šä¸ªæ—¶é’Ÿå‘¨æœŸã€‚ å› æ­¤ï¼Œæœ‰å¿…è¦æ¢ç©¶æœ‰æ•ˆçš„wrapperæ–‡ä»¶å†™æ³•ï¼Œå› ä¸ºå½“æˆ‘ä»¬éœ€è¦é€šè¿‡æ³¢å½¢å¯¹æ¨¡å—è¿›è¡Œdebugæ—¶ï¼Œæˆ‘ä»¬è‡ªç„¶ä¸å¸Œæœ›æœ€åå‘ç°æ˜¯wrapperæ–‡ä»¶çš„å†™æ³•å¯¼è‡´ç”Ÿæˆä¸ç¬¦åˆé¢„æœŸçš„æ³¢å½¢ã€‚\né¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦æ˜ç¡®ï¼Œåœ¨wrapperæ–‡ä»¶ä¸­ï¼Œå…¶ä¸»è¦å®ç°äº†ä¸¤ç±»æ“ä½œï¼Œç¬¬ä¸€æ˜¯å®ç°æ¿€åŠ±ä¿¡å·çš„å˜åŒ–å¹¶é‡æ–°å¯¹è¢«æµ‹æ¨¡å—è¿›è¡Œeval()ï¼Œç¬¬äºŒåˆ™æ˜¯å®ç°æ³¢å½¢ä¸­æ—¶é—´çš„æ¨ç§»ï¼Œä¸ºæ­¤ï¼Œæˆ‘ä»¬ç»™å‡ºä¸€ä¸ªæ¨¡å¼åŒ–çš„wrapperæ–‡ä»¶å†™æ³•ï¼š\n1 2 3 #define Vtop Vysyx_25070184_top // nickname #define CLK_NAME clk // clock name #define CLK_HALF_PERIOD 5 // clock period / 2 åœ¨æ–‡ä»¶å¼€å¤´ï¼Œæˆ‘ä»¬å®ç°äº†å‡ ä¸ªå®å®šä¹‰ï¼Œå°†è¢«æµ‹é¡¶å±‚æ¨¡å—åç»Ÿä¸€ä¸ºtopï¼Œå°†æ—¶é’Ÿåç§°ç»Ÿä¸€ä¸ºCLK_NAMEï¼Œå¹¶å®šä¹‰ä»¿çœŸæ—¶çš„åŠæ—¶é’Ÿå‘¨æœŸé•¿åº¦CLK_HALF_PERIODã€‚\n1 2 #define EDGE_TRG_EVENT(top, event) do { top-\u0026gt;CLK_NAME = !top-\u0026gt;CLK_NAME; top-\u0026gt;eval(); event; top-\u0026gt;eval(); } while (0) #define EDGE_TRG(top) EDGE_TRG_EVENT(top, ) å…¶æ¬¡ï¼Œæˆ‘ä»¬å®ç°äº†å¦å¤–ä¸¤ä¸ªå®å®šä¹‰ï¼Œç”¨äºå®ç°æ¿€åŠ±ä¿¡å·çš„å˜åŒ–ï¼ŒEDGE_TRG_EVENTå®ç”¨äºå®ç°ä¸€ä¸ªè¢«æ—¶é’Ÿè¾¹æ²¿é©±åŠ¨çš„äº‹ä»¶eventï¼Œå…¶ä¸»è¦ä¼šè¿›è¡Œå¦‚ä¸‹ä¸¤ä¸ªæ“ä½œï¼š\nç¿»è½¬å½“å‰æ—¶é’Ÿå–å€¼ï¼Œè¿›è¡Œeval()ã€‚ æ‰§è¡Œäº‹ä»¶eventï¼Œå†æ¬¡è¿›è¡Œeval()ã€‚ è¿™ä¸ªå®å®šä¹‰å…¶å®ç›¸å½“äºä¼ ç»ŸRTLå®ç°çš„Testbenchä¸­çš„@(posedge/negedge clk) event;ã€‚\nå¦å¤–ä¸€ä¸ªå®å®šä¹‰EDGE_TRGåˆ™ç›¸å½“äºä»…å¯¹æ—¶é’Ÿè¿›è¡Œç¿»è½¬å¹¶eval()ï¼Œè€Œä¸å­˜åœ¨å…¶ä»–äº‹ä»¶çš„æ‰§è¡Œã€‚\næœ€åï¼Œæˆ‘ä»¬å®šä¹‰å¦å¤–ä¸€ä¸ªå‡½æ•°half_cycle()å®ç°æ³¢å½¢æ—¶é—´çš„æ¨ç§»ï¼š\n1 2 3 4 5 void half_cycle(Vtop* top, VerilatedContext* contextp, VerilatedFstC *tfp) { top-\u0026gt;eval(); contextp-\u0026gt;timeInc(CLK_HALF_PERIOD); tfp-\u0026gt;dump(contextp-\u0026gt;time()); } è¯¥å‡½æ•°ä¼šåœ¨æ³¢å½¢ä¸­äº§ç”ŸåŠæ—¶é’Ÿå‘¨æœŸçš„æ—¶é—´æ¨ç§»ï¼Œå› ä¸ºåœ¨ç‹­ä¹‰çš„åŒæ­¥æ—¶åºç”µè·¯ä¸­ï¼ŒåŠæ—¶é’Ÿå‘¨æœŸç›¸å½“äºä¸€ä¸ªæœ€å°çš„æ—¶é—´æ­¥é•¿ï¼Œåœ¨è¿™ä¸€æ—¶é—´é—´éš”å†…ä¸åº”å½“æœ‰ä»»ä½•ä¿¡å·å­˜åœ¨å˜åŒ–ã€‚\n","date":"2025-07-22T00:00:00Z","image":"https://posvirus.github.io/p/verilator/ysyx_hu_bf38ebd186ab1ff1.png","permalink":"https://posvirus.github.io/p/verilator/","title":"æµ…æVerilatorçš„wrapperæ–‡ä»¶å†™æ³•"}]